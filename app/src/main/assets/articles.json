[
  {
    "chapterId": 1,
    "chapterTitle": "Введение в Kotlin",
    "articles": [
      {
        "id": 1,
        "title": "Установка необходимого",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Установка необходимого"
          },
          {
            "type": "text",
            "content": "Перед началом работы с Kotlin следует отметить, что нам потребуется JDK (Java Development Kit). Перейдем на страницу:"
          },
          {
            "type": "url",
            "content": "https://www.oracle.com/java/technologies/downloads/"
          },
          {
            "type": "image",
            "content": "ch1ar1_1"
          },
          {
            "type": "image",
            "content": "ch1ar1_2"
          },
          {
            "type": "text",
            "content": "Нажмем на кнопку Next. На следующем экране необходимо указать, в какую папку будет производиться установка:"
          },
          {
            "type": "image",
            "content": "ch1ar1_3"
          },
          {
            "type": "text",
            "content": "Оставим выбор папки по умолчанию и нажмем на Next для выполнения установки.\n\nПосле завершения установки JDK мы увидим вот такое окно:"
          },
          {
            "type": "image",
            "content": "ch1ar1_4"
          },
          {
            "type": "text",
            "content": "Готово! Теперь, благодаря JDK, Kotlin сможет использовать библиотеки, написанные на Java"
          },
          {
            "type": "subtitle",
            "content": "Установка самого языка"
          },
          {
            "type": "text",
            "content": "Часто, при разработке, используют программу - среду разработки Intellij IDEA, которая во многом облегчает написание приложений на Kotlin. Скачать ее можно по ссылке:"
          },
          {
            "type": "url",
            "content": "https://www.jetbrains.com/idea/download/"
          },
          {
            "type": "text",
            "content": "Загрузить компилятор непосредственно для самого языка Kotlin можно в самом низу страницы, по адресу:"
          },
          {
            "type": "url",
            "content": "https://github.com/JetBrains/kotlin/releases/latest/."
          },
          {
            "type": "image",
            "content": "ch1ar1_5"
          },
          {
            "type": "text",
            "content": "Загрузим и распакуем из архива папку kotlinc. В распакованном архиве в папке bin мы можем найти утилиту kotlinc - этои есть компилятор Kotlin."
          },
          {
            "type": "image",
            "content": "ch1ar1_6"
          },
          {
            "type": "text",
            "content": "Теперь нам нужно добавить эту директорию в переменную окружения PATH. Пишем в поиске \"переменные окружения\" (или \"system environment variables\" если язык системы - английский) и следуем инструкции:"
          },
          {
            "type": "image",
            "content": "ch1ar1_7"
          },
          {
            "type": "image",
            "content": "ch1ar1_8"
          },
          {
            "type": "image",
            "content": "ch1ar1_9"
          },
          {
            "type": "text",
            "content": "Здесь нам нужно указать путь к распакованной папке с компилятором (желательно чтобы эта папка была в корне диска С)."
          },
          {
            "type": "image",
            "content": "ch1ar1_10"
          },
          {
            "type": "text",
            "content": "Готово! Теперь у вас установлен язык программирования Kotlin."
          }
        ]
      },
      {
        "id": 2,
        "title": "Первая программа",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Первая программа на Kotlin в IntelliJ IDEA"
          },
          {
            "type": "text",
            "content": "Зайдем в IntelliJ IDEA и создадим новый пустой проект."
          },
          {
            "type": "image",
            "content": "ch1ar1_11"
          },
          {
            "type": "text",
            "content": "После этого откроется окно создания нового проекта:"
          },
          {
            "type": "image",
            "content": "ch1ar1_12"
          },
          {
            "type": "text",
            "content": "В левой части мы можем увидеть структуру проекта. Все файлы с исходным кодом помещаются в папку src. По умолчанию она пуста, и никаких файлов кода у нас в проекте пока нет. Поэтому добавим файл с исходным кодом."
          },
          {
            "type": "image",
            "content": "ch1ar1_13"
          },
          {
            "type": "text",
            "content": "После этого нам откроется небольшое окошко, в которое надо ввести имя файла. Пусть файл будет называться app:"
          },
          {
            "type": "image",
            "content": "ch1ar1_14"
          },
          {
            "type": "text",
            "content": "После нажатия на клавишу Enter в папку src будет добавлен новый файл с кодом Kotlin (в нашем случае - файл app.kt). А в центральной части откроется его содержимое - собственно исходный код. По умолчанию он пуст. Поэтому добавим в него пакой-нибудь примитивный код:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    println(\"Hello from Learn Kotlin!\")\n}"
          },
          {
            "type": "text",
            "content": "Запустим эту примитивную программу на выполнение. Для этого нажмем на значок Kotlin рядом с первой строкой кода или на название файла и выберем в появившемся меню пункт Run 'AppKt':"
          },
          {
            "type": "image",
            "content": "ch1ar1_15"
          },
          {
            "type": "text",
            "content": "После этого будет выполнено построение проекта, и скомпилированная программа будет запущена в консоли в IntelliJ IDEA:"
          },
          {
            "type": "image",
            "content": "ch1ar1_16"
          },
          {
            "type": "text",
            "content": "Поздравляю с Вашей первой программой на Kotlin!"
          }
        ]
      }
      ]
  },
  {
    "chapterId": 2,
    "chapterTitle": "Основы языка",
    "articles": [
      {
        "id": 1,
        "title": "Структура программы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Структура программы\n"
          },
          {
            "type": "subtitle",
            "content": "Функция main"
          },
          {
            "type": "text",
            "content": "Точкой входа в программу на языке Kotlin является функция main. Именно с этой функции начинается выполнение программы на Kotlin, поэтому эта функция должна быть в любой программе."
          },
          {
            "type": "text",
            "content": "Так, в прошлой теме была определена следующая функция main:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    println(\"Hello from LearnKotlin!\")\n}"
          },
          {
            "type": "text",
            "content": "Определение функции main() (в принципе как и других функций в Kotlin) начинается с ключевого слова fun. После fun указывается имя функции."
          },
          {
            "type": "text",
            "content": "После имени функции в скобках идет список параметров функции. Здесь функция main не принимает никаких параметров."
          },
          {
            "type": "text",
            "content": "Все действия, которые выполняет функция, заключаются в фигурные скобки. В данном случае единственное, что делает функция main, - вывод на консоль некоторого сообщения с помощью другой встроенной функции println()."
          },
          {
            "type": "subtitle",
            "content": "\nИнструкции и блоки кода"
          },
          {
            "type": "text",
            "content": "Основным строительным блоком программы на языке Kotlin являются инструкции (statement).\n Каждая инструкция выполняет некоторое действие, например, вызовы функций, объявление переменных и присвоение им значений. Например:"
          },
          {
            "type": "code",
            "content": "println(\"Hello from LearnKotlin!\")"
          },
          {
            "type": "text",
            "content": "Данная строка представляет встроенную функцию println(), которая выводит на консоль, некоторое сообщение"
          },
          {
            "type": "text",
            "content": "Стоит отметить, что в отличие от других похожих языков программирования, например, Java, в Kotlin не обязательно ставить после инструкции точку с запятой. Каждая инструкция просто размещается на новой строке:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    println(\"Kotlin from LearnKotlin\")\n    println(\"Hello world!\")\n    println(\"Kotlin is a fun\")\n}"
          },
          {
            "type": "text",
            "content": "Тем не менее, если инструкции располагаются на одной строке, то чтобы их отделить друг от друга, надо указывать после инструкции точку с запятой:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    println(\"Kotlin from LearnKotlin\");println(\"Hello world!\");println(\"Kotlin is a fun\")\n}"
          },
          {
            "type": "subtitle",
            "content": "\nКомментарии"
          },
          {
            "type": "text",
            "content": "Код программы может содержать комментарии.\n Комментарии позволяют понять смысл программы, что делают те или иные ее части. При компиляции комментарии игнорируются."
          },
          {
            "type": "text",
            "content": "В Kotlin есть два типа комментариев: однострочный и многострочный. Однострочный комментарий размещается на одной строке после двойного слеша '//'.\n А многострочный комментарий заключается между символами \n/* текст комментария */\n Например:"
          },
          {
            "type": "code",
            "content": "/*\n    многострочный комментарий\n    Функция main -\n    точка входа в программу\n*/\nfun main(){         // начало функции main\n \n    println(\"Hello world!\") // вывод строки на консоль\n}                   // конец функции main"
          }
        ]
      },
      {
        "id": 2,
        "title": "Переменные",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Переменные"
          },
          {
            "type": "text",
            "content": "Переменная представляет именованный участок памяти, который хранит некоторое значение."
          },
          {
            "type": "text",
            "content": "Каждая переменная характеризуется определенным именем, типом данных и значением. \nДля определения переменной можно использовать либо ключевое слово val, либо ключевое слово var."
          },
          {
            "type": "text",
            "content": "Формальное определение переменной:"
          },
          {
            "type": "code",
            "content": "val|var имя_переменной: тип_переменной"
          },
          {
            "type": "text",
            "content": "Вначале идет слово val или var, затем имя переменной и через двоеточие тип переменной."
          },
          {
            "type": "text",
            "content": "Например, определим переменную age:"
          },
          {
            "type": "code",
            "content": "var age: Int"
          },
          {
            "type": "text",
            "content": "То есть в данном случае объявлена переменная age, которая имеет тип Int. Тип Int говорит о том, что переменная будет содержать целочисленные значения."
          },
          {
            "type": "text",
            "content": "После определения переменной ей можно присвоить значение (инициализировать):"
          },
          {
            "type": "code",
            "content": "fun main() {\n    var age: Int = 23\n    println(age)\n}"
          },
          {
            "type": "text",
            "content": "Обязательно нужно присваивать переменным некоторое значение до ее использования:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    var age: Int\n    println(age)// Ошибка, переменная не инициализирована\n}"
          },
          {
            "type": "subtitle",
            "content": "\nИзменяемые и неизменяемые переменные"
          },
          {
            "type": "text",
            "content": "Выше было сказано, что переменные могут объявляться как с помощью слова val, так и с помощью слова var.\nВ чем же разница?"
          },
          {
            "type": "text",
            "content": "С помощью ключевого слова val определяется неизменяемая переменная (immutable variable) или переменная только для чтения (read-only). То есть мы можем присвоить значение такой переменной только один раз, но изменить его после первого присвоения мы уже не сможем. Например, в следующем случае мы получим ошибку:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val age: Int\n    age = 23        // здесь норм - первое присвоение\n    age = 56        // здесь ошибка - переопределить значение переменной нельзя\n    println(age)\n}"
          },
          {
            "type": "text",
            "content": "А у переменной, которая определена с помощью ключевого слова var мы можем многократно менять значения (mutable variable):"
          },
          {
            "type": "code",
            "content": "fun main() {\n    var age: Int\n    age = 23\n    println(age)\n    age = 56\n    println(age)\n}"
          },
          {
            "type": "text",
            "content": "Поэтому если не планируется изменять значение переменной в программе, то лучше определять ее с ключевым словом val.\n"
          },
          {
            "type": "subtitle",
            "content": "\nОпределение констант"
          },
          {
            "type": "text",
            "content": "Также Kotlin поддерживает константы времени компиляции. Для их определения применяются ключевые слова const val:"
          },
          {
            "type": "code",
            "content": "const val maxAge = 120  // константа\nfun main() {\n    println(maxAge)\n}"
          },
          {
            "type": "text",
            "content": "В данном случае maxAge является константой."
          },
          {
            "type": "text",
            "content": "Отличительной особенностью констант является то, что они на стадии компиляции должны иметь некоторое значение, и это значение изменить нельзя. Это накладывает на использование констант ряд ограничений:"
          },
          {
            "type": "text",
            "content": "1) Естественно нельзя изменить значение константы:"
          },
          {
            "type": "code",
            "content": "const val maxAge = 120  // константа\nfun main() {\n    maxAge = 1500   // ошибка \n    println(maxAge)\n}"
          },
          {
            "type": "text",
            "content": "Здесь при попытке присвоения константе maxAge нового значения в функции main мы столкнемся с ошибкой на стадии компиляции. \nЕсли мы работаем в среде Intellij IDEA или Android Studio, то уже при написании кода на подобные ошибки укажет сама среда разработки."
          },
          {
            "type": "text",
            "content": "2) Константа должна объявляться на самом верхнем уровне (вне класса/функции):"
          },
          {
            "type": "code",
            "content": "fun main() {\n    const val maxAge = 120   // ошибка \n    println(maxAge)\n}"
          },
          {
            "type": "text",
            "content": "3) Тип данных константы должен соответствовать одному из примитивных (например, Int) или типу String\n"
          },
          {
            "type": "text",
            "content": "Также стоит отметить отличие val-переменных от констант (const val):\nЗначение val-переменных устанавливается во время выполнения, а значение констант - во время компиляции. \nЗначение val-переменной также нельзя изменить после установки. \nКонстанте необходимо присвоить значение сразу при определении."
          }
        ]
      },
      {
        "id": 3,
        "title": "Основные типы данных",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Основные типы"
          },
          {
            "type": "text",
            "content": "В данном разделе описываются основные типы: числа, логические переменные, символы, строки и массивы."
          },
          {
            "type": "subtitle",
            "content": "\nЧисла\nЦелочисленные типы"
          },
          {
            "type": "text",
            "content": "\t• Byte: хранит целое число от -128 до 127 и занимает 1 байт\n\n\t• Short: хранит целое число от -32 768 до 32 767 и занимает 2 байта\n\n\t• Int: хранит целое число от -2 147 483 648 до 2 147 483 647  и занимает 4 байта\n\n\t• Long: хранит целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт"
          },
          {
            "type": "code",
            "content": "val one = 1 // Int\nval threeBillion = 3000000000 // Long\nval oneLong = 1L // Long\nval oneByte: Byte = 1"
          },
          {
            "type": "text",
            "content": "Кроме чисел в десятичной системе мы можем определять числа в двоичной и шестнадцатеричной системах.\n\nШестнадцатеричная запись числа начинается с 0x, затем идет набор символов от 0 до F, которые представляют число:"
          },
          {
            "type": "code",
            "content": "val num: Int = 0x0A1\nprintln(num) // 161"
          },
          {
            "type": "text",
            "content": "Двоичная запись числа предваряется символами 0b, после которых идет последовательность из нулей и единиц:"
          },
          {
            "type": "subtitle",
            "content": "\nЧисла с плавающей точкой"
          },
          {
            "type": "text",
            "content": "Для действительных чисел в Kotlin есть типы с плавающей точкой Float и Double. \nСогласно стандарту IEEE 754, типы с плавающей точкой различаются своим десятичным разрядом, то есть количеством десятичных цифр, которые они могут хранить. С точки зрения IEEE 754, Float является одинарно точным, а Double обеспечивает двойную точность."
          },
          {
            "type": "text",
            "content": "В качестве разделителя целой и дробной части применяется точка:"
          },
          {
            "type": "code",
            "content": "val pi = 3.14 // Double\n// val one: Double = 1 // Ошибка: несоответствие типов\nval oneDouble = 1.0 // Double"
          },
          {
            "type": "text",
            "content": "Чтобы явно указать тип Float, добавьте после значения f или F. Если такое значение содержит более 6-7 разрядов, оно будет округлено."
          },
          {
            "type": "code",
            "content": "val e = 2.7182818284 // Double\nval eFloat = 2.7182818284f // Float, фактическое значение 2.7182817"
          },
          {
            "type": "text",
            "content": "Также тип Double поддерживает экспоненциальную запись:"
          },
          {
            "type": "code",
            "content": "val d: Double = 23e3\nprintln(d)      // 23 000\n \nval g: Double = 23e-3\nprintln(g)      // 0.023"
          },
          {
            "type": "subtitle",
            "content": "\nЛогический тип Boolean"
          },
          {
            "type": "text",
            "content": "Тип Boolean может хранить одно из двух значений: true (истина) или false (ложь)."
          },
          {
            "type": "code",
            "content": "val a: Boolean = true\nval b: Boolean = false"
          },
          {
            "type": "subtitle",
            "content": "\nСимволы"
          },
          {
            "type": "text",
            "content": "Символьные данные представлены типом Char. Он представляет отдельный символ, который заключается в одинарные кавычки."
          },
          {
            "type": "code",
            "content": "val a: Char = 'A'\nval b: Char = 'B'\nval c: Char = 'C'"
          },
          {
            "type": "subtitle",
            "content": "Строки"
          },
          {
            "type": "text",
            "content": "Строки представлены типом String. Строка представляет последовательность символов, заключенную в двойные кавычки, либо в тройные двойные кавычки."
          },
          {
            "type": "code",
            "content": "fun main() {\n     \n    val name: String = \"Eugene\"\n \n    println(name)\n}"
          },
          {
            "type": "text",
            "content": "Для большего удобства при создании многострочного текста можно использовать тройные двойные кавычки:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val text: String = \"\"\"\n                        SALT II was a series of talks between United States\n                        and Soviet negotiators from 1972 to 1979.\n                        It was a continuation of the SALT I talks.\n                    \"\"\"\n    println(text)\n}"
          },
          {
            "type": "subtitle",
            "content": "\nШаблоны строк"
          },
          {
            "type": "text",
            "content": "Шаблоны строк (string templates) представляют удобный способ вставки в строку различных значений, в частности, значений переменных. \nТак, с помощью знака доллара $ мы можем вводить в строку значения различных переменных:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val firstName = \"Tom\"\n    val lastName = \"Smith\"\n    val welcome = \"Hello, $firstName $lastName\"\n    println(welcome)    // Hello, Tom Smith\n}"
          },
          {
            "type": "text",
            "content": "В данном случае вместо $firstName и $lastName будут вставляться значения этих переменных. При этом переменные необязательно должны представлять строковый тип:"
          },
          {
            "type": "code",
            "content": "val name = \"Tom\"\nval age = 22\nval userInfo = \"Your name: $name  Your age: $age\""
          },
          {
            "type": "subtitle",
            "content": "\nВыведение типа"
          },
          {
            "type": "text",
            "content": "Kotlin позволяет выводить тип переменной на основании данных, которыми переменная инициализируется. Поэтому при инициализации переменной тип можно опустить:"
          },
          {
            "type": "code",
            "content": "val age = 5"
          },
          {
            "type": "text",
            "content": "В данном случае компилятор увидит, что переменной присваивается значение типа Int, поэтому переменная age будет представлять тип Int.\n\nСоответственно если мы присваиваем переменной строку, то такая переменная будет иметь тип String."
          },
          {
            "type": "code",
            "content": "val name = \"Tom\""
          },
          {
            "type": "text",
            "content": "Любые целые числа, воспринимаются как данные типа Int.\n\nЕсли же мы хотим явно указать, что число представляет значение типа Long, то следует использовать суффикс L:"
          },
          {
            "type": "code",
            "content": "val sum = 45L"
          },
          {
            "type": "text",
            "content": "Если надо указать, что объект представляет беззнаковый тип, то применяется суффикс u или U:"
          },
          {
            "type": "code",
            "content": "val sum = 45U"
          },
          {
            "type": "text",
            "content": "Аналогично все числа с плавающей точкой (которые содержат точку в качестве разделителя целой и дробной части) рассматриваются как числа типа Double:"
          },
          {
            "type": "code",
            "content": "val height = 1.78"
          },
          {
            "type": "text",
            "content": "Если мы хотим указать, что данные будут представлять тип Float, то необходимо использовать суффикс f или F:"
          },
          {
            "type": "code",
            "content": "val height = 1.78F"
          },
          {
            "type": "text",
            "content": "Однако нельзя сначала объявить переменную без указания типа, а потом где-то в программе присвоить ей какое-то значение:"
          },
          {
            "type": "code",
            "content": "val age     // Ошибка, переменная не инициализирована\nage = 5 "
          },
          {
            "type": "subtitle",
            "content": "\nСтатическая типизация"
          },
          {
            "type": "text",
            "content": "Тип данных ограничивает набор значений, которые мы можем присвоить переменной. \nНапример, мы не можем присвоить переменной типа Double строку:"
          },
          {
            "type": "code",
            "content": "val height: Double = \"1.78\"   //Ошибка"
          },
          {
            "type": "text",
            "content": "И после того, как тип переменной установлен, он не может быть изменен:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    var height: String = \"1.78\"\n    height = 1.81       // !Ошибка - переменная height хранит только строки\n    println(height)\n}"
          },
          {
            "type": "text",
            "content": "Кроме того, мы не можем переменной одного типа напрямую присвоить значение переменной другого типа. Например:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    var longN: Long = 2\n    var intN: Int = 4\n    longN = intN   // ! Ошибка\n    println(longN)\n}"
          },
          {
            "type": "text",
            "content": "Мы можем решить эту проблему: Kotlin предоставляет нам ряд встроенных функций для преобразования данных к определенному типу:"
          },
          {
            "type": "text",
            "content": "\t• toByte()\n\n\t• toShort()\n\n\t• toInt()\n\n\t• toLong()\n\n\t• toFloat()\n\n\t• toDouble()\n\n\t• toChar()"
          },
          {
            "type": "text",
            "content": "Так, мы можем изменить пример выше, применив функцию toLong:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    var longN: Long = 2\n    var intN: Int = 4\n    longN = intN.toLong()   // Ошибки нет\n    println(longN)\n}"
          },
          {
            "type": "subtitle",
            "content": "\nТип Any"
          },
          {
            "type": "text",
            "content": "В Kotlin также есть тип Any, который позволяет присвоить переменной данного типа любое значение:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    var name: Any = \"Tom\"\n    println(name)   // Tom\n    name = 6758\n    println(name)   // 6758\n}"
          }
        ]
      },
      {
        "id": 4,
        "title": "Консольный ввод и вывод",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Вывод на консоль"
          },
          {
            "type": "text",
            "content": "Для вывода информации на консоль в Kotlin есть две встроенные функции:"
          },
          {
            "type": "code",
            "content": "print()\nprintln()"
          },
          {
            "type": "text",
            "content": "Обе эти функции принимают некоторый объект, который надо вывести на консоль, обычно это строка. \nРазличие между ними состоит в том, что функция println() при выводе на консоль добавляет перевод на новую строку:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    print(\"Hello \")\n    print(\"Kotlin \")\n    println()\n    println(\"Kotlin is a fun\")\n}"
          },
          {
            "type": "text",
            "content": "Причем функция println() необязательно должна принимать некоторое значения. Так, здесь применяется пустой вызов функции, который просто перевод консольный вывод на новую строку:"
          },
          {
            "type": "code",
            "content": "println()"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Hello Kotlin\nKotlin is a fun"
          },
          {
            "type": "subtitle",
            "content": "\nВвод с консоли"
          },
          {
            "type": "text",
            "content": "Для ввода с консоли применяется встроенная функция readLine() (в новых версиях языка - readln()). Она возвращает введенную строку. \nСтоит отметить, что результат этой функции всегда представляет объект типа String. Соответственно введеную строку мы можем передать в переменную типа String:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    print(\"Введите имя: \")\n    val name = readLine()\n \n    println(\"Ваше имя: $name\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь сначала выводится приглашение к вводу данных. Далее введенное значение передается в переменную name. Результат работы программы:"
          },
          {
            "type": "code",
            "content": "Введите имя: Константин\nВаше имя: Константин"
          },
          {
            "type": "text",
            "content": "Подобным образом можно вводить разные данные:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    print(\"Введите имя: \")\n    val name = readLine()\n    print(\"Введите email: \")\n    val email = readLine()\n    print(\"Введите адрес: \")\n    val address = readLine()\n \n    println(\"Ваше имя: $name\")\n    println(\"Ваш email: $email\")\n    println(\"Ваш адрес: $address\")\n}"
          },
          {
            "type": "text",
            "content": "Пример работы программы:"
          },
          {
            "type": "code",
            "content": "Введите имя: Константин\nВведите email: qwerty123@mail.ru\nВведите адрес: ул. Вершинина, д.39А, кв. 410\nВаше имя: Константин\nВаш email: qwerty123@mail.ru\nВаш адрес: ул. Кленов, д.31, кв. 20"
          }
        ]
      },
      {
        "id": 5,
        "title": "Операции с числами",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Арифметические операции"
          },
          {
            "type": "text",
            "content": "Kotlin поддерживает базовые арифметические операции:"
          },
          {
            "type": "text",
            "content": "\t• '+' (сложение): возвращает сумму двух чисел."
          },
          {
            "type": "code",
            "content": "val x = 5\nval y = 6\nval z = x + y\nprintln(z)      // z = 11"
          },
          {
            "type": "text",
            "content": "\t• '-' (вычитание): возвращает разность двух чисел."
          },
          {
            "type": "code",
            "content": "val x = 5\nval y = 6\nval z = x - y  // z = -1"
          },
          {
            "type": "text",
            "content": "\t• '*' (умножение): возвращает произведение двух чисел."
          },
          {
            "type": "code",
            "content": "val x = 5\nval y = 6\nval z = x * y  // z = 30"
          },
          {
            "type": "text",
            "content": "\t• '/' (деление): возвращает частное двух чисел."
          },
          {
            "type": "code",
            "content": "val x = 60\nval y = 10\nval z = x / y  // z = 6"
          },
          {
            "type": "text",
            "content": "При этом если в операции деления оба операнда представляют целые числа, то результатом тоже будет целое число, а если в процессе деления образовалась дробная часть, то она отбрасывается:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val x = 11\n    val y = 5\n    val z = x / y  // z = 2\n    println(z)// 2\n}"
          },
          {
            "type": "text",
            "content": "Так в данном случае, хотя если согласно стандартной математике разделить 11 на 5, то получится 2.2. Однако поскольку оба операнда представляют целочисленный тип, а именно тип Int, то дробная часть - 0.2 отрабрасывается, поэтому результатом будет число 2, а переменная z будет представлять тип Int.\n\nЧтобы результатом было дробное число, один из операндов должен представлять число с плавающей точкой:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val x = 11\n    val y = 5.0\n    val z = x / y   // z = 2.2\n    println(z)      // 2.2\n}"
          },
          {
            "type": "text",
            "content": "В данном случае переменная y представляет тип Double, поэтому результатом деления будет число 2.2, а переменная z также будет представлять тип Double"
          },
          {
            "type": "text",
            "content": "\t• '%': возвращает остаток от целочисленного деления двух чисел."
          },
          {
            "type": "code",
            "content": "val x = 65\nval y = 10\nval z = x % y  // z = 5"
          },
          {
            "type": "text",
            "content": "\t• '++' (инкремент): увеличивает значение на единицу."
          },
          {
            "type": "text",
            "content": "\t  Префиксный инкремент возвращает увеличенное значение:"
          },
          {
            "type": "code",
            "content": "var x = 5\nval y = ++x\nprintln(x)      // x = 6\nprintln(y)      // y = 6"
          },
          {
            "type": "text",
            "content": "\t  Постфиксный инкремент возвращает значение до увеличения на единицу:"
          },
          {
            "type": "code",
            "content": "var x = 5\nval y = x++\nprintln(x)      // x = 6\nprintln(y)      // y = 5"
          },
          {
            "type": "text",
            "content": "\t• '--' (декремент): уменьшает значение на единицу."
          },
          {
            "type": "text",
            "content": "\t  Префиксный декремент возвращает уменьшенное значение:"
          },
          {
            "type": "code",
            "content": "var x = 5\nval y = --x\nprintln(x)      // x = 4\nprintln(y)      // y = 4"
          },
          {
            "type": "text",
            "content": "\t  Постфиксный декремент возвращает значение до уменьшения на единицу:"
          },
          {
            "type": "code",
            "content": "var x = 5\nval y = x--\nprintln(x)      // x = 4\nprintln(y)      // y = 5"
          },
          {
            "type": "text",
            "content": "Также есть ряд операций присвоения, которые сочетают арифметические операции и присвоение:"
          },
          {
            "type": "text",
            "content": "\t• '+=': присваивание после сложения. Присваивает левому операнду сумму левого и правого операндов: A += B эквивалентно A = A + B"
          },
          {
            "type": "text",
            "content": "\t• '-=': присваивание после вычитания. Присваивает левому операнду разность левого и правого операндов: A -= B эквивалентно A = A - B"
          },
          {
            "type": "text",
            "content": "\t• '*=': присваивание после умножения. Присваивает левому операнду произведение левого и правого операндов: A *= B эквивалентно A = A * B"
          },
          {
            "type": "text",
            "content": "\t• '/=': присваивание после деления. Присваивает левому операнду частное левого и правого операндов: A /= B эквивалентно A = A / B"
          },
          {
            "type": "text",
            "content": "\t• '%=': присваивание после деления по модулю. Присваивает левому операнду остаток от целочисленного деления левого операнда на правый: A %= B эквивалентно A = A % B"
          },
          {
            "type": "subtitle",
            "content": "\nПоразрядные операции"
          },
          {
            "type": "text",
            "content": "Ряд операций выполняется над двоичными разрядами числа. \nЗдесь важно понимать, как выглядит двоичное представление тех или иных чисел. В частности, число 4 в двоичном виде - 100, а число 15 - 1111.\n\nЕсть следующие поразрядные операторы (они применяются только к данным типов Int и Long):"
          },
          {
            "type": "text",
            "content": "\t• 'shl': сдвиг битов числа со знаком влево"
          },
          {
            "type": "code",
            "content": "val z = 3 shl 2     // z = 11 << 2 = 1100 \nprintln(z)          // z = 12\nval d = 0b11 shl 2\nprintln(d)          // d = 12"
          },
          {
            "type": "text",
            "content": "В данном случае число сдвигается на два разряда влево, поэтому справа число в двоичном виде дополняется двумя нулями. То есть в двоичном виде 3 представляет 11. Сдвигаем на два разряда влево (дополняем справа двумя нулями) и получаем 1100, то есть в десятичной системе число 12."
          },
          {
            "type": "text",
            "content": "\t• 'shr': сдвиг битов числа со знаком вправо"
          },
          {
            "type": "code",
            "content": "val z = 12 shr 2     // z = 1100 >> 2 = 11\nprintln(z)          // z = 3\nval d = 0b1100 shr 2\nprintln(d)          // d = 3"
          },
          {
            "type": "text",
            "content": "Число 12 сдвигается на два разряда вправо, то есть два числа справа факически отбрасываем и получаем число 11, то есть 3 в десятичой системе."
          },
          {
            "type": "text",
            "content": "\t• 'ushr': сдвиг битов беззнакового числа вправо"
          },
          {
            "type": "code",
            "content": "val z = 12 ushr 2     // z = 1100 >> 2 = 11\nprintln(z)          // z = 3"
          },
          {
            "type": "text",
            "content": "\t• 'and': побитовая операция AND (логическое умножение или конъюнкция). Эта операция сравнивает соответствующие разряды двух чисел и возвращает единицу, если эти разряды обоих чисел равны 1. Иначе возвращает 0."
          },
          {
            "type": "code",
            "content": "val x = 5   // 101\nval y = 6   // 110\nval z = x and y     // z = 101 & 110 = 100\nprintln(z)          // z = 4\n \nval d = 0b101 and 0b110\nprintln(d)          // d = 4"
          },
          {
            "type": "text",
            "content": "\t• 'or': побитовая операция OR (логическое сложение или дизъюнкция). Эта операция сравнивают два соответствуюших разряда обоих чисел и возвращает 1, если хотя бы один разряд равен 1. Если оба разряда равны 0, то возвращается 0."
          },
          {
            "type": "code",
            "content": "val x = 5   // 101\nval y = 6   // 110\nval z = x or y     // z = 101 | 110 = 111\nprintln(z)         // z = 7\n \nval d = 0b101 or 0b110\nprintln(d)          // d = 7"
          },
          {
            "type": "text",
            "content": "\t• 'xor': побитовая операция XOR. Сравнивает два разряда и возвращает 1, если один из разрядов равен 1, а другой равен 0. Если оба разряда равны, то возвращается 0."
          },
          {
            "type": "code",
            "content": "val x = 5   // 101\nval y = 6   // 110\nval z = x xor y     // z = 101 ^ 110 = 011\nprintln(z)         // z = 3\n \nval d = 0b101 xor 0b110\nprintln(d)          // d = 3"
          },
          {
            "type": "text",
            "content": "\t• 'inv': логическое отрицание или инверсия - инвертирует биты числа"
          },
          {
            "type": "code",
            "content": "val b = 11  // 1011\nval c = b.inv()\nprintln(c)      // -12"
          }
        ]
      },
      {
        "id": 6,
        "title": "Условные выражения",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Условные выражения"
          },
          {
            "type": "text",
            "content": "Условные выражения представляют некоторое условие, которое возвращает значение типа Boolean: либо true (если условие истинно), либо false (если условие ложно)."
          },
          {
            "type": "subtitle",
            "content": "\nОперации отношения"
          },
          {
            "type": "text",
            "content": "\t• '>' (больше чем): возвращает true, если первый операнд больше второго. Иначе возвращает false"
          },
          {
            "type": "code",
            "content": "val a = 11\nval b = 12\nval c : Boolean =  a > b\nprintln(c)      // false - a меньше чем b\n \nval d = 35 > 12\nprintln(d)      // true - 35 больше чем 12"
          },
          {
            "type": "text",
            "content": "\t• '<' (меньше чем): возвращает true, если первый операнд меньше второго. Иначе возвращает false"
          },
          {
            "type": "code",
            "content": "val a = 11\nval b = 12\nval c =  a < b   // true\n \nval d = 35 < 12  // false"
          },
          {
            "type": "text",
            "content": "\t• '>=' (больше чем или равно): возвращает true, если первый операнд больше или равен второму"
          },
          {
            "type": "code",
            "content": "val a = 11\nval b = 12\nval c = a >= b      // false\nval d = 11 >= a     // true"
          },
          {
            "type": "text",
            "content": "\t• '<=' (меньше чем или равно): возвращает true, если первый операнд меньше или равен второму."
          },
          {
            "type": "code",
            "content": "val a = 11\nval b = 12\nval c = a <= b      // true\nval d = 15 <= a     // false"
          },
          {
            "type": "text",
            "content": "\t• '==' (равно): возвращает true, если оба операнда равны. Иначе возвращает false"
          },
          {
            "type": "code",
            "content": "val a = 11\nval b = 12\nval c = a == b      // false\nval d = b == 12     // true"
          },
          {
            "type": "text",
            "content": "\t• '!=' (не равно): возвращает true, если оба операнда НЕ равны"
          },
          {
            "type": "code",
            "content": "val a = 11\nval b = 12\nval c = a != b      // true\nval d = b != 12     // false"
          },
          {
            "type": "subtitle",
            "content": "\nЛогические операции"
          },
          {
            "type": "text",
            "content": "Операндами в логических операциях являются два значения типа Boolean. Нередко логические операции объединяют несколько операций отношения:"
          },
          {
            "type": "text",
            "content": "\t• 'and' возвращает true, если оба операнда равны true."
          },
          {
            "type": "code",
            "content": "val a = true\nval b = false\nval c = a and b                         // false\nval d = (11 >= 5) and (9 < 10)     // true"
          },
          {
            "type": "text",
            "content": "\t• 'or' возвращает true, если хотя бы один из операндов равен true."
          },
          {
            "type": "code",
            "content": "val a = true\nval b = false\nval c = a or b                          // true\nval d = (11 < 5) or (9 > 10)     // false"
          },
          {
            "type": "text",
            "content": "\t• 'xor' возвращает true, если только один из операндов равен true. Если операнды равны, возвращается false"
          },
          {
            "type": "code",
            "content": "val a = true\nval b = false\nval c = a xor b                 // true\nval d = a xor (90 > 10)      // false"
          },
          {
            "type": "text",
            "content": "\t• '!' возвращает true, если операнд равен false. И, наоборот, если операнд равен true, возвращается false"
          },
          {
            "type": "code",
            "content": "val a = true\nval b = !a  // false\nval c = !b  // true"
          },
          {
            "type": "text",
            "content": "В качестве альтернативы оператору ! можно использовать метод not():"
          },
          {
            "type": "code",
            "content": "val a = true\nval b = a.not()  // false\nval c = b.not()  // true"
          },
          {
            "type": "text",
            "content": "\t• 'in' возвращает true, если операнд имеется в некоторой последовательности."
          },
          {
            "type": "code",
            "content": "val a = 5\nval b = a in 1..6       // true - число 5 входит в последовательность от 1 до 6\n \nval c = 4\nval d = c in 11..15     // false - число 4 НЕ входит в последовательность от 11 до 15"
          },
          {
            "type": "text",
            "content": "Если нам, наоборот, хочется возвращать true, если числа нет в указанной последовательности, то можно применить комбинацию операторов !in:"
          },
          {
            "type": "code",
            "content": "val a = 8\nval b = a !in 1..6      // true - число 8 не входит в последовательность от 1 до 6"
          }
        ]
      },
      {
        "id": 7,
        "title": "Условные конструкции",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Условные конструкции"
          },
          {
            "type": "text",
            "content": "Условные конструкции позволяют направить выполнение программы по одному из путей в зависимости от условия.\n\nКонструкция if принимает условие, и если это условие истинно, то выполняется последующий блок инструкций."
          },
          {
            "type": "code",
            "content": "val a = 10\nif(a == 10) {\n \n    println(\"a равно 10\")\n}"
          },
          {
            "type": "text",
            "content": "Если необходимо задать альтернативный вариант, то можно добавить блок else (иначе):"
          },
          {
            "type": "code",
            "content": "val a = 10\nif(a == 10) {\n    println(\"a равно 10\")\n}\nelse{\n    println(\"a НЕ равно 10\")\n}"
          },
          {
            "type": "text",
            "content": "Таким образом, если условное выражение после оператора if истинно, то выполняется блок после if, если ложно - выполняется блок после else.\n\nЕсли блок кода состоит из одного выражения, то в принципе фигурные скобки можно опустить:"
          },
          {
            "type": "code",
            "content": "val a = 10\nif(a == 10)\n    println(\"a равно 10\")\nelse\n    println(\"a НЕ равно 10\")"
          },
          {
            "type": "text",
            "content": "Если необходимо проверить несколько альтернативных вариантов, то можно добавить выражения else if:"
          },
          {
            "type": "code",
            "content": "val a = 10\nif(a == 10) {\n    println(\"a равно 10\")\n}\nelse if(a == 9){\n    println(\"a равно 9\")\n}\nelse if(a == 8){\n    println(\"a равно 8\")\n}\nelse{\n    println(\"a имеет неопределенное значение\")\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВозвращение значения из if"
          },
          {
            "type": "text",
            "content": "Конструкция if может возвращать значение. Например, найдем максимальное из двух чисел:"
          },
          {
            "type": "code",
            "content": "val a = 10\nval b = 20\nval c = if (a > b) a else b\n \nprintln(c)  // 20"
          },
          {
            "type": "text",
            "content": "Аналогично можно использовать else if:"
          },
          {
            "type": "code",
            "content": "val a = 20\nval b = 20\nval c = if (a > b) 1 else if (a < b) -1 else 0\n \nprintln(c)  // 0"
          },
          {
            "type": "text",
            "content": "Если при определении возвращаемого значения надо выполнить еще какие-нибудь действия, то можно заключить эти действия в блоки кода:"
          },
          {
            "type": "code",
            "content": "val a = 10\nval b = 20\nval c = if (a > b){\n    println(\"a = $a\")\n    a\n} else {\n    println(\"b = $b\")\n    b\n}"
          },
          {
            "type": "text",
            "content": "В конце каждого блока указывается возвращаемое значение."
          },
          {
            "type": "subtitle",
            "content": "\nКонструкция when"
          },
          {
            "type": "text",
            "content": "Конструкция when проверяет значение некоторого объекта и в зависимости от его значения выполняет тот или иной код. Конструкция when аналогична конструкции switch в других языках. "
          },
          {
            "type": "code",
            "content": "when(объект){\n     \n    значение1 -> действия1\n    значение2 -> действия2\n     \n    значениеN -> действияN\n}"
          },
          {
            "type": "text",
            "content": "Если значение объекта равно одному из значений в блоке кода when, то выполняются соответствующие действия, которые идут после оператора -> после соответствующего значения."
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val isEnabled = true\n    when(isEnabled){\n        false -> println(\"isEnabled off\")\n        true -> println(\"isEnabled on\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь в конструкцию when передается переменная isEnabled. Далее ее значение по сравнивается со значениями в false и true. В данном случае переменная isEnabled равна true, поэтому будет выполняться код"
          },
          {
            "type": "code",
            "content": "println(\"isEnabled on\")"
          },
          {
            "type": "text",
            "content": "В примере выше переменная isEnabled имела только два возможных варианта: true и false. \nОднако чаще бывают случаи, когда значения в блоке when не покрывают все возможные значения объекта. Дополнительное выражение else позволяет задать действия, которые выполняются, если объект не соответствует ни одному из значений. Например:"
          },
          {
            "type": "code",
            "content": "val a = 30\nwhen(a){\n    10 -> println(\"a = 10\")\n    20 -> println(\"a = 20\")\n    else -> println(\"неопределенное значение\")\n}"
          },
          {
            "type": "subtitle",
            "content": "\nСравнение с набором значений"
          },
          {
            "type": "text",
            "content": "Можно определить одни и те же действия сразу для нескольких значений. В этом случае значения перечисляются через запятую:"
          },
          {
            "type": "code",
            "content": "val a = 10\nwhen(a){\n    10, 20 -> println(\"a = 10 или a = 20\")\n    else -> println(\"неопределенное значение\")\n}"
          },
          {
            "type": "text",
            "content": "Также можно сравнивать с целым диапазоном значений с помощью оператора in:"
          },
          {
            "type": "code",
            "content": "val a = 10\nwhen(a){\n    in 10..19 -> println(\"a в диапазоне от 10 до 19\")\n    in 20..29 -> println(\"a в диапазоне от 20 до 29\")\n    !in 10..20 -> println(\"a вне диапазона от 10 до 20\")\n    else -> println(\"неопределенное значение\")\n}"
          },
          {
            "type": "subtitle",
            "content": "\nWhen как альтернатива для if..else"
          },
          {
            "type": "text",
            "content": "Нам необязатльно сравнивать значение какого-либо объекта. Конструкция when аналогично конструкции if..else просто может поверять набор условий и если одно из условий возвращает true, то выполнять соответствующий набор действий:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val a = 15\n    val b = 6\n    when{\n        (b > 10) -> println(\"b больше 10\")\n        (a > 10) -> println(\"a больше 10\")\n        else -> println(\"и a, и b меньше или равны 10\")\n    }\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВозвращение значения"
          },
          {
            "type": "text",
            "content": "Как и if, конструкция when может возвращать значение. Возвращаемое значение указывается после оператора ->:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    val day = 2\n    var dayOfweek = when (day) {\n            1 -> \"Monday\"\n            2 -> \"Tuesday\"\n            3 -> \"Wednesday\"\n            4 -> \"Thursday\"\n            else -> \"Unknown\"\n    }\n    println(dayOfweek)      // Tuesday\n}"
          },
          {
            "type": "text",
            "content": "Здесь в зависимости от значения переменной day в другой переменной - dayOfweek окажется та или иная строка.\n\nДругой пример:"
          },
          {
            "type": "code",
            "content": "val sum = 1000\n \nval rate = when(sum){\n    in 100..999 -> 10\n    in 1000..9999 -> 15\n    else -> 20\n}\nprintln(rate)       // 15"
          },
          {
            "type": "text",
            "content": "Таким образом, если значение переменной sum располагается в определенном диапазоне, то возвращается то значение, которое идет после стрелки.\n"
          }
        ]
      },
      {
        "id": 8,
        "title": "Циклы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Циклы"
          },
            {
              "type": "text",
              "content": "Циклы представляют вид управляющих конструкций, которые позволяют в зависимости от определенных условий выполнять некоторое действие множество раз."
            },
            {
              "type": "subtitle",
              "content": "\nfor"
            },
            {
              "type": "text",
              "content": "Цикл for пробегается по всем элементам коллекции. Его формальная форма выглядит следующим образом:"
            },
            {
              "type": "code",
              "content": "for(переменная in последовательность){\n    выполняемые инструкции\n}"
            },
            {
              "type": "text",
              "content": "Например, выведем все квадраты чисел от 1 до 9, используя цикл for:"
            },
            {
              "type": "code",
              "content": "for(n in 1..9){\n    print(\"${n * n} \\t\")\n}"
            },
            {
              "type": "text",
              "content": "В данном случае перебирается последовательность чисел от 1 до 9. При каждом проходе цикла (итерации цикла) из этой последовательности будет извлекаться элемент и помещаться в переменную n. То есть в данном случае мы получим следующий консольный вывод:"
            },
            {
              "type": "code",
              "content": "1  4  9  16  25  36  49  64  81 "
            },
            {
              "type": "text",
              "content": "Циклы могут быть вложенными. Например, выведем таблицу умножения:"
            },
            {
              "type": "code",
              "content": "for(i in 1..9){\n    for(j in 1..9){\n        print(\"${i * j} \\t\")\n    }\n    println()\n}"
            },
            {
              "type": "subtitle",
              "content": "\nЦикл while"
            },
            {
              "type": "text",
              "content": "Цикл while повторяет определенные действия пока истинно некоторое условие:"
            },
            {
              "type": "code",
              "content": "var i = 10\nwhile(i > 0){\n    println(i*i)\n    i--;\n}"
            },
            {
              "type": "text",
              "content": "Здесь пока переменная i больше 0, будет выполняться цикл, в котором на консоль будет выводиться квадрат значения i."
            },
            {
              "type": "text",
              "content": "В данном случае вначале проверяется условие (i > 0) и если оно истинно (то есть возвращает true), то выполняется цикл. И вполне может быть ситуация, когда к началу выполнения цикла условие не будет выполняться. Например, переменная i изначально меньше 0, тогда цикл вообще не будет выполняться.\n"
            },
            {
              "type": "subtitle",
              "content": "\ndo..while"
            },
            {
              "type": "text",
              "content": "Есть и другая форма цикла while - do..while:"
            },
            {
              "type": "code",
              "content": "var i = -1\ndo{\n    println(i*i)\n    i--;\n}\nwhile(i > 0)"
            },
            {
              "type": "text",
              "content": "В данном случае вначале выполняется блок кода после ключевого слова do, а потом оценивается условие после while. Если условие истинно, то повторяется выполнение блока после do. То есть несмотря на то, что в данном случае переменная i меньше 0 и она не соответствует условию, тем не менее блок do выполнится хотя бы один раз."
            },
            {
              "type": "subtitle",
              "content": "\nОператоры continue и break"
            },
            {
              "type": "text",
              "content": "Иногда при использовании цикла возникает необходимость при некоторых условиях не дожидаться выполнения всех инструкций в цикле, перейти к новой итерации. Для этого можно использовать оператор continue:"
            },
            {
              "type": "code",
              "content": "for(n in 1..8){\n    if(n == 5) continue;\n    println(n * n)\n}"
            },
            {
              "type": "text",
              "content": "В данном случае когда n будет равно 5, сработает оператор continue. И последующая инструкция, которая выводит на консоль квадрат числа, не будет выполняться. Цикл перейдет к обработке следующего элемента в массиве"
            },
            {
              "type": "text",
              "content": "Бывает, что при некоторых условиях нам вовсе надо выйти из цикла, прекратить его выполнение. В этом случае применяется оператор break:"
            },
            {
              "type": "code",
              "content": "for(n in 1..5){\n    if(n == 5) break;\n    println(n * n)\n}"
            },
            {
              "type": "text",
              "content": "В данном случае когда n окажется равен 5, то с помощью оператора break будет выполнен выход из цикла. Цикл полностью завершится."
            },
            {
              "type": "text",
              "content": "Однако следует помнить, что оператор break выводит только из текущего цикла, где он вызывается. Например, возьмем следующую конструкцию с внешним и внутренним циклами:"
            },
            {
              "type": "code",
              "content": "fun main() {\n     \n    for(i in 1..3){\n        for(j in 1..3){\n            if(j == 3) break;\n            println(\"Hello\")\n        }\n    }\n}"
            },
            {
              "type": "text",
              "content": "Сколько раз здесь будет выведена строка \"Hello\"? Очевидно 6 раз."
            },
            {
              "type": "code",
              "content": "Hello\nHello\nHello\nHello\nHello\nHello"
            },
            {
              "type": "text",
              "content": "Каждый раз во внутреннем цикле j окажется равна 3, произойдет переход к новой итерации внешнего цикла по i. Но что если нам надо вообще выйти из всех циклов, в том числе и из внешнего? Наиболее простым в данном случае способом будет использование меток:"
            },
            {
              "type": "code",
              "content": "fun main() {\n     \n    outerloop@ for(i in 1..3){\n        for(j in 1..3){\n            if(j == 3) break@outerloop;\n            println(\"Hello\")\n        }\n    }\n}"
            },
            {
              "type": "text",
              "content": "В данном случае внешний цикл маркирован меткой outerloop. Название метки произвольное, единственное, что заврешается символом @. И кода во внутреннем цикле будет выполняться условие j == 3 оператор break выйдет из цикла, предваряемого меткой outerloop"
            },
            {
              "type": "code",
              "content": "if(j == 3) break@outerloop;"
            }
          ]
      },
      {
        "id": 9,
        "title": "Диапазоны",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Диапазоны"
          },
          {
            "type": "text",
            "content": "Диапазон представляет набор значений или неокторый интервал. Для создания диапазона применяется оператор '..':"
          },
          {
            "type": "code",
            "content": "val range = 1..5    // диапазон [1, 2, 3, 4, 5]"
          },
          {
            "type": "text",
            "content": "Этот оператор принимает два значения - границы диапазона, и все элементы между этими значениями (включая их самих) составляют диапазон."
          },
          {
            "type": "text",
            "content": "Диапазон необязательно должна представлять числовые данные. Например, это могут быть строки:"
          },
          {
            "type": "code",
            "content": "val range =  \"a\"..\"d\""
          },
          {
            "type": "text",
            "content": "Оператор '..' позволяет создать диапазон по нарастающей, где каждый следующий элемент будет больше предыдущего. С помощью специальной функции downTo можно построить диапазон в обратном порядке:"
          },
          {
            "type": "code",
            "content": "val range1 =  1..5      // 1 2 3 4 5\nval range2 =  5 downTo 1    // 5 4 3 2 1"
          },
          {
            "type": "text",
            "content": "Еще одна специальная функция step позволяет задать шаг, на который будут изменяться последующие элементы:"
          },
          {
            "type": "code",
            "content": "val range1 = 1..10 step 2           // 1 3 5 7 9\nval range2 = 10 downTo 1 step 3     // 10 7 4 1"
          },
          {
            "type": "text",
            "content": "Еще одна функция until позволяет не включать верхнюю границу в диапазон:"
          },
          {
            "type": "code",
            "content": "val range1 = 1 until 9          // 1 2 3 4 5 6 7 8\nval range2 = 1 until 9 step 2   // 1 3 5 7"
          },
          {
            "type": "text",
            "content": "С помощью специальных операторов можно проверить наличие или отсутствие элементов в диапазоне:"
          },
          {
            "type": "text",
            "content": "\t• in: возвращает true, если объект имеется в диапазоне"
          },
          {
            "type": "text",
            "content": "\t• !in: возвращает true, если объект отсутствует в диапазоне"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val range = 1..5\n \n    var isInRange = 5 in range\n    println(isInRange)      // true\n \n    isInRange = 86 in range\n    println(isInRange)      // false\n \n    var isNotInRange = 6 !in range\n    println(isNotInRange)   // true\n \n    isNotInRange = 3 !in range\n    println(isNotInRange)   // false\n}"
          },
          {
            "type": "subtitle",
            "content": "\nПеребор диапазона"
          },
          {
            "type": "text",
            "content": "С помощью цикла for можно перебирать диапазон:"
          },
          {
            "type": "code",
            "content": "val range1 = 5 downTo 1 \nfor(c in range1) print(c)   // 54321\nprintln()\n \nval range2 = 'a'..'d'\nfor(c in range2) print(c)   // abcd\nprintln()\n \nfor(c in 1..9) print(c)     // 123456789\nprintln()\n \nfor(c in 1 until 9) print(c)    // 12345678\nprintln()\n \nfor(c in 1..9 step 2) print(c)  // 13579"
          }
        ]
      },
      {
        "id": 10,
        "title": "Массивы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Массивы"
          },
          {
            "type": "text",
            "content": "Для хранения набора значений в Kotlin, как и в других языках программирования, можно использоватьмассивы. При этом массив может хранить данные только одного  того же типа. В Kotlin массивы представлены типом Array."
          },
          {
            "type": "text",
            "content": "При определении массива после типа Array в угловых скобках необходимо указать, объекты какого типа могут храниться в массиве. Например, определим массив целых чисел:"
          },
          {
            "type": "code",
            "content": "val numbers: Array<Int>"
          },
          {
          "type": "text",
          "content": "С помощью встроенной функции arrayOf() можно передать набор значений, которые будут составлять массив:"
          },
          {
            "type": "code",
            "content": "val numbers: Array<Int> = arrayOf(1, 2, 3, 4, 5)"
          },
          {
            "type": "text",
            "content": "То есть в данном случае в массиве 5 чисел от 1 до 5."
          },
          {
            "type": "text",
            "content": "Также можно использовать неявную типизацию и сразу передать набор значений массива:"
          },
          {
            "type": "code",
            "content": "val numbers = arrayOf(1, 2, 3, 4, 5)"
          },
          {
            "type": "text",
            "content": "В этом случае тип элементов массива будет выводиться из типа значений из функции arrayOf()"
          },
          {
            "type": "text",
            "content": "Чтобы создать массив, элементы которого не установлены, мы можем использовать встроенную функцию arrayOfNulls(). Она создает массив из элементов, каждый из который имеет значение null- то есть фактически не установленное значение. В эту функцию передается количество элементов:"
          },
          {
            "type": "code",
            "content": "val numbers = arrayOfNulls<Int>(3)  // [null, null, null]"
          },
          {
            "type": "text",
            "content": "Также имеются один способо создать массив и инициализировать его значениями:"
          },
          {
            "type": "code",
            "content": "val numbers = Array(3, {5}) // [5, 5, 5]"
          },
          {
            "type": "text",
            "content": "Здесь применяется конструктор класса Array. В этот конструктор передаются два значения. Первое значение - число 3 - указывает, сколько элементов будет в массиве. Второе значение - число 5 представляет выражение, которое генерирует элементы массива. Таким образом, массив будет состоять из трех пятерок."
          },
          {
            "type": "text",
            "content": "Но выражение, которое создает элементы массива, может быть и более сложным. Например:"
          },
          {
            "type": "code",
            "content": "var i = 1;\nval numbers = Array(3, { i++ * 2}) // [2, 4, 6]"
          },
          {
            "type": "text",
            "content": "В данном случае элемент массива является результатом умножения переменной i на 2. При этом при каждом обращении к переменой i ее значение увеличивается на единицу."
          },
          {
            "type": "subtitle",
            "content": "\nОбращение к элементам массива"
          },
          {
            "type": "text",
            "content": "С помощью индексов мы можем обратиться к определенному элементу в массиве. Индексация начинается с нуля, то есть первый элемент будет иметь индекс 0. Индекс указывается в квадратных скобках:"
          },
          {
            "type": "code",
            "content": "val numbers = arrayOf(1, 2, 3, 4, 5)\nval n = numbers[1]  // получаем второй элемент  n=2\nprintln(n)\nnumbers[2] = 7      // переустанавливаем третий элемент\nprintln(\"numbers[2] = ${numbers[2]}\") // numbers[2] = 7"
          },
          {
            "type": "subtitle",
            "content": "\nРазмер массива"
          },
          {
            "type": "text",
            "content": "Каждый массив имеет свойство size, которое хранит количество элементов массива:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    val numbers  = arrayOf(1, 2, 3, 4, 5);\n    println(numbers.size)   // 5\n \n    val people = arrayOf(\"Tom\", \"Bob\", \"Sam\")\n    println(people.size)   // 3\n}"
          },
          {
            "type": "subtitle",
            "content": "\nПеребор массивов"
          },
          {
            "type": "text",
            "content": "Для перебора массивов можно применять цикл for:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val numbers = arrayOf(1, 2, 3, 4, 5)\n    for(number in numbers){\n        print(\"$number \\t\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае переменная numbers представляет массив чисел. При переборе этого массива в цикле каждый его элемент оказывается в переменной number, значение которой, к примеру, можно вывести на консоль. Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "1  2  3  4  5"
          },
          {
            "type": "text",
            "content": "Подобным образом можно перебирать массивы и других типов:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val people = arrayOf(\"Tom\", \"Sam\", \"Bob\")\n    for(person in people){\n        print(\"$person \\t\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Tom   Sam   Bob"
          },
          {
            "type": "subtitle",
            "content": "\nПроверка наличия элемента в массиве"
          },
          {
            "type": "text",
            "content": "Как и в случае с последовательностью мы можем проверить наличие или отсутствие элементов в массиве с помощью операторов in и !in:"
          },
          {
            "type": "code",
            "content": "val numbers = arrayOf(1, 2, 3, 4, 5)\n \nprintln(4 in numbers)       // true\nprintln(2 !in numbers)      // false"
          },
          {
            "type": "subtitle",
            "content": "\nМассивы для базовых типов"
          },
          {
            "type": "text",
            "content": "Для упрощения создания массива в Kotlin определены дополнительные типы:\nBooleanArray, ByteArray, ShortArray, IntArray, LongArray, CharArray, FloatArray и DoubleArray.\nОни позволяют создавать массивы для определенных типов. Например, тип IntArray позволяет определить массив объектов Int, а DoubleArray - массив объектов Double:"
          },
          {
            "type": "code",
            "content": "val numbers: IntArray = intArrayOf(1, 2, 3, 4, 5)\nval doubles: DoubleArray = doubleArrayOf(2.4, 4.5, 1.2)"
          },
          {
            "type": "text",
            "content": "Для определения данных для этих массивов можно применять функции, которые начинаются на название типа в нижнем регистре, например, int, и затем идет ArrayOf."
          },
          {
            "type": "text",
            "content": "Аналогично для инициализации подобных массивов также можно применять конструктор соответствуюшего класса:"
          },
          {
            "type": "code",
            "content": "val numbers = IntArray(3, {5})\nval doubles = DoubleArray(3, {1.5})"
          }
        ]
      }
    ]
  },
  {
    "chapterId": 3,
    "chapterTitle": "Функциональное программирование",
    "articles": [
      {
        "id": 1,
        "title": "Функции и их параметры",
        "blocks": [

          {
            "type": "subtitle",
            "content": "Функции"
          },
          {
            "type": "text",
            "content": "Функция определяет некоторое действие. В Kotlin функция объявляется с помощью ключевого слова fun, после которого идет название функции. Затем после названия в скобках указывается список параметров. \nЕсли функция возвращает какое-либо значение, то после списка параметров через двоеточие можно указать тип возвращаемого значения. И далее в фигурных скобках идет тело функции."
          },
          {
            "type": "code",
            "content": "fun имя_функции (параметры) : возвращаемый_тип{\n    выполняемые инструкции\n}"
          },
          {
            "type": "text",
            "content": "Параметры необязательны. Возвращаемый тип можно не указывать, так как Kotlin обычно сам может его вывести на основании тела функции."
          },
          {
            "type": "text",
            "content": "Например, определим и вызовем функцию, которая просто выводит некоторую строку на консоль:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    hello() // вызов функции hello\n    hello() // вызов функции hello\n    hello() // вызов функции hello\n}\n// определение функции hello\nfun hello(){\n    println(\"Hello\")\n}"
          },
          {
            "type": "subtitle",
            "content": "\nПредача параметров"
          },
          {
            "type": "text",
            "content": "Через параметры функция может получать некоторые значения извне. Параметры указываются после имени функции в скобках через запятую в формате 'имя_параметра : тип_параметра'. \nНапример, определим функцию, которая просто выводит сообщение на консоль:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    showMessage(\"Hello Kotlin\")\n    showMessage(\"Привет Kotlin\")\n    showMessage(\"Salut Kotlin\")\n}\n \nfun showMessage(message: String){\n    println(message)\n}"
          },
          {
            "type": "text",
            "content": "Функция showMessage() принимает один параметр типа String. Поэтому при вызове функции в скобках необходимо передать значение для этого параметра: showMessage(\"Hello Kotlin\"). Причем это значение должно представлять тип String, то есть строку. \nЗначения, которые передаются параметрам функции, еще назвают аргументами."
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Hello Kotlin\nПривет Kotlin\nSalut Kotlin"
          },
          {
            "type": "text",
            "content": "Другой пример - функция, которая выводит данные о пользователе на консоль:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    displayUser(\"Tom\", 23)\n    displayUser(\"Alice\", 19)\n    displayUser(\"Kate\", 25)\n}\nfun displayUser(name: String, age: Int){\n    println(\"Name: $name   Age: $age\")\n}"
          },
          {
            "type": "text",
            "content": "Функция displayUser() принимает два параметра - name и age. При вызове функции в скобках ей передаются значения для этих параметров. При этом значения передаются параметрам по позиции и должны соответствовать параметрам по типу. Так как вначале идет параметр типа String, а потом параметр типа Int, то при вызове функции в скобках вначале передается строка, а потом число."
          },
          {
            "type": "subtitle",
            "content": "\nНеобязательные параметры"
          },
          {
            "type": "text",
            "content": "В примере выше при вызове функций showMessage и displayUser мы обязательно должны предоставить для каждого их параметра какое-то определенное значение, которое соответствует типу параметра. \nМы не можем, к примеру, вызвать функцию displayUser, не передав ей аргументы для параметров, это будет ошибка."
          },
          {
            "type": "text",
            "content": "Однако мы можем определить какие-то параметры функции как необязательные и установить для них значения по умолчанию:"
          },
          {
            "type": "code",
            "content": "fun displayUser(name: String, age: Int = 18, position: String=\"unemployed\"){\n    println(\"Name: $name   Age: $age  Position: $position\")\n}\n \nfun main() {\n \n    displayUser(\"Tom\", 23, \"Manager\")\n    displayUser(\"Alice\", 21)\n    displayUser(\"Kate\")\n}"
          },
          {
            "type": "text",
            "content": "В данном случае функция displayUser имеет три параметра для передачи имени, возраста и должности.  Для age и position передача аргументов является необязательной, так как для них установлено значение по умолчанию. \nЕсли для этих параметров не передаются значения, тогда параметры используют значения по умолчанию."
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Name: Tom   Age: 23  Position: Manager\nName: Alice   Age: 21  Position: unemployed\nName: Kate   Age: 18  Position: unemployed"
          },
          {
            "type": "subtitle",
            "content": "\nИменованные аргументы"
          },
          {
            "type": "text",
            "content": "По умолчанию значения передаются параметрам по позиции: первое значение - первому параметру, второе значение - второму параметру и так далее. \nОднако, используя именованные аргументы, мы можем переопределить порядок их передачи параметрам:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    displayUser(\"Tom\", position=\"Manager\", age=28)\n    displayUser(age=21, name=\"Alice\")\n    displayUser(\"Kate\", position=\"Middle Developer\")\n}"
          },
          {
            "type": "text",
            "content": "При вызове функции в скобках мы можем указать название параметра и с помощью знака равно передать ему нужное значение."
          }
        ]
      },
      {
        "id": 2,
        "title": "Vararg",
        "blocks": [

          {
            "type": "subtitle",
            "content": "Переменное количество параметров. Vararg"
          },
          {
            "type": "text",
            "content": "Функция может принимать переменное количество параметров одного типа. Для определения таких параметров применяется ключевое слово vararg. \nНапример, нам необходимо передать в функцию несколько строк, но сколько именно строк, мы точно не знаем. Их может быть пять, шесть, семь и т.д.:"
          },
          {
            "type": "code",
            "content": "fun printStrings(vararg strings: String){\n    for(str in strings)\n        println(str)\n}\nfun main() {\n \n    printStrings(\"Tom\", \"Bob\", \"Sam\")\n    printStrings(\"Kotlin\", \"JavaScript\", \"Java\", \"C#\", \"C++\")\n}"
          },
          {
            "type": "text",
            "content": "Функция printStrings принимает неопределенное количество строк. В самой функции мы можем работать с параметром как с последовательностью строк, например, перебирать элементы последовательности в цикле и производить с ними некоторые действия."
          },
          {
            "type": "text",
            "content": "При вызове функции мы можем ей передать любое количество строк."
          },
          {
            "type": "text",
            "content": "Другой пример - подсчет суммы неопределенного количества чисел:"
          },
          {
            "type": "code",
            "content": "fun sum(vararg numbers: Int){\n    var result=0\n    for(n in numbers)\n        result += n\n    println(\"Сумма чисел равна $result\")\n}\nfun main() {\n \n    sum(1, 2, 3, 4, 5)\n    sum(1, 2, 3, 4, 5, 6, 7, 8, 9)\n}"
          },
          {
            "type": "text",
            "content": "Если функция принимает несколько параметров, то обычно vararg-параметр является последним."
          },
          {
            "type": "code",
            "content": "fun printUserGroup(count:Int, vararg users: String){\n    println(\"Count: $count\")\n    for(user in users)\n        println(user)\n}\n \nfun main() {\n \n    printUserGroup(3, \"Tom\", \"Bob\", \"Alice\")\n}"
          },
          {
            "type": "text",
            "content": "Однако это необязательно, но если после vararg-параметра идут еще какие-нибудь параметры, то при вызове функции значения этим параметрам передаются через именованные аргументы:"
          },
          {
            "type": "code",
            "content": "fun printUserGroup(group: String, vararg users: String, count:Int){\n    println(\"Group: $group\")\n    println(\"Count: $count\")\n    for(user in users)\n        println(user)\n}\nfun main() {\n \n    printUserGroup(\"8B42\", \"Tom\", \"Bob\", \"Alice\", count=3)\n}"
          },
          {
            "type": "text",
            "content": "Здесь функция printUserGroup принимает три параметра. Значения параметрам до vararg-параметра передаются по позициям. То есть в данном случае \"8B42\" будет представлять значение для параметра group. Последующие значения интерпретируются как значения для vararg-параметра вплоть до именнованных аргументов."
          },
          {
            "type": "subtitle",
            "content": "\nОператор *"
          },
          {
            "type": "text",
            "content": "Оператор * (spread operator) (не стоит путать со знаком умножения) позволяет передать параметру в качестве значения элементы из массива:"
          },
          {
            "type": "code",
            "content": "fun changeNumbers(vararg numbers: Int, koef: Int){\n    for(number in numbers)\n        println(number * koef)\n}\nfun main() {\n \n    val nums = intArrayOf(1, 2, 3, 4)\n    changeNumbers(*nums, koef=2)\n}"
          },
          {
            "type": "text",
            "content": "Обратите внимание на звездочку перед nums при вызове функции: changeNumbers (*nums, koef=2). Без применения данного оператора мы столкнулись бы с ошибкой, поскольку параметры функции представляют не массив, а неопределенное количество значений типа Int."
          }
        ]
      },
      {
        "id": 3,
        "title": "Оператор return",
        "blocks": [

          {
            "type": "subtitle",
            "content": "Возвращение результата. Оператор return"
          },
          {
            "type": "text",
            "content": "Функция может возвращать некоторый результат. В этом случае после списка параметров через двоеточие указывается возвращаемый тип. А в теле функции применяется оператор return, после которого указывается возвращаемое значение."
          },
          {
            "type": "text",
            "content": "Например, определим функцию, которая возвращает сумму двух чисел:"
          },
          {
            "type": "code",
            "content": "fun sum(x:Int, y:Int): Int{\n     \n    return x + y\n}\nfun main() {\n \n    val a = sum(4, 3)\n    val b = sum(5, 6)\n    val c = sum(6, 9)\n    println(\"a=$a  b=$b  c=$c\")\n}"
          },
          {
            "type": "text",
            "content": "В объявлении функции sum после списка параметров через двоеточие указывается тип Int, который будет представлять тип возвращаемого значения:"
          },
          {
            "type": "code",
            "content": "fun sum(x:Int, y:Int): Int"
          },
          {
            "type": "text",
            "content": "В самой функции с помощью оператора return возвращаем полученное значение - результат операции сложения:"
          },
          {
            "type": "code",
            "content": "return x + y"
          },
          {
            "type": "text",
            "content": "Так как функция возвращает значение, то при ее вызове это значение можно присвоить переменной:"
          },
          {
            "type": "code",
            "content": "val a = sum(4, 3)"
          },
          {
            "type": "subtitle",
            "content": "\nТип Unit"
          },
          {
            "type": "text",
            "content": "Если функция не возвращает какого-либо результата, то фактически неявно она возвращает значение типа Unit. Этот тип аналогичен типу void в ряде языков программирования, которое указывает, что функция ничего не возвращает. \nНапример, следующая функция"
          },
          {
            "type": "code",
            "content": "fun hello(){\n    println(\"Hello\")\n}"
          },
          {
            "type": "text",
            "content": "будет аналогична следующей:"
          },
          {
            "type": "code",
            "content": "fun hello() : Unit{\n    println(\"Hello\")\n}"
          },
          {
            "type": "text",
            "content": "Формально мы даже можем присвоить результат такой функции переменной:"
          },
          {
            "type": "code",
            "content": "val d = hello()\nval e = hello()"
          },
          {
            "type": "text",
            "content": "Однако практического смысла это не имеет, так как возвращаемое значение представляет объект Unit, который больше никак не применяется."
          },
          {
            "type": "text",
            "content": "Если функция возвращает значение Unit, мы также можем использовать оператор return для возврата из функции:"
          },
          {
            "type": "code",
            "content": "fun checkAge(age: Int){\n    if(age < 0 || age > 110){\n        println(\"Invalid age\")\n        return\n    }\n    println(\"Age is valid\")\n}\nfun main() {\n \n    checkAge(-10)\n    checkAge(10)\n}"
          },
          {
            "type": "text",
            "content": "В данном случае если значение параметра age выходит за пределы диапазона от 0 до 110, то с помощью оператора return осуществляется выход из функции, и последующие инструкции не выполняются. \nПри этом если функция возвращает значение Unit, то после оператора return можно не указывать никакого значения."
          }
        ]
      },
      {
        "id": 4,
        "title": "Однострочные и локальные функции",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Однострочные и локальные функции"
          },
          {
            "type": "subtitle",
            "content": "\nОднострочные функции"
          },
          {
            "type": "text",
            "content": "Однострочные функции (single expression function) используют сокращенный синтаксис определения функции в виде одного выражения. Эта форма позволяет опустить возвращаемый тип и оператор return."
          },
          {
            "type": "code",
            "content": "\t\nfun имя_функции (параметры_функции) = тело_функции"
          },
          {
            "type": "text",
            "content": "Функция также определяется с помощью ключевого слова fun, после которого идет имя функции и список параметров. Но после списка параметров не указывается возвращаемый тип. Возвращаемый тип будет выводится компилятором. Далее через оператор присвоения = определяется тело функции в виде одного выражения."
          },
          {
            "type": "text",
            "content": "Например, функция возведения числа в квадрат:"
          },
          {
            "type": "code",
            "content": "fun square(x: Int) = x * x\n \nfun main() {\n \n    val a = square(5)   // 25\n    val b = square(6)   // 36\n    println(\"a=$a  b=$b\")\n}"
          },
          {
            "type": "text",
            "content": "В данном случае функция square возводит число в квадрат. Она состоит из одного выраженияx * x. Значение этого выражения и будет возвращаться функцией. При этом оператор return не используется."
          },
          {
            "type": "text",
            "content": "Такие функции более лаконичны, более читабельны, но также опционально можно и указывать возвращаемый тип явно:"
          },
          {
            "type": "code",
            "content": "fun square(x: Int) : Int = x * x"
          },
          {
            "type": "subtitle",
            "content": "\nЛокальные функции"
          },
          {
            "type": "text",
            "content": "Одни функции могут быть определены внутри других функций. Внутренние или вложенные функции еще называют локальными."
          },
          {
            "type": "text",
            "content": "Локальные функции могут определять действия, которые используются только в рамках какой-то конкретной функции и нигде больше не применяются."
          },
          {
            "type": "text",
            "content": "Например, у нас есть функция, которая сравнивает два возраста:"
          },
          {
            "type": "code",
            "content": "fun compareAge(age1: Int, age2: Int){\n \n    fun ageIsValid(age: Int): Boolean{\n        return age > 0 && age < 111\n    }\n    if( !ageIsValid(age1) || !ageIsValid(age2)) {\n        println(\"Invalid age\")\n        return\n    }\n \n    when {\n        age1 == age2 -> println(\"age1 == age2\")\n        age1 > age2 -> println(\"age1 > age2\")\n        age1 < age2 -> println(\"age1 < age2\")\n    }\n}\nfun main() {\n \n    compareAge(20, 23)\n    compareAge(-3, 20)\n    compareAge(34, 134)\n    compareAge(15, 8)\n}"
          },
          {
            "type": "text",
            "content": "Однако извне могут быть переданы некорректные данные. Имеет ли смысл сравнивать возраст меньше нуля с другим? Очевидно нет. Для этой цели в функции определена локальная функция ageIsValid(), которая возвращает true, если возраст является допустимым. Больше в программе эта функция нигде не используется, поэтому ее можно сделать локальной."
          },
          {
            "type": "text",
            "content": "При этом локальная может использоваться только в той функции, где она определена."
          },
          {
            "type": "text",
            "content": "Причем в данном случае удобнее сделать локальную функцию однострочной:"
          },
          {
            "type": "code",
            "content": "fun compareAge(age1: Int, age2: Int){\n \n    fun ageIsValid(age: Int)= age > 0 && age < 111\n \n    if( !ageIsValid(age1) || !ageIsValid(age2)) {\n        println(\"Invalid age\")\n        return\n    }\n \n    when {\n        age1 == age2 -> println(\"age1 == age2\")\n        age1 > age2 -> println(\"age1 > age2\")\n        age1 < age2 -> println(\"age1 < age2\")\n    }\n}"
          }
        ]
      },
      {
        "id": 5,
        "title": "Перегрузка функций",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Перегрузка функций"
          },
          {
            "type": "text",
            "content": "Перегрузка функций (function overloading) представляет определение нескольких функций с одним и тем же именем, но с различными параметрами. Параметры перегруженных функций могут отличаться по количеству, типу или по порядку в списке параметров."
          },
          {
            "type": "code",
            "content": "fun sum(a: Int, b: Int) : Int{\n    return a + b\n}\nfun sum(a: Double, b: Double) : Double{\n    return a + b\n}\nfun sum(a: Int, b: Int, c: Int) : Int{\n    return a + b + c\n}\nfun sum(a: Int, b: Double) : Double{\n    return a + b\n}\nfun sum(a: Double, b: Int) : Double{\n    return a + b\n}"
          },
          {
            "type": "text",
            "content": "В данном случае для одной функции sum() определено пять перегруженных версий. Каждая из версий отличается либо по типу, либо количеству, либо по порядку параметров. \nПри вызове функции sum компилятор в зависимости от типа и количества параметров сможет выбрать для выполнения нужную версию:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val a = sum(1, 2)\n    val b = sum(1.5, 2.5)\n    val c = sum(1, 2, 3)\n    val d = sum(2, 1.5)\n    val e = sum(1.5, 2)\n}"
          },
          {
            "type": "text",
            "content": "При этом при перегрузке не учитывается возвращаемый результат функции. Например, пусть у нас будут две следующие версии функции sum:"
          },
          {
            "type": "code",
            "content": "fun sum(a: Double, b: Int) : Double{\n    return a + b\n}\nfun sum(a: Double, b: Int) : String{\n    return \"$a + $b\"\n}"
          },
          {
            "type": "text",
            "content": "Они совпадают во всем за исключением возвращаемого типа. Однако в данном случае мы сталкивамся с ошибкой, так как перегруженные версии должны отличаться именно по типу, порядку или количеству параметров. Отличие в возвращаемом типе не имеют значения."
          }
        ]
      },
      {
        "id": 6,
        "title": "Тип функции",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Тип функции"
          },
          {
            "type": "text",
            "content": "В Kotlin все является объектом, в том числе и функции. И функции, как и другие объекты, имеют определенный тип. \nТип функции определяется следующим образом:"
          },
          {
            "type": "code",
            "content": "(типы_параметров) -> возвращаемый_тип"
          },
          {
            "type": "text",
            "content": "Возьмем функцию которая не принимает никаких параметров и ничего не возвращает:"
          },
          {
            "type": "code",
            "content": "fun hello(){\n \n    println(\"Hello Kotlin\")\n}"
          },
          {
            "type": "text",
            "content": "Она имеет тип:"
          },
          {
            "type": "code",
            "content": "() -> Unit"
          },
          {
            "type": "text",
            "content": "Если функция не принимает параметров, в определении типа указываются пустые скобки. Если не указан возвращаемый тип, то фактически а в качестве типа возвращаемого значения применяется тип Unit."
          },
          {
            "type": "text",
            "content": "Возьмем другую функцию:"
          },
          {
            "type": "code",
            "content": "fun sum(a: Int, b: Int): Int{\n    return a + b\n}"
          },
          {
            "type": "text",
            "content": "Эта функция принимает два параметра типа Int и возвращает значение типа Int, поэтому она имеет тип"
          },
          {
            "type": "code",
            "content": "(Int, Int) -> Int"
          },
          {
            "type": "text",
            "content": "Что дает нам знание типа функции? Используя тип функции, мы можем определять переменные и параметры других функций, которые будут представлять функции."
          },
          {
            "type": "subtitle",
            "content": "\nПеременные-функции"
          },
          {
            "type": "text",
            "content": "Переменная может представлять функцию. С помощью типа функции можно определить, какие именно функции переменная может представлять:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val message: () -> Unit \n    message = ::hello\n    message()\n}\n \nfun hello(){\n    println(\"Hello Kotlin\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь переменная message представляет функцию с типом () -> Unit, то есть функцию без параметров, которая ничего не возвращает. Далее определена как раз такая функция - hello(), соответственно мы можем передать функцию hello переменной message."
          },
          {
            "type": "text",
            "content": "Чтобы передать функцию, перед названием функции ставится оператор '::'"
          },
          {
            "type": "code",
            "content": "message = ::hello"
          },
          {
            "type": "text",
            "content": "Затем мы можем обращаться к переменной message() как к обычной функции:"
          },
          {
            "type": "code",
            "content": "message()"
          },
          {
            "type": "text",
            "content": "Так как переменная message ссылается на функцию hello, то при вызове message() фактически будет вызываться функция hello()."
          },
          {
            "type": "text",
            "content": "При этом тип функции также может выводится исходя из присваемого переменной значения:"
          },
          {
            "type": "code",
            "content": "val message = ::hello // message имеет тип () -> Unit"
          },
          {
            "type": "text",
            "content": "Рассмотрим другой пример, когда переменная ссылается на функцию с параметрами:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val operation: (Int, Int) -> Int = ::sum\n    val result = operation(3, 5)\n    println(result) // 8\n}\nfun sum(a: Int, b: Int): Int{\n    return a + b\n}"
          },
          {
            "type": "text",
            "content": "Переменная operation представляет функцию с типом (Int, Int) -> Int, то есть функцию с двумя параметрами типа Int и возвращаемым значением типа Int. Соответственно такой переменной мы можем присвоить функциюsum, которая соответствует этому типу."
          },
          {
            "type": "text",
            "content": "Затем через имя переменной фактически можно обращаться к функции sum(), передавая ей значения для параметров и получая ее результат:"
          },
          {
            "type": "code",
            "content": "val result = operation(3, 5)"
          },
          {
            "type": "text",
            "content": "При этом динамически можно менять значение, главное чтобы оно соответствовало типу переменной:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    // operation указывает на функцию sum\n    var operation: (Int, Int) -> Int = ::sum\n    val result1 = operation(14, 5)\n    println(result1) // 19\n \n    // operation указывает на функцию subtract\n    operation = ::subtract      \n    val result2 = operation(14, 5)\n    println(result2) // 9\n \n}\nfun sum(a: Int, b: Int): Int{\n    return a + b\n}\nfun subtract(a: Int, b: Int): Int{\n    return a - b\n}"
          }
        ]
      },
      {
        "id": 7,
        "title": "Функции высокого порядка",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Функции высокого порядка"
          },
          {
            "type": "text",
            "content": "Функции высокого порядка (high order function) - это функции, которые либо принимают функцию в качестве параметра, либо возвращают функцию, либо и то, и другое."
          },
          {
            "type": "subtitle",
            "content":"\nФункция как параметр функции"
          },
          {
            "type": "text",
            "content": "Чтобы функция могла принимать другую функцию через параметр, этот параметр должен представлять тип функции:"
          },
          {
            "type": "code",
            "content": "fun main() {\n\n    displayMessage(::morning)\n    displayMessage(::evening)\n}\nfun displayMessage(mes: () -> Unit){\n    mes()\n}\nfun morning(){\n    println(\"Good Morning\")\n}\nfun evening(){\n    println(\"Good Evening\")\n}"
          },
          {
            "type": "text",
            "content": "В данном случае функция displayMessage() через параметр mes принимает функцию типа () -> Unit, то есть такую функцию, которая не имеет параметров и ничего не возвращает."
          },
          {
            "type": "code",
            "content":"fun displayMessage(mes: () -> Unit){"
          },
          {
            "type": "text",
            "content": "При вызове этой функции мы можем передать этому параметру функцию, которая соответствует этому типу:"
          },
          {
            "type": "code",
            "content":"displayMessage(::morning)"
          },
          {
            "type": "text",
            "content": "Рассмотрим пример параметра-функции, которая принимает параметры:"
          },
          {
            "type": "code",
            "content":"fun main() {\n\n    action(5, 3, ::sum)         // 8\n    action(5, 3, ::multiply)    // 15\n    action(5, 3, ::subtract)    // 2\n}\n\nfun action (n1: Int, n2: Int, op: (Int, Int)-> Int){\n    val result = op(n1, n2)\n    println(result)\n}\nfun sum(a: Int, b: Int): Int{\n    return a + b\n}\nfun subtract(a: Int, b: Int): Int{\n    return a - b\n}\nfun multiply(a: Int, b: Int): Int{\n    return a * b\n}"
          },
          {
            "type": "text",
            "content": "Здесь функция action принимает три параметра. Первые два параметра - значения типа Int. А третий параметр представляет функцию, которая имеет тип (Int, Int)-> Int, то есть принимает два числа и возвращает некоторое число."
          },
          {
            "type": "text",
            "content": "В самой функции action вызываем эту параметр-функцию, передавая ей два числа, и полученный результат выводим на консоль."
          },
          {
            "type": "text",
            "content": "При вызове функции action мы можем передать для ее третьего параметра конкретную функцию, которая соответствует этому параметру по типу:"
          },
          {
            "type": "code",
            "content":"action(5, 3, ::sum)         // 8\naction(5, 3, ::multiply)    // 15\naction(5, 3, ::subtract)    // 2"
          },
          {
            "type": "subtitle",
            "content": "\nВозвращение функции из функции"
          },
          {
            "type": "text",
            "content": "В более редких случаях может потребоваться возвратить функцию из другой функции. В этом случае для функции в качестве возвращаемого типа устанавливается тип другой функции. А в теле функции возвращается лямбда выражение. Например:"
          },
          {
            "type": "code",
            "content":"fun main() {\n    val action1 = selectAction(1)\n    println(action1(8,5))    // 13\n\n    val action2 = selectAction(2)\n    println(action2(8,5))    // 3\n}\nfun selectAction(key: Int): (Int, Int) -> Int{\n    // определение возвращаемого результата\n    when(key){\n        1 -> return ::sum\n        2 -> return ::subtract\n        3 -> return ::multiply\n        else -> return ::empty\n    }\n}\nfun empty (a: Int, b: Int): Int{\n    return 0\n}\nfun sum(a: Int, b: Int): Int{\n    return a + b\n}\nfun subtract(a: Int, b: Int): Int{\n    return a - b\n}\nfun multiply(a: Int, b: Int): Int{\n    return a * b\n}"
          },
          {
            "type": "text",
            "content": "Здесь функция selectAction принимает один параметр - key, который представляет тип Int. В качестве возвращаемого типа у функции указан тип (Int, Int) -> Int. То есть selectAction будет возвращать некую функцию, которая принимает два параметра типа Int и возвращает объект типа Int."
          },
          {
            "type": "text",
            "content": "В теле функции selectAction в зависимости от значения параметра key возвращается определенная функция, которая соответствует типу (Int, Int) -> Int."
          },
          {
            "type": "text",
            "content": "Далее в функции main определяется переменная action1 хранит результат функции selectAction. Так как selectAction() возвращает функцию, то и переменная action1 будет хранить эту функцию. Затем через переменную action1 можно вызвать эту функцию."
          }
        ]
      },
      {
        "id": 8,
        "title": "Анонимные функции",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Анонимные функции"
          },
          {
            "type": "text",
            "content": "Анонимные функции выглядят как обычные за тем исключением, что они не имеют имени. Анонимная функция может иметь одно выражение:"
          },
          {
            "type": "code",
            "content": "fun(x: Int, y: Int): Int = x + y"
          },
          {
            "type": "text",
            "content": "Либо может представлять блок кода:"
          },
          {
            "type": "code",
            "content": "fun(x: Int, y: Int): Int{ \n    return x + y\n}"
          },
          {
            "type": "text",
            "content": "Анонимную функцию можно передавать в качестве значения переменной:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val message = fun()=println(\"Hello\")\n    message()\n}"
          },
          {
            "type": "text",
            "content": "Здесь переменной message передается анонимная функция fun()=println(\"Hello\"). Эта анонимная функция не принимает параметров и просто выводит на консоль строку \"Hello\". Таким образом, переменная message будет представлять тип () -> Unit."
          },
          {
            "type": "text",
            "content": "Далее мы можем вызывать эту функцию через имя переменной как обычную функцию: message()."
          },
          {
            "type": "text",
            "content": "Другой пример - анонимная функция с параметрами:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val sum = fun(x: Int, y: Int): Int = x + y \n    val result = sum(5, 4)\n    println(result)     // 9\n}"
          },
          {
            "type": "text",
            "content": "В данном случае переменной sum присваивается анонимная функция, которая принимает два параметра - два целых числа типа Int и возвращает их сумму."
          },
          {
            "type": "text",
            "content": "Также через имя переменной мы можем вызвать эту анонимную функцию, передав ей некоторые значения для параметров и получить ее результат."
          },
          {
            "type": "subtitle",
            "content": "\nАнонимная функция как аргумент функции"
          },
          {
            "type": "text",
            "content": "Анонимную функцию можно передавать в функцию, если параметр соответствует типу этой функции:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    doOperation(9,5, fun(x: Int, y: Int): Int = x + y )     // 14\n    doOperation(9,5, fun(x: Int, y: Int): Int = x - y)      // 4\n \n    val action = fun(x: Int, y: Int): Int = x * y\n    doOperation(9, 5, action)       // 45\n}\nfun doOperation(x: Int, y: Int, op: (Int, Int) ->Int){\n \n    val result = op(x, y)\n    println(result)\n"
          },
          {
            "type": "subtitle",
            "content": "\nВозвращение анонимной функции из функции"
          },
          {
            "type": "text",
            "content": "И также фунция может возвращать анонимную функцию в качестве результата:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val action1 = selectAction(1)\n    val result1 = action1(4, 5)\n    println(result1)        // 9\n \n    val action2 = selectAction(3)\n    val result2 = action2(4, 5)\n    println(result2)        // 20\n \n    val action3 = selectAction(9)\n    val result3 = action3(4, 5)\n    println(result3)        // 0\n}\n \nfun selectAction(key: Int): (Int, Int) -> Int{\n    // определение возвращаемого результата\n    when(key){\n        1 -> return fun(x: Int, y: Int): Int = x + y\n        2 -> return fun(x: Int, y: Int): Int = x - y\n        3 -> return fun(x: Int, y: Int): Int = x * y\n        else -> return fun(x: Int, y: Int): Int = 0\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь функция selectAction() в зависимости от переданного значения возвращает одну из четырех анонимных функций. Последняя анонимная функция fun(x: Int, y: Int): Int = 0 просто возвращает число 0."
          },
          {
            "type": "text",
            "content": "При обращении к selectAction() переменная получит определенную анонимную функцию:"
          },
          {
            "type": "code",
            "content": "val action1 = selectAction(1)"
          },
          {
            "type": "text",
            "content": "То есть в данном случае переменная action1 хранит ссылку на функцию fun(x: Int, y: Int): Int = x + y"
          }
        ]
      },
      {
        "id": 9,
        "title": "Лямбда-выражения",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Лямбда-выражения"
          },
          {
            "type": "text",
            "content": "Лямбда-выражения представляют небольшие кусочки кода, которые выполняют некоторые действия. \nФактически лямбды преставляют сокращенную запись функций. При этом лямбды, как и обычные и анонимные функции, могут передаваться в качестве значений переменным и параметрам функции."
          },
          {
            "type": "text",
            "content": "Лямбда-выражения оборачиваются в фигурные скобки:"
          },
          {
            "type": "code",
            "content": "{println(\"hello\")}"
          },
          {
            "type": "text",
            "content": "В данном случае лямбда-выражение выводит на консоль строку \"hello\"."
          },
          {
            "type": "text",
            "content": "Лямбда-выражение можно сохранить в обычную переменную и затем вызывать через имя этой переменной как обычную функцию."
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val hello = {println(\"Hello Kotlin\")}\n    hello()\n    hello()\n}"
          },
          {
            "type": "text",
            "content": "В данном случае лямбда сохранена в переменную hello и через эту переменную вызывается два раза. \nПоскольку лямбда-выражение представляет сокращенную форму функции, то переменная hello имеет тип функции () -> Unit."
          },
          {
            "type": "code",
            "content": "val hello: ()->Unit = {println(\"Hello Kotlin\")}"
          },
          {
            "type": "text",
            "content": "Также лямбда-выражение можно запускать как обычную функцию, используя круглые скобки:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    {println(\"Hello Kotlin\")}()\n}"
          },
          {
            "type": "text",
            "content": "Следует учитывать, что если до подобной записи идут какие-либо инструкции, то Kotlin автоматически может не определять, что определения лямбда-выражения составляет новую инструкцию. В этом случае предыдущую инструкции можно завершить точкой с запятой:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    {println(\"Hello Kotlin\")}();\n    {println(\"Kotlin on Metanit.com\")}()\n}"
          },
          {
            "type": "subtitle",
            "content": "\nПередача параметров"
          },
          {
            "type": "text",
            "content": "Лямбды как и функции могут принимать параметры. Для передачи параметров используется стрелка ->. Параметры указываются слева от стрелки, а тело лямбда-выражения, то есть сами выполняемые действия, справа от стрелки."
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val printer = {message: String -> println(message)}\n    printer(\"Hello\")\n    printer(\"Good Bye\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь лямбда-выражение принимает один параметр типа String, значение которого выводится на консоль. Переменная printer в данном случае имеет тип (String) -> Unit."
          },
          {
            "type": "text",
            "content": "При вызове лямбда-выражения сразу при его определении в скобках передаются значения для его параметров:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    {message: String -> println(message)}(\"Welcome to Kotlin\")\n}"
          },
          {
            "type": "text",
            "content": "Если параметров несколько, то они передаются слева от стрелки через запятую:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val sum = {x:Int, y:Int -> println(x + y)}\n    sum(2, 3)   // 5\n    sum(4, 5)   // 9\n}"
          },
          {
            "type": "text",
            "content": "Если в лямбда-выражении надо выполнить не одно, а несколько действий, то эти действия можно размещать на отдельных строках после стрелки:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val sum = {x:Int, y:Int -> println(x + y)}\n    sum(2, 3)   // 5\n    sum(4, 5)   // 9\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВозвращение результата"
          },
          {
            "type": "text",
            "content": "Выражение, стоящее после стрелки, определяет результат лямбда-выражения. И этот результат мы можем присвоить, например, переменной."
          },
          {
            "type": "text",
            "content": "Если лямбда-выражение формально не возвращает никакого результата, то фактически, как и в функциях, возвращается значение типа Unit:"
          },
          {
            "type": "code",
            "content": "val hello = { println(\"Hello\")}\nval h = hello()             // h представляет тип Unit\n \nval printer = {message: String -> println(message)}\nval p = printer(\"Welcome\")    // p представляет тип Unit"
          },
          {
            "type": "text",
            "content": "В обоих случаях используется функция println, которая формально не возвращает никакого значения (точнее возвращает объект типа Unit)."
          },
          {
            "type": "text",
            "content": "Но также может возвращаться конкретное значение:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val sum = {x:Int, y:Int -> x + y}\n     \n    val a = sum(2, 3)   // 5\n    val b = sum(4, 5)   // 9\n    println(\"a=$a  b=$b\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь выражение справа от стрелки x + y продуцирует новое значение - сумму чисел, и при вызове лямбда-выражения это значение можно передать переменной. В данном случае лямбда-выражение имеет тип (Int, Int) -> Int."
          },
          {
            "type": "text",
            "content": "Если лямбда-выражение многострочное, состоит из нескольких инструкций, то возвращается то значение, которое генерируется последней инструкцией:"
          },
          {
            "type": "code",
            "content": "val sum = {x:Int, y:Int ->\n    val result = x + y\n    println(\"$x + $y = $result\")\n    result\n}"
          },
          {
            "type": "text",
            "content": "Последнее выражение по сути представляет число - сумму чисел x и y и оно будет возвращаться в качестве результата лямбда-выражения."
          },
          {
            "type": "subtitle",
            "content": "\nЛямбда-выражения как аргументы функций"
          },
          {
            "type": "text",
            "content": "Лямбда-выражения можно передавать параметрам функции, если они представляют один и тот же тип функции:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val sum = {x:Int, y:Int -> x + y }\n    doOperation(3, 4, sum)                          // 7\n    doOperation(3, 4, {a:Int, b: Int -> a * b}) // 12\n \n}\nfun doOperation(x: Int, y: Int, op: (Int, Int) ->Int){\n \n    val result = op(x, y)\n    println(result)\n}"
          },
          {
            "type": "subtitle",
            "content": "\nТипизиция параметров лямбды"
          },
          {
            "type": "text",
            "content": "При передаче лямбды параметру или переменной, для которой явным образом указан тип, мы можем опустить в лямбда-выражении типы параметров:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val sum: (Int, Int) -> Int = {x, y -> x + y } \n    doOperation(3, 4, {a, b -> a * b})\n}\nfun doOperation(x: Int, y: Int, op: (Int, Int) ->Int){\n \n    val result = op(x, y)\n    println(result)\n}"
          },
          {
            "type": "text",
            "content": "Здесь в случае с переменной sum, Kotlin видит, что ее тип(Int, Int) -> Int, то есть и первый, и второй параметр представляют тип Int. Поэтому при присвоении переменной лямбды {x, y -> x + y } Kotlin автоматически поймет, что параметры x и y представляют именно тип Int."
          },
          {
            "type": "text",
            "content": "То же самое касается и вызова функции doOperation() - при передаче в него лямбды Kotlin автоматически поймет какой параметр какой тип представляет."
          },
          {
            "type": "subtitle",
            "content": "\nTrailing lambda"
          },
          {
            "type": "text",
            "content": "Если параметр, который принимает функцию, является последним в списке, то при передачи ему лямбда-выражения, саму лямбду можно прописать после списка параметров. Например, возьмем выше использованную функцию doOperation():"
          },
          {
            "type": "code",
            "content": "fun doOperation(x: Int, y: Int, op: (Int, Int) ->Int){\n \n    val result = op(x, y)\n    println(result)\n}"
          },
          {
            "type": "text",
            "content": "Здесь параметр, который представляет функцию - параметр op, является последним в списке параметров. Поэтому вместо того, чтобы написать так:"
          },
          {
            "type": "code",
            "content": "doOperation(3, 4, {a, b -> a * b}) // 12"
          },
          {
            "type": "text",
            "content": "Мы также можем написать так:"
          },
          {
            "type": "code",
            "content": "doOperation(3, 4) {a, b -> a * b} // 12"
          },
          {
            "type": "text",
            "content": "То есть вынести лямбду за список параметров. Это так называемая конечная лямбда или trailing lambda"
          },
          {
            "type": "subtitle",
            "content": "\nВозвращение лямбда-выражения из функции"
          },
          {
            "type": "text",
            "content": "Также фукция может возвращать лямбда-выражение, которое соответствует типу ее возвращаемого результата:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val action1 = selectAction(1)\n    val result1 = action1(4, 5)\n    println(result1)        // 9\n \n    val action2 = selectAction(3)\n    val result2 = action2(4, 5)\n    println(result2)        // 20\n \n    val action3 = selectAction(9)\n    val result3 = action3(4, 5)\n    println(result3)        // 0\n}\nfun selectAction(key: Int): (Int, Int) -> Int{\n    // определение возвращаемого результата\n    when(key){\n        1 -> return {x, y -> x + y }\n        2 -> return {x, y -> x - y }\n        3 -> return {x, y -> x * y }\n        else -> return {x, y -> 0 }\n    }\n}"
          },
          {
            "type": "subtitle",
            "content": "\nНеиспользуемые параметры"
          },
          {
            "type": "text",
            "content": "Обратим внимание на предыдущий пример на последнюю лямбду:"
          },
          {
            "type": "code",
            "content": "else -> return {x, y -> 0 }"
          },
          {
            "type": "text",
            "content": "Если в функцию selectAction() передается число, отличное от 1, 2, 3, то возвращается лямбда-выражение, которое просто возвращает число 0. \nС одной стороны, это лямбда-выражение должно соответствовать типу возвращаемого результата функции selectAction() - (Int, Int) -> Int"
          },
          {
            "type": "text",
            "content": "С другой стороны, оно не использует параметры, эти параметры не нужны. В этом случае вместо неиспользуемых параметров можно указать прочерки:"
          },
          {
            "type": "code",
            "content": "else -> return {_, _ -> 0 }"
          }
        ]
      },
      {
        "id": 10,
        "title": "Замыкания",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Замыкания"
          },
          {
            "type": "text",
            "content": "Замыкание (closure) представляет объект функции, который запоминает свое лексическое окружение даже в том случае, когда она выполняется вне своей области видимости."
          },
          {
            "type": "text",
            "content": "Технически замыкание включает три компонента:"
          },
          {
            "type": "text",
            "content": "\t• внешняя функция, которая определяет некоторую область видимости и в которой определены некоторые переменные и параметры - лексическое окружение"
          },
          {
            "type": "text",
            "content": "\t• переменные и параметры (лексическое окружение), которые определены во внешней функции"
          },
          {
            "type": "text",
            "content": "\t• вложенная функция, которая использует переменные и параметры внешней функции"
          },
          {
            "type": "code",
            "content": "fun outer(): ()->Unit{       // внешняя функция\n    var n              // некоторая переменная - лексическое окружение\n    fun inner(){     // вложенная функция\n        // действия с переменной n\n    }\n    return ::inner  // возвращаем вложенную функцию\n}"
          },
          {
            "type": "text",
            "content": "В данном случае функция inner и есть замыкание."
          },
          {
            "type": "text",
            "content": "Рассмотрим замыкания на простейшем примере:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val fn = outer() // fn = inner, так как функция outer возвращает функцию inner\n    // вызываем внутреннюю функцию inner\n    fn() // 6\n    fn() // 7\n    fn() // 8\n}\nfun outer(): ()->Unit{       // внешняя функция\n    var n = 5         // некоторая переменная - лексическое окружение функции inner\n    fun inner(){     // вложенная функция\n        // действия с переменной n\n        n++\n        println(n)\n    }\n    return ::inner\n}"
          },
          {
            "type": "text",
            "content": "Здесь функция outer задает область видимости, в которой определены внутренняя функция inner и переменная n. Переменная n представляет лексическое окружение для функции inner. В самой функции inner инкрементируем переменную n и выводим ее значение на консоль. В конце функция outer возвращает функцию inner."
          },
          {
            "type": "text",
            "content": "Далее вызываем функцию outer:"
          },
          {
            "type": "code",
            "content": "val fn = outer()"
          },
          {
            "type": "text",
            "content": "Поскольку функция outer возвращает функцию inner, то переменная fn будет хранить ссылку на функцию inner. При этом эта функция запомнила свое окружение - то есть внешнюю переменную n."
          },
          {
            "type": "text",
            "content": "Далее мы фактически три раза вызываем функцию inner, и мы видим, что переменная n, которая определена вне функции inner, увеличивается на единицу:"
          },
          {
            "type": "code",
            "content": "fn()   // 6\nfn()   // 7\nfn()   // 8"
          },
          {
            "type": "text",
            "content": "То есть несмотря на то, что переменная x определена вне функции inner, эта функция запомнила свое окружение и может его использовать, несомотря на то, что она вызывается вне функции outer, в которой была определена. В этом и суть замыканий."
          },
          {
            "type": "text",
            "content": "Кстати мы можем сократить определение функции outer, используя анонимную функцию:"
          },
          {
            "type": "code",
            "content": "fun outer(): ()-> Unit{\n    var n = 5\n    return {\n        n++\n        println(n)\n    }\n}"
          },
          {
            "type": "text",
            "content": "Рассмотрим другой пример:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val func = multiply(5)\n    val result1 = func(6) // 30\n    println(result1)       // 30\n \n    val result2 = func(5) // 25\n    println(result2)          // 25\n}\nfun multiply(n:Int): (Int)->Int{\n \n    return {m:Int-> n * m}\n}"
          },
          {
            "type": "text",
            "content": "Итак, здесь вызов функцииm ultiply() приводит к вызову другой внутренней функции. Внутренняя же функция представлена лямбда-выражением:"
          },
          {
            "type": "code",
            "content": "{m:Int-> n * m}"
          },
          {
            "type": "text",
            "content": "Оно запоминает окружение, в котором было создана, в частности, значение параметра n."
          },
          {
            "type": "text",
            "content": "В итоге при вызове функции multiply определяется переменная func, которая и представляет собой замыкание, то есть объединяет две вещи: функцию и окружение, в котором функция была создана. Окружение состоит из любой локальной переменной или любого параметра, которые были определены в области действия функции multiply во время создания замыкания."
          },
          {
            "type": "text",
            "content": "То есть result1 — это замыкание, которое содержит и внутреннюю функцию {m: Int-> n * m}, и параметр n, который существовал во время создания замыкания."
          },
          {
            "type": "text",
            "content": "При этом важно не запутаться в параметрах. При определении замыкания:"
          },
          {
            "type": "code",
            "content": "val func = multiply(5)"
          },
          {
            "type": "text",
            "content": "Число 5 передается для параметра n функции multiply."
          },
          {
            "type": "text",
            "content": "При вызове внутренней функции:"
          },
          {
            "type": "code",
            "content": "val result1 = func(6) // 30"
          },
          {
            "type": "text",
            "content": "Число 6 передается для параметра m во внутреннюю функцию (int m) => n * m;"
          },
          {
            "type": "text",
            "content": "Также мы можем использовать другой вариант для вызова замыкания:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val result1 = multiply(5)(6) // 30\n    println(result1)       // 30\n \n    val result2 = multiply(5)(5) // 25\n    println(result2)          // 25\n}\nfun multiply(n:Int): (Int)->Int{\n \n    return {m:Int-> n * m}\n}"
          }
        ]
      }
      ]
  },
  {
    "chapterId": 4,
    "chapterTitle": "ООП",
    "articles": [
      {
        "id": 1,
        "title": "Классы и объекты",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Объектно-ориентированное программирование"
          },
          {
            "type": "subtitle",
            "content": "\nКлассы и объекты"
          },
          {
            "type": "text",
            "content": "Kotlin поддерживает объектно-ориентированную парадигму программирования, а это значит, что программу на данном языке можно представить в виде взаимодействующих между собой объектов."
          },
          {
            "type": "text",
            "content": "Представлением объекта является класс. \nКласс фактически представляет определение объекта. А объект является конкретным воплощением класса. \nНапример, у всех есть некоторое представление о машине, например, кузов, четыре колеса, руль и т.д. - некоторый общий набор характеристик, присущих каждой машине. Это представление фактически и является классом. При этом есть разные машины, у которых отличается форма кузова, какие-то другие детали, то есть есть конкретные воплощения этого класса, конкретные объекты или экземпляры класса."
          },
          {
            "type": "text",
            "content": "Для определения класса применяется ключевое слово class, после которого идет имя класса. А после имени класса в фигурных скобках определяется тело класса. Если класс не имеет тела, то фигурные скобки можно опустить. \nНапример, определим класс, который представляет человека:"
          },
          {
            "type": "code",
            "content": "class Person\n \n// либо можно так\nclass Person { }"
          },
          {
            "type": "text",
            "content": "Класс фактически представляет новый тип данных, поэтому мы можем определять переменные этого типа:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom: Person\n    val bob: Person\n    val alice: Person\n}\n \nclass Person"
          },
          {
            "type": "text",
            "content": "В функции main определены три переменных типа Person."
          },
          {
            "type": "text",
            "content": "Для создания объекта класса необходимо вызвать конструктор данного класса. \nКонструктор фактически представляет функцию, которая называется по имени класса и которая выполняет инициализацию объекта. По умолчанию для класса компилятор генерирует пустой конструктор, который мы можем использовать:"
          },
          {
            "type": "code",
            "content": "val tom: Person = Person()"
          },
          {
            "type": "text",
            "content": "Часть кода после знака равно Person() как раз и представляет вызов конструктора, который создает объект класса Person. До вызова конструктора переменная класса не указывает ни на какой объект."
          },
          {
            "type": "text",
            "content": "Например, создадим три объекта класса Person:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom: Person = Person()\n    val bob: Person = Person()\n    val alice: Person = Person()\n}\n \nclass Person"
          },
          {
            "type": "subtitle",
            "content": "\nСвойства"
          },
          {
            "type": "text",
            "content": "Каждый класс может хранить некоторые данные или состояние в виде свойств. \nСвойства представляют переменные, определенные на уровне класса с ключевыми словами val и var. Если свойство определено с помощью val, то значение такого свойства можно установить только один раз, то есть оно immutable. Если свойство определено с помощью var, то значение этого свойства можно многократно изменять."
          },
          {
            "type": "text",
            "content": "Свойство должно быть инициализировано, то есть обязательно должно иметь начальное значение. Например, определим пару свойств:"
          },
          {
            "type": "code",
            "content": "class Person{\n    var name: String = \"Undefined\"\n    var age: Int = 18\n}"
          },
          {
            "type": "text",
            "content": "В данном случае в классе Person, который представляет человека, определены свойства name (имя человека) и age (возраст человека). И эти свойства инициализированы начальными значениями."
          },
          {
            "type": "text",
            "content": "Поскольку эти свойства определены с var, то мы можем изменить их начальные значения:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val bob: Person = Person()  // создаем объект\n    println(bob.name)       // Undefined\n    println(bob.age)        // 18\n \n    bob.name = \"Bob\"\n    bob.age = 25\n \n    println(bob.name)       // Bob\n    println(bob.age)        // 25\n}\n \nclass Person{\n    var name: String = \"Undefined\"\n    var age: Int = 18\n}"
          },
          {
            "type": "text",
            "content": "Для обращения к свойствам используется имя переменной, которая предствляет объект, и после точки указывается имя свойства. Например, получение значения свойства:"
          },
          {
            "type": "code",
            "content": "val personName : String = bob.name"
          },
          {
            "type": "text",
            "content": "Установка значения свойства:"
          },
          {
            "type": "code",
            "content": "bob.name = \"Bob\""
          },
          {
            "type": "subtitle",
            "content": "\nФункции класса"
          },
          {
            "type": "text",
            "content": "Класс также может содержать функции. \nФункции определяют поведение объектов данного класса. Такие функции еще называют member functions или функции-члены класса. Например, определим класс с функциями:"
          },
          {
            "type": "code",
            "content": "class Person{\n    var name: String = \"Undefined\"\n    var age: Int = 18\n \n    fun sayHello(){\n        println(\"Hello, my name is $name\")\n    }\n \n    fun go(location: String){\n        println(\"$name goes to $location\")\n    }\n \n    fun personToString() : String{\n        return \"Name: $name  Age: $age\"\n    }\n}"
          },
          {
            "type": "text",
            "content": "Функции класса определяется также как и обычные функции. \nВ частности, здесь в классе Person определена функция sayHello(), которая выводит на консоль строку \"Hello\" и эмулирует приветствие объекта Person. \nВторая функция - go() эмулирует движение объекта Person к определенному местоположению. Местоположение передается через параметр location. \nИ третья функция personToString() возвращает информацию о текущем объекте в виде строки."
          },
          {
            "type": "text",
            "content": "В функциях, которые определены внутри класса, доступны свойства этого класса. \nТак, в данном случае в функциях можно обратиться к свойствам name и age, которые определены в классе Person."
          },
          {
            "type": "text",
            "content": "Для обращения к функциям класса необходимо использовать имя объекта, после которого идет название функции и в скобках значения для параметров этой функции:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person()\n    tom.name = \"Tom\"\n    tom.age = 37\n \n    tom.sayHello()\n    tom.go(\"the shop\")\n    println(tom.personToString())\n \n}\n \nclass Person{\n    var name: String = \"Undefined\"\n    var age: Int = 18\n \n    fun sayHello(){\n        println(\"Hello, my name is $name\")\n    }\n \n    fun go(location: String){\n        println(\"$name goes to $location\")\n    }\n \n    fun personToString() : String{\n        return \"Name: $name  Age: $age\"\n    }\n}"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Hello, my name is Tom\nTom goes to the shop\nName: Tom  Age: 37"
          }
        ]
      },
      {
        "id": 2,
        "title": "Конструкторы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Конструкторы"
          },
          {
            "type": "text",
            "content": "Для создания объекта необходимо вызвать конструктор класса. По умолчанию компилятор создает конструктор, который не принимает параметров и который мы можем использовать. Но также мы можем определять свои собственные конструкторы. \n\nКлассы в Kotlin могут иметь одинпервичный конструктор (primary constructor) и один или нескольковторичных конструкторов (secondary constructor)."
          },
          {
            "type": "subtitle",
            "content": "\nВторичные конструкторы"
          },
          {
            "type": "text",
            "content": "Вторичные конструкторы определяются в теле класса с помощью ключевого слова 'constructor':"
          },
          {
            "type": "code",
            "content": "fun main() {\n     \n    val tom = Person(\"Tom\", 39)\n    val bob = Person(\"Bob\", 45)\n      \n    println(\"Name: ${tom.name}  Age: ${tom.age}\")\n    println(\"Name: ${bob.name}  Age: ${bob.age}\")\n}\n \nclass Person{\n    val name: String\n    var age: Int\n      \n    constructor(_name: String, _age: Int){\n        name = _name\n        age = _age\n    }\n}"
          },
          {
            "type": "text",
            "content": "Конструкторы во многом похожи на функциии, как и обычные функции, могут иметь параметры. \nЗдесь в классе Person определен конструктор, принимает два параметра: _name и _age - условно говоря имя и возраст человека. Внутри конструктора эти значения передаются переменным name и age:"
          },
          {
            "type": "code",
            "content": "constructor(_name: String, _age: Int){\n    name = _name\n    age = _age\n}"
          },
          {
            "type": "text",
            "content": "В функции main создаются два объекта Person. Для их создания применяется вторичный конструктор, параметрам которого передаются некоторые значения:"
          },
          {
            "type": "code",
            "content": "val tom = Person(\"Tom\", 39)\nval bob = Person(\"Bob\", 45)"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Name: Tom  Age: 39\nName: Bob  Age: 45"
          },
          {
            "type": "text",
            "content": "Аналогичным образом мы можем определять и большее количество конструкторов:"
          },
          {
            "type": "code",
            "content": "fun main() {\n     \n    val tom = Person(\"Tom\")\n    val bob = Person(\"Bob\", 45)\n      \n    println(\"Name: ${tom.name}  Age: ${tom.age}\")\n    println(\"Name: ${bob.name}  Age: ${bob.age}\")\n}\n \nclass Person{\n    val name: String\n    var age: Int = 0\n     \n    constructor(_name: String){\n        name = _name\n    }\n    constructor(_name: String, _age: Int){\n        name = _name\n        age = _age\n    }\n}"
          },
          {
            "type": "text",
            "content": "Теперь в классе Person также определен еще один конструктор, который принимает только один параметр - имя человека и передает его значение переменной name. Переменная age в данном случае оставляет значение по умолчанию - число 0."
          },
          {
            "type": "text",
            "content": "В функции main вызываем оба конструктора:"
          },
          {
            "type": "code",
            "content": "val tom = Person(\"Tom\")\nval bob = Person(\"Bob\", 45)"
          },
          {
            "type": "text",
            "content": "Для создания первого объекта вызывается первый конструктор, а для второго - второй конструктор. Консольный вывод:"
          },
          {
            "type": "code",
            "content": "Name: Tom  Age: 0\nName: Bob  Age: 45"
          },
          {
            "type": "text",
            "content": "Однако в данном случае мы сталкиваемся с дублированием кода - установкой переменной name. В данном случае это может быть не актуально. Но что, если мы захотим добавить какую-то более сложную логику установки имени, например, с проверкой на длину строки, какие-то другие маркеры? \nВ этом случае лучше делегировать во втором конструкторе установку имени в первый конструктор. То есть из второго конструктора вызвать первый. Для этого применяется ключевое слово this:"
          },
          {
            "type": "code",
            "content": "class Person{\n    val name: String\n    var age: Int = 0\n     \n    constructor(_name: String){\n        name = _name\n    }\n    constructor(_name: String, _age: Int): this(_name){\n        age = _age\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь выражение this(_name) как раз и представляет вызов первого конструктора, где и устанавливается имя."
          },
          {
            "type": "subtitle",
            "content": "\nПервичный конструктор"
          },
          {
            "type": "text",
            "content": "Первичный конструктор является частью заголовка класса и определяется сразу после имени класса:"
          },
          {
            "type": "code",
            "content": "class Person constructor(_name: String, _age: Int){\n    \n}"
          },
          {
            "type": "text",
            "content": "Конструкторы, как и обычные функции, могут иметь параметры. \nТак, в данном случае конструктор имеет параметр _name, который представляет тип String. \nЧерез параметры конструктора мы можем передать извне данные и использовать их для инициализации объекта. При этом первичный конструктор в отличие от функций не определяет никаких действий, он только может принимать данные извне через параметры."
          },
          {
            "type": "text",
            "content": "Если первичный конструктор не имеет никаких аннотаций или модификаторов доступа, как в данном случае, то ключевое слово constructor можно опустить:"
          },
          {
            "type": "code",
            "content": "class Person (_name: String, _age: Int){\n    \n}"
          },
          {
            "type": "text",
            "content": "Значения параметров первичного конструктора можно использовать внутри класса, например, передать их значения переменным класса:"
          },
          {
            "type": "code",
            "content": "fun main() {\n     \n    val tom = Person(\"Tom\", 39)\n    val bob = Person(\"Bob\", 45)\n      \n    println(\"Name: ${tom.name}  Age: ${tom.age}\")\n    println(\"Name: ${bob.name}  Age: ${bob.age}\")\n}\n \nclass Person (_name: String, _age: Int){\n    val name: String = _name\n    var age: Int = _age\n}"
          },
          {
            "type": "text",
            "content": "Стоит отметить, что класс может иметь только один первичный конструктор. И также в классе могут быть одновременно и первичный, и вторичные конструкторы. \nОднако если для класса определен первичный конструктор, то вторичный конструктор должен вызывать первичный с помощью ключевого слова this:"
          },
          {
            "type": "code",
            "content": "class Person(_name: String){\n    val name: String = _name\n    var age: Int = 0\n     \n    constructor(_name: String, _age: Int) : this(_name){\n        age = _age\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь в классе Person определен первичный конструктор, который принимает значение для установки свойства name:"
          },
          {
            "type": "code",
            "content": "class Person(_name: String)"
          },
          {
            "type": "text",
            "content": "И также добавлен вторичный конструктор. Он принимает два параметра: _name и _age. С помощью ключевого слова this вызывается первичный конструктор, поэтому через этот вызов необходимо передать значения для параметров первичного конструктора. В частности, в первичный конструктор передается значение параметра _name. В самом вторичном конструкторе устанавливается значение свойства age."
          },
          {
            "type": "code",
            "content": "constructor(_name: String, _age: Int) : this(_name){\n    age = _age\n}"
          },
          {
            "type": "text",
            "content": "Таким образом, при вызове вторичного конструктора вначале вызывается первичный конструктор, срабатывает блок инициализатора, который устанавливает свойство name. Затем выполняются собственно действия вторичного конструктора, который устанавливает свойство age."
          },
          {
            "type": "text",
            "content": "Используем данную модификацию класса Person:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"Tom\")         // обращение к первичному конструктору\n    val bob = Person(\"Bob\", 45)     // обращение к вторичному конструктору\n     \n    println(\"Name: ${tom.name}  Age: ${tom.age}\")\n    println(\"Name: ${bob.name}  Age: ${bob.age}\")\n}\n \nclass Person(_name: String){\n    val name: String = _name\n    var age: Int = 0\n     \n    constructor(_name: String, _age: Int) : this(_name){\n        age = _age\n    }\n}"
          },
          {
            "type": "text",
            "content": "В функции main создаются два объекта Person. Для создания объекта tom применяется первичный конструктор, который принимает один параметр. Для создания объекта bob применяется вторичный конструктор с двумя параметрами."
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Name: Tom  Age: 0\nName: Bob  Age: 45 "
          },
          {
            "type": "subtitle",
            "content": "\nПервичный конструктор и свойства"
          },
          {
            "type": "text",
            "content": "Первичный конструктор также может использоваться для определения свойств:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val bob = Person(\"Bob\", 23)\n \n    println(\"Name: ${bob.name}  Age: ${bob.age}\")\n}\n \nclass Person(val name: String, var age: Int)    // { } - здесь не нужны"
          },
          {
            "type": "text",
            "content": "Свойства определяются как и параметры, при этом их определение начинается с ключевого слова val (если их не планируется изменять) и var (если свойства должны быть изменяемыми). И в этом случае нам уже необязательно явным образом определять эти свойства в теле класса, так как их уже определяет конструктор. И при вызове конструктора этим свойствам автоматически передаются значения: Person (\"Bob\", 23)"
          },
          {
            "type": "text",
            "content": "Обратите внимание, что если в классе определен только первичный конструктор, то фигурные скобки, которые оформляют тело класса, использовать необязательно. Хотя мы могли бы написать и так:"
          },
          {
            "type": "code",
            "content": "class Person(val name: String, var age: Int){ }"
          },
          {
            "type": "subtitle",
            "content": "\nИнициализатор"
          },
          {
            "type": "text",
            "content": "Кроме конструкторов для инициализации объектов мы можем использовать блоки инициализаторов. Они представляют блок кода в фигурных скобках, перед которым идет слово init:"
          },
          {
            "type": "code",
            "content": "fun main() {\n     \n    val tom = Person(\"Tom\", -100)\n    val bob = Person(\"Bob\", 45)\n      \n    println(\"Name: ${tom.name}  Age: ${tom.age}\")\n    println(\"Name: ${bob.name}  Age: ${bob.age}\")\n}\n \nclass Person (_name: String, _age: Int){\n    val name: String\n    var age: Int = 1\n \n    init{\n        name = _name\n        if(_age >0 && _age < 110) age = _age\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь в классе Person определен следующий блок инициализатора:"
          },
          {
            "type": "code",
            "content": "init{\n        name = _name\n        if(_age >0 && _age < 110) age = _age\n    }"
          },
          {
            "type": "text",
            "content": "В данном случае блок инициализатора применяется для установки переменных. Так, мы можем определить здесь проверку входных значений, как в случае с параметром _age. Можно определить какую-то другую логику, которая должна выполняться при инициализации объекта."
          },
          {
            "type": "text",
            "content": "Стоит отметить, что в классе может быть определено одновременно несколько блоков инициализатора."
          }
        ]
      },
      {
        "id": 3,
        "title": "Пакеты и импорты",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Пакеты и импорт"
          },
          {
            "type": "text",
            "content": "Пакеты в Kotlin представляют логический блок, который объединяет функционал, например, классы и функции, используемые для решения близких по характеру задач. \nТак, классы и функции, которые предназначены для решения одной задачи, можно поместить в один пакет, классы и функции для других задач можно поместить в другие пакеты."
          },
          {
            "type": "text",
            "content": "Для определения пакета применяется ключевое слово package, после которого идет имя пакета:"
          },
          {
            "type": "code",
            "content": "package email"
          },
          {
            "type": "text",
            "content": "Определение пакета помещается в самое начало файла. И все содержимое файла рассматривается как содержимое этого пакета."
          },
          {
            "type": "text",
            "content": "Например, добавим в проект новый файл email.kt:"
          },
          {
            "type": "image",
            "content": "ch4ar3_1"
          },
          {
            "type": "text",
            "content": "И определим в нем следующий код:"
          },
          {
            "type": "code",
            "content": "package email\n \nclass Message(val text: String)\n \nfun send(message: Message, address: String){\n    println(\"Message `${message.text}` has been sent to $address\")\n}"
          },
          {
            "type": "text",
            "content": "Пакет называется \"email\". Он содержит класс Message, который содежит одно свойство text. Условно говоря, это класс представляет email-сообщение, а свойство text - его текст."
          },
          {
            "type": "text",
            "content": "Также в этом пакете определена функция send(), которая условно отправляет сообшение на некоторый адрес."
          },
          {
            "type": "text",
            "content": "Допустим, мы хотим использовать функционал этого пакета в другом файле. Для подключения сущностей из пакета необходимо применить директиву import. Здесь возможны различные способы подключения функционала из пакета. Можно подключить в целом весь пакет:"
          },
          {
            "type": "code",
            "content": "import email.*  "
          },
          {
            "type": "text",
            "content": "После названия пакета ставится точка и звездочка, тем самым импортируются все типы из этого пакета. Например, возьмем другой файл проекта - app.kt, который определяет функцию main, и используем в нем функционал пакета email:"
          },
          {
            "type": "code",
            "content": "import email.*\n \nfun main() {\n \n    val myMessage = Message(\"Hello Kotlin\")\n    send(myMessage, \"tom@gmail.com\")\n}"
          },
          {
            "type": "text",
            "content": "Поскольку в начале файла импортированы все типы из пакета email, то мы можем использовать класс Message и функцию send в функции main."
          },
          {
            "type": "text",
            "content": "Консольный вывод данной программы:"
          },
          {
            "type": "code",
            "content": "Message `Hello Kotlin` has been sent to tom@gmail.com"
          },
          {
            "type": "text",
            "content": "Также можно импортировать типы, определенные в пакете, по отдельности:"
          },
          {
            "type": "code",
            "content": "import email.send\nimport email.Message"
          },
          {
            "type": "subtitle",
            "content": "\nПсевдонимы"
          },
          {
            "type": "text",
            "content": "С помощью оператора as можно определять псевдоним для подключаемого типа и затем обращаться к этому типу через его псевдоним:"
          },
          {
            "type": "code",
            "content": "import email.send as sendEmail\nimport email.Message as EmailMessage\n \nfun main() {\n \n    val myMessage = EmailMessage(\"Hello Kotlin\")\n    sendEmail(myMessage, \"tom@gmail.com\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь для функции send() определен псевдоним sendEmail. И далее для обращения к этой функции надо использовать ее псевдоним:"
          },
          {
            "type": "code",
            "content": "sendEmail(myMessage, \"tom@gmail.com\")"
          },
          {
            "type": "text",
            "content": "Также для класса Message определен псевдоним EmailMessage. Соответственно при использовании класса необходимо применять его псевдоним, а не оригинальное имя:"
          },
          {
            "type": "code",
            "content": "val myMessage = EmailMessage(\"Hello Kotlin\")"
          },
          {
            "type": "text",
            "content": "Псевдонимы могут нам особенно пригодится, если у нас импортируются из разных пакетов типы с одним и тем же именем. Например, пусть в проекте есть файл sms.kt:"
          },
          {
            "type": "code",
            "content": "package sms\n \nclass Message(val text: String)\n \nfun send(message: Message, phoneNumber: String){\n    println(\"Message `${message.text}` has been sent to $phoneNumber\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь определен пакет sms также с классом Message и функцией send для отправке сообшения по sms."
          },
          {
            "type": "text",
            "content": "Допустим, в файле app.kt мы одновременно хотим использовать класс Message и функцию send и из файла email.kt, и из файла sms.kt:"
          },
          {
            "type": "code",
            "content": "import email.send as sendEmail\nimport email.Message as EmailMessage\nimport sms.send as sendSms\nimport sms.Message as SmsMessage\n \nfun main() {\n \n    val myEmailMessage = EmailMessage(\"Hello Kotlin\")\n    sendEmail(myEmailMessage, \"tom@gmail.com\")\n \n    val mySmsMessage = SmsMessage(\"Hello Kotlin\")\n    sendSms(mySmsMessage, \"+1234567890\")\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВстроенные пакеты"
          },
          {
            "type": "text",
            "content": "Kotlin имеет ряд встроенных пакетов, которые подключаюся по умолчанию в любой файл на языке Kotlin:"
          },
          {
            "type": "text",
            "content": "\t• kotlin.*"
          },
          {
            "type": "text",
            "content": "\t• kotlin.annotation.*"
          },
          {
            "type": "text",
            "content": "\t• kotlin.collections.*"
          },
          {
            "type": "text",
            "content": "\t• kotlin.comparisons.*"
          },
          {
            "type": "text",
            "content": "\t• kotlin.io.*"
          },
          {
            "type": "text",
            "content": "\t• kotlin.ranges.*"
          },
          {
            "type": "text",
            "content": "\t• kotlin.sequences.*"
          },
          {
            "type": "text",
            "content": "\t• kotlin.text.*"
          },
          {
            "type": "text",
            "content": "Поэтому если возникнет необходимость использовать какие-то типы, определенные в этих пакетах, то явным образом эти пакеты не нужно импортировать."
          }
        ]
      },
      {
        "id": 4,
        "title": "Наследование",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Наследование"
          },
          {
            "type": "text",
            "content": "Наследование позволяет создавать классы, которые расширяют функциональность или изменяют поведение уже существующих классов. \nВ отношении наследования выделяются два ключевых компонента. \nПрежде всего это базовый класс (класс-родитель, родительский класс, суперкласс), который определяет базовую функциональность. И производный класс(класс-наследник, подкласс), который наследует функциональность базового класса и может расширять или модифицировать ее."
          },
          {
            "type": "text",
            "content": "Чтобы функциональность класса можно было унаследовать, необходимо определить для этого класса аннотацию open. По умолчанию без этой аннотации класс не может быть унаследован."
          },
          {
            "type": "code",
            "content": "open class базовый_класс\nclass производный_класс: первичный_конструктор_базового_класса"
          },
          {
            "type": "text",
            "content": "Для установки наследования после названия производного класса идет двоеточие. После двоеточия в общем случае вызывается первичный конструктор класса, от которого идет наследование. Рассмотрим пример:"
          },
          {
            "type": "code",
            "content": "open class Person{\n    var name: String = \"Undefined\"\n    fun printName() = println(name)\n}\nclass Employee: Person()"
          },
          {
            "type": "text",
            "content":"Например, в данном случае класс Person представляет человека, который имеет свойство name (имя человека) и метод printName() для вывода информации о человеке. \nКласс Employee представляет условного работника. Поскольку работник является человеком, то класс работника будет разделять общий функционал с классом человека. Поэтому вместо того, чтобы заново определять в классе Employee свойство name, лучше унаследовать весь функционал класса Person. \nТо есть в данном случае класс Person является базовым или суперклассом, а класс Employee - производным классом или классом-наследником."
          },
          {
            "type": "text",
            "content": "Но стоит учитывать, что при наследовании производный класс должен вызывать первичный конструктор (а если такого нет, то конструктор по умолчанию) базового класса."
          },
          {
            "type": "text",
            "content": "Здесь класс Person явным образом не определяет первичных конструкторов, поэтому в классе Employee надо вызывать конструктор по умолчанию для класса Person"
          },
          {
            "type": "text",
            "content": "Вызвать конструктор базового класса в производном классе можно двумя способами. Первый способ - после двоеточия сразу указать вызов конструктора базового класса:"
          },
          {
            "type": "code",
            "content": "class Employee: Person()"
          },
          {
            "type": "text",
            "content": "Здесь запись Person() как раз представляет вызов конструктора по умолчанию класса Person."
          },
          {
            "type": "text",
            "content": "Второй способ вызвать конструктор базового класса - определить в производном классе вторичный конструктор и в нем вызвать конструктор базового класса с помощью ключевого слова super:"
          },
          {
            "type": "code",
            "content": "open class Person{\n    var name: String = \"Undefined\"\n    fun printName() = println(name)\n}\nclass Employee: Person{\n \n    constructor() : super()\n}"
          },
          {
            "type": "text",
            "content": "Здесь с помощью ключевого слова constructor в классе Employee определяется вторичный конструктор. А после списка его параметров после двоеточия идет обращение к конструктору базового класса: \nconstructor() : super()\nТо есть здесь вызов super() - это и есть вызов конструктора базового класса."
          },
          {
            "type": "text",
            "content": "Вне зависимости какой способ будет выбран, далее мы сможем создавать объекты класса Employee и использовать для него уснаследованный от класса Person функционал:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val bob: Employee = Employee()\n    bob.name = \"Bob\"\n    bob.printName()     // Bob\n}\nopen class Person{\n    var name: String = \"Undefined\"\n    fun printName() = println(name)\n}\nclass Employee: Person()"
          },
          {
            "type": "text",
            "content": "Стоит отметить, что те классы, которые явным образом не наследуются от других классов, неявно наследуются от класса Any."
          },
          {
            "type": "subtitle",
            "content": "\nНаследование класса с первичным конструктором"
          },
          {
            "type": "text",
            "content": "Если базовый класс явным образом определяет конструктор (первичный или вторичный), то производный класс должен вызывать этот конструктор. Для вызова конструктора базового в производном применяются те ж способы."
          },
          {
            "type": "text",
            "content": "Первый способ - вызвать конструктор после названия класса через двоеточие:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val bob: Employee = Employee()\n    bob.name = \"Bob\"\n    bob.printName()     // Bob\n}\nopen class Person{\n    var name: String = \"Undefined\"\n    fun printName() = println(name)\n}\nclass Employee: Person()"
          },
          {
            "type": "text",
            "content": "В данном случае класс Person через конструктор устанавливает свойство name. Поэтому в классе Employee тоже определен конструктор, который принимает стороковое значение и передает его в конструктор Person."
          },
          {
            "type": "text",
            "content": "Если производный класс не имеет явного первичного конструктора, тогда при вызове вторичного конструктора должен вызываться конструктор базового класса через ключевое слово super:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String){\n    fun printName()= println(name)\n}\nclass Employee: Person{\n \n    constructor(empName: String) : super(empName){}\n}"
          },
          {
            "type": "text",
            "content": "Опять же, поскольку конструктор Person принимает один параметр, то в super() нам надо передать значение для этого параметра."
          },
          {
            "type": "text",
            "content": "Применение классов:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val bob = Employee(\"Bob\")\n    bob.printName()\n}\n \nopen class Person(val name: String){\n    fun printName() = println(name)\n}\nclass Employee(empName: String): Person(empName)"
          },
          {
            "type": "text",
            "content": "Выше рассматривался случай, когда в базовом классе определен первичный конструктор. Но все то же действует и в том случае, если в базовом классе есть только вторичные конструкторы:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val bob = Employee(\"Bob\")\n    bob.printName()\n}\n \nopen class Person{\n \n    val name: String\n    constructor(userName: String){\n        name = userName\n    }\n    fun printName() = println(name)\n}\nclass Employee(empName: String): Person(empName)"
          },
          {
            "type": "subtitle",
            "content": "\nРасширение базового класса"
          },
          {
            "type": "text",
            "content": "Производный класс наследует функционал от базового класса, но также может определять и свой собственный функционал:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val bob = Employee(\"Bob\", \"JetBrains\")\n    bob.printName()\n    bob.printCompany()\n}\n \nopen class Person(val name: String){\n    fun printName() = println(name)\n}\nclass Employee(empName: String, val company: String): Person(empName){\n \n    fun printCompany() = println(company)\n}"
          },
          {
            "type": "text",
            "content": "В данном случае класс Employee добаваляет к унаследованному функционалу свойство company, которое хранит компанию работника, и функцию printCompany()."
          },
          {
            "type": "text",
            "content": "Стоит отметить, что в Kotlin мы можем унаследовать класс только от одного класса, множественное наследование не поддерживается."
          },
          {
            "type": "text",
            "content": "Также, стоит отметить, что все классы по умолчанию наследуются от класса Any, даже если класс Any явным образом не указан в качестве базового. Поэтому любой класс уже по умолчанию будет иметь все свойства и функции, которые определены в классе Any."
          }
        ]
      },
      {
        "id": 5,
        "title": "Переопределение методов и свойств",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Переопределение методов и свойств"
          },
          {
            "type": "text",
            "content": "Kotlin позволяет переопределять в производном классе функции и свойства, которые определенны в базовом классе. \nЧтобы функции и свойства базового класа можно было переопределить, к ним применяется аннотация open. \nПри переопределении в производном классе к этим функциям применяется аннотация override."
          },
          {
            "type": "subtitle",
            "content": "\nПереопределение свойств"
          },
          {
            "type": "text",
            "content": "Чтобы указать, что свойство можно переопределить в производном классе, перед его определением указывается ключевое слово open:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String){\n    open var age: Int = 1\n}"
          },
          {
            "type": "text",
            "content": "В данном случае свойство age доступно для переопределения."
          },
          {
            "type": "text",
            "content": "Если свойство определяется через первичный конструктор, то также перед его определением ставится аннотация open:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String, open var age: Int = 1)"
          },
          {
            "type": "text",
            "content": "В производном классе для переопределения свойства перед ним указывается аннотация override."
          },
          {
            "type": "code",
            "content": "open class Person(val name: String, open var age: Int = 1)\n \nopen class Employee(name: String): Person(name){\n \n    override var age: Int = 18\n}"
          },
          {
            "type": "text",
            "content": "Здесь переопределение заключается в изменении начального значения для свойства age."
          },
          {
            "type": "text",
            "content": "Также переопределить свойство можно сразу в первичном конструкторе:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String, open var age: Int = 1)\n \nopen class Employee(name: String, override var age: Int = 18): Person(name, age)"
          },
          {
            "type": "text",
            "content": "Применение:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"Tom\")\n    println(\"Name: ${tom.name}  Age: ${tom.age}\")\n \n    val bob = Employee(\"Bob\")\n    println(\"Name: ${bob.name}  Age: ${bob.age}\")\n}\nopen class Person(val name: String, open var age: Int = 1)\n \nopen class Employee(name: String, override var age: Int = 18): Person(name, age)"
          },
          {
            "type": "text",
            "content": "Консольный вывод:"
          },
          {
            "type": "code",
            "content": "Name: Tom  Age: 1\nName: Bob  Age: 18"
          },
          {
            "type": "subtitle",
            "content": "\nПереопределение геттеров и сеттеров"
          },
          {
            "type": "text",
            "content": "Также можно переопределять геттеры и сеттеры свойств:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String){\n \n    open val fullInfo: String\n        get() = \"Person $name - $age\"\n \n    open var age: Int = 1\n        set(value){\n            if(value in 1..109) field = value\n        }\n}\nopen class Employee(name: String): Person(name){\n \n    override val fullInfo: String\n        get() = \"Employee $name - $age\"\n \n    override var age: Int = 18\n        set(value){\n            if(value in 18..109) field = value\n        }\n}\n \nfun main() {\n \n    val tom = Person(\"Tom\")\n    tom.age = 14\n    println(tom.fullInfo)       // Person Tom - 14\n \n    val bob = Employee(\"Bob\")\n    bob.age = 14\n    println(bob.fullInfo)       // Employee Bob - 18\n}"
          },
          {
            "type": "text",
            "content": "Здесь класс Employee переопределяет геттер свойства fullInfo и сеттер свойства age"
          },
          {
            "type": "subtitle",
            "content": "\nПереопределение методов"
          },
          {
            "type": "text",
            "content": "Чтобы функции базового класа можно было переопределить, к ним применяется аннотация open. При переопределении в производном классе к этим функциям применяется аннотация override:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String){\n    open fun display() = println(\"Name: $name\")\n}\nclass Employee(name: String, val company: String): Person(name){\n \n    override fun display() = println(\"Name: $name    Company: $company\")\n}\n \nfun main() {\n \n    val tom = Person(\"Tom\")\n    tom.display()       // Name: Tom\n \n    val bob = Employee(\"Bob\", \"JetBrains\")\n    bob.display()       // Name: Bob  Company: JetBrains\n}"
          },
          {
            "type": "text",
            "content": "Функция display определена в классе Person с аннотацией open, поэтому в производных классах его можно переопределить. В классе Employee эта функция переопределена с применением аннотации override."
          },
          {
            "type": "subtitle",
            "content": "\nПереопределение в иерархии наследования классов"
          },
          {
            "type": "text",
            "content": "Стоит учитывать, что переопределить функции можно по всей иерархии наследования. Например, у нас может быть класс Manager, унаследованный от Employee:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String){\n \n    open fun display() =  println(\"Name: $name\")\n}\nopen class Employee(name: String, val company: String): Person(name){\n \n    override fun display() {\n        println(\"Name: $name    Company: $company\")\n    }\n}\nclass Manager(name: String, company: String):Employee(name, company){\n \n    override fun display() {\n        println(\"Name: $name Company: $company  Position: Manager\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае класс Manager переопределяет функцию display, поскольку среди его базовых классов есть класс Person, который определяет эту функцию с ключевым словом open."
          },
          {
            "type": "subtitle",
            "content": "\nЗапрет переопределения"
          },
          {
            "type": "text",
            "content": "В это же время иногда бывает необходимо запретить дальнейшее переопределение функции в классах-наследниках. Для этого применяется ключевое слово final:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String){\n \n    open fun display() = println(\"Name: $name\")\n}\nopen class Employee(name: String, val company: String): Person(name){\n \n    final override fun display() {\n        println(\"Name: $name    Company: $company\")\n    }\n}\nclass Manager(name: String, company: String):Employee(name, company){\n    // теперь функцию нельзя переопределить\n    /*override fun display() {\n        println(\"Name: $name Company: $company  Position: Manager\")\n    }*/\n}"
          },
          {
            "type": "subtitle",
            "content": "\nОбращение к реализации из базового класса"
          },
          {
            "type": "text",
            "content": "С помощью ключевого слова super в производном классе можно обращаться к реализации из базового класса."
          },
          {
            "type": "code",
            "content": "open class Person(val name: String){\n \n    open val fullInfo: String\n        get() = \"Name: $name\"\n \n    open fun display(){\n        println(\"Name: $name\")\n    }\n}\nopen class Employee(name: String, val company: String): Person(name){\n \n    override val fullInfo: String\n        get() = \"${super.fullInfo} Company: $company\"\n \n    final override fun display() {\n        super.display()\n        println(\"Company: $company\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае производный класс Employee при переопределении свойства и функции применяет реализацию из базового класса Person. \nНапример, через super.fullInfo возвращается значение свойства из базового класса (то есть значение свойства name), а с помощью вызова super.display() вызывается реализация функции display из класса Person."
          }
        ]
      },
      {
        "id": 6,
        "title": "Модификаторы видимости",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Модификаторы видимости"
          },
          {
            "type": "text",
            "content": "Все используемые типы, а также компоненты типов (классы, объекты, интерфейсы, конструкторы, функции, свойства) имеют определеннй уровень видимости, определяемый модификатором видимости (модификатором доступа). \n\nМодификатор видимости определяет, где те или иные типы и их компоненты доступны и где их можно использовать. \nВ Kotlin есть следующие модификаторы видимости:"
          },
          {
            "type": "text",
            "content": "\t• private: классы, объекты, интерфейсы, а также функции и свойства, определенные вне класса, с этим модификатором видны только в том файле, в котором они определены. Члены класса с этим модификатором видны только в рамках своего класса"
          },
          {
            "type": "text",
            "content": "\t• protected: члены класса с этим модификатором видны в классе, в котором они определены, и в классах-наследниках"
          },
          {
            "type": "text",
            "content": "\t• internal: классы, объекты, интерфейсы, функции, свойства, конструкторы с этим модификатором видны в любой части модуля, в котором они определены. \nМодуль представляет набор файлов Kotlin, скомпилированных вместе в одну структурную единицу. Это может быть модуль IntelliJ IDEA или проект Maven"
          },
          {
            "type": "text",
            "content": "\t• public: классы, функции, свойства, объекты, интерфейсы с этим модификатором видны в любой части программы. (При этом если функции или классы с этим модификатором определены в другом пакете их все равно нужно импортировать)"
          },
          {
            "type": "text",
            "content": "Для установки уровня видимости модификатор ставится перед ключевыми словами var/val/fun в самом начале определения свойства или функции."
          },
          {
            "type": "text",
            "content": "Если модификатор видимости явным образом не указан, то применяется модификатор public.\nТо есть следующий класс"
          },
          {
            "type": "code",
            "content": "class Person(){\n \n    var name = \"Undefined\"\n    var age = 18\n     \n    fun printPerson(){\n        println(\"Name: $name  Age: $age\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Будет эквивалентен следующему определению класса:"
          },
          {
            "type": "code",
            "content": "class Person(){\n \n    public var name = \"Undefined\"\n    public var age = 18\n \n    public fun printPerson(){\n        println(\"Name: $name  Age: $age\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Если свойства объявляются через первичный конструктор и для них явным образом не указан модификатор видимости:"
          },
          {
            "type": "code",
            "content": "class Person(val name: String, val age: Int){\n    public fun printPerson(){\n        println(\"Name: $name  Age: $age\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "То также к таким свойствам автоматически применяется public:"
          },
          {
            "type": "code",
            "content": "class Person(public val name: String, public val age: Int){\n    public fun printPerson(){\n        println(\"Name: $name  Age: $age\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Соответственно мы можем обращаться к подобным компонентам класса в любом месте программы:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"Tom\", 37)\n    tom.printPerson()       // Name: Tom    Age: 37\n \n    println(tom.name)\n    println(tom.age)\n}"
          },
          {
            "type": "subtitle",
            "content": "\nprivate"
          },
          {
            "type": "text",
            "content": "Если же к свойствам и методам применяется модификатор private, то к ним нельзя будет обратиться извне - вне данного класса."
          },
          {
            "type": "code",
            "content": "class Person(private val name:String, _age: Int){\n \n    private val age = _age\n \n    fun printPerson(){\n        printName()\n        printAge()\n    }\n    private fun printName(){\n        println(\"Name: $name\")\n    }\n    private fun printAge(){\n        println(\"Age: $age\")\n    }\n}\n \nfun main() {\n \n    val tom = Person(\"Tom\", 37)\n    tom.printPerson()\n     \n    // println(tom.name)   // Ошибка! - свойство name - private\n    // tom.printAge()  // Ошибка! - функция printAge - private\n}"
          },
          {
            "type": "text",
            "content": "В данном случае класс Person определяет два свойства name (имя человека) и age (возраст человека). Чтобы было более показательно, одно свойство определено через конструктор, а второе как переменная класса. И поскольку эти свойства определены с модификатором private, то мы можем к ним обращаться только внутри этого класса. Вне класса обращаться к ним нельзя:"
          },
          {
            "type": "code",
            "content": "println(tom.name)   // Ошибка! - свойство name - private"
          },
          {
            "type": "text",
            "content": "Также в классе определены три функции printPerson(), printAge() и printName(). Последние две функции выводят значения свойств. А функция printPerson выводит информацию об объекте, вызывая предыдущие две функции."
          },
          {
            "type": "text",
            "content": "Однако функции printAge() и printName() определены как приватные, поэтому их можно использовать только внутри класса:"
          },
          {
            "type": "code",
            "content": "tom.printAge()  // Ошибка! - функция printAge - private"
          },
          {
            "type": "subtitle",
            "content": "\nprotected"
          },
          {
            "type": "text",
            "content": "Модификатор protected определяет свойства и функции, которые из вне класса видны только в классах-наследниках:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Employee(\"Tom\", 37)\n    tom.printEmployee()       // Name: Tom    Age: 37\n \n    // println(tom.name)   // Ошибка! - свойство name - protected\n    // tom.printPerson()  // Ошибка! - функция printPerson - protected\n}\nopen class Person(protected val name:String, private val age: Int){\n \n     protected fun printPerson(){\n        printName()\n        printAge()\n    }\n    private fun printName(){\n        println(\"Name: $name\")\n    }\n    private fun printAge(){\n        println(\"Age: $age\")\n    }\n}\nclass Employee(name:String, age: Int) : Person(name, age){\n \n    fun printEmployee(){\n        println(\"Employee $name. Full information:\")\n        printPerson()\n        // printName() // нельзя - printName - private\n        // println(\"Age: $age\")    // нельзя age - private\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь в классе Person свойство name определенно как protected, поэтому оно доступно в классе-наследнике Employee (однако вне базового и производного класса - например, в функции main оно недоступно). А вот свойство age- приватное, поэтому оно доступно только внутри класса Person."
          },
          {
            "type": "text",
            "content": "Также в классе Employee будет доступна функция printPerson(), так как она имеет модификатор protected, а функции printAge() и printName() с модификатором private будут недоступны."
          },
          {
            "type": "subtitle",
            "content": "\nМодификаторы конструкторов"
          },
          {
            "type": "text",
            "content": "Конструкторы как первичные, так и вторичные также могут иметь модификаторы. Модификатор указывается перед ключевым словом constructor. По умолчанию они имеют модификатор public. Если для первичного конструктора необходимо явным образом установить модификатор доступа, то конструктор определяется с помощью ключевого слова constructor:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    // val bob  = Person(\"Bob\")    // Так нельзя - конструктор private\n}\nopen class Person private constructor(val name:String){\n \n     fun printPerson(){\n        println(\"Name: $name\")\n    }\n}\n// class Employee(name:String) : Person(name)  // так нельзя - конструктор в Person private"
          },
          {
            "type": "text",
            "content": "Стоит отметить, что в данном случае, поскольку конструктор приватный мы не можем его использовать вне класса ни для создания объекта класса в функции main, ни при наследовании. \nНо мы можем использовать такой конструктор в других конструкторах внутри класса:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Employee(\"Tom\", 37)\n    tom.printPerson()\n}\nopen class Person private constructor(val name:String){\n \n    var age: Int = 0\n    protected constructor(_name:String, _age: Int): this(_name){    // вызываем приватный конструктор\n        age = _age\n    }\n     fun printPerson(){\n        println(\"Name: $name Age: $age\")\n    }\n}\nclass Employee(name:String, age: Int) : Person(name, age)"
          },
          {
            "type": "text",
            "content": "Здесь вторичный конструктор класса Person, который имеет модификатор protected (то есть доступен в текущем классе и классах-наследниках) вызывает первичный конструктор класса Person, который имеет модификато private."
          },
          {
            "type": "subtitle",
            "content": "\nМодификаторы объектов и типов верхнего уровня"
          },
          {
            "type": "text",
            "content": "Классы, а также переменные и функции, которые определены вне других классов, также могут иметь модификаторы public, private и internal."
          },
          {
            "type": "text",
            "content": "Допустим, у нас есть файл base.kt, который определяет одноименный пакет:"
          },
          {
            "type": "code",
            "content": "package base\n \nprivate val privateVal = 3\ninternal val internalVal = 4\nval publicVal = 5\n \nprivate fun privateFun() = println(\"privateFn\")\nfun internalFun() = println(\"internalFn\")\nfun publicFun() = println(\"publicFn\")\n \nprivate class PrivateClass(val name: String)\ninternal class InternalClass(val name:String)\nclass PublicClass(val name:String)\n \nfun printData(){\n    // внутри модуля доступны приватные идентификаторы\n    val privateClass= PrivateClass(\"Tom\")\n    println(privateVal)\n    privateFun()\n \n    // внутри модуля доступны internal-идентификаторы\n    val internalClass= InternalClass(\"Tom\")\n    println(internalVal)\n    internalFun()\n \n    // внутри модуля доступны public-идентификаторы\n    val publicClass= PublicClass(\"Tom\")\n    println(publicVal)\n    publicFun()\n}"
          },
          {
            "type": "text",
            "content": "Внутри данного файла мы можем использовать его приватные переменные, функции классы. Однако при подключении этого пакета в другие файлы, приватные переменные, функции и классы будут недоступны:"
          },
          {
            "type": "code",
            "content": "import base.*\n \nfun main() {\n \n    publicFun()\n    val publicClass= PublicClass(\"Tom\")\n    println(publicVal)\n \n \n    // privateFun()                         // функция недоступна\n    // val privateClass= PrivateClass(\"Tom\")    // класс недоступен\n    // println(privateVal)      // переменная недоступна\n \n    // если в одном модуле, то internal-компоненты доступны\n    internalFun()                         // функция доступна\n    val internalClass= InternalClass(\"Tom\")    // класс доступен\n    println(internalVal)      // переменная доступна\n}"
          },
          {
            "type": "text",
            "content": "Однако даже внутри одного файла есть ограничения на использование приватных классов:"
          },
          {
            "type": "code",
            "content": "package email\n \nprivate class Message(val text: String)\n \nfun send(message: Message, address : String){\n    println(\"Message `${message.text}` has been sent to $address\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь мы столкнемся с ошибкой, так как публичная функция не может принимать параметр приватного класса. И в данном случае нам надо либо сделать класс Message публичным, либо функцию send приватной."
          }
        ]
      },
      {
        "id": 7,
        "title": "Геттеры и сеттеры",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Геттеры и сеттеры"
          },
          {
            "type": "text",
            "content": "Геттеры (getter) и сеттеры (setter) (еще их называют методами доступа) позволяют управлять доступом к переменной. Их формальный синтаксис:"
          },
          {
            "type": "code",
            "content": "var имя_свойства[: тип_свойства] [= инициализатор_свойства]\n    [getter]\n    [setter]"
          },
          {
            "type": "text",
            "content": "Инициализатор, геттер и сеттер свойства необязательны. Указывать тип свойства также необязательно, если он может быть выведен их значения инициализатора или из возвращаемого значения геттера."
          },
          {
            "type": "text",
            "content": "Геттеры и сеттеры необязательно определять именно для свойств внутри класса, они могут также применяться к переменным верхнего уровня."
          },
          {
            "type": "subtitle",
            "content": "\nСеттер"
          },
          {
            "type": "text",
            "content": "Сеттер определяет логику установки значения переменной. Он определяется с помощью слова set. Например, у нас есть переменная age, которая хранит возраст пользователя и представляет числовое значение."
          },
          {
            "type": "code",
            "content": "var age: Int = 18"
          },
          {
            "type": "text",
            "content": "Но теоретически мы можем установить любой возраст: 2, 6, -200, 100500. И не все эти значения будут корректными. \nНапример, у человека не может быть отрицательного возраста. И для проверки входных значений можно использовать сеттер:"
          },
          {
            "type": "code",
            "content": "var age: Int = 18\n    set(value){\n        if((value>0) and (value < 110))\n            field = value\n    }\n \nfun main() {\n \n    println(age)    // 18\n    age = 45\n    println(age)    // 45\n    age = -345\n    println(age)    // 45\n}"
          },
          {
            "type": "text",
            "content": "Блок set определяется сразу после свойства, к которому оно относится - в данном случае после свойства age."
          },
          {
            "type": "text",
            "content": "В блоке set проверяем, входит ли устанавливаемое значение в диапазон допустимых значений. Если входит, то есть если значение корректно, то передаем его объекту field. Если значение некорректно, то свойство просто сохраняет свое предыдущее значение."
          },
          {
            "type": "text",
            "content": "Идентификатор field представляет автоматически генерируемое поле, которое непосредственно хранит значение свойства. Стоит отметить, что к полю через идентификатор field можно обратиться только в геттере или в сеттере."
          },
          {
            "type": "text",
            "content": "В функции main при втором обращении к сеттеру (age = -345) можно заметить, что значение свойства age не изменилось. Так как новое значение -345 не входит в диапазон от 0 до 110."
          },
          {
            "type": "subtitle",
            "content": "\nГеттер"
          },
          {
            "type": "text",
            "content": "Геттер управляет получением значения свойства и определяется с помощью ключевого слова get:"
          },
          {
            "type": "code",
            "content": "var age: Int = 18\n    set(value){\n        if((value>0) and (value <110))\n            field = value\n    }\n    get() = field"
          },
          {
            "type": "text",
            "content": "Справа от выражения get() через знак равно указывается возвращаемое значение. В данном случае возвращается значения поля field, которое хранит значение свойства name. Хотя в таком геттер большого смысла нет, поскольку получить подобное значение мы можем и без геттера."
          },
          {
            "type": "text",
            "content": "Если геттер должен содержать больше инструкций, то геттер можно оформить в блок с кодом внутри фигурных скобок:"
          },
          {
            "type": "code",
            "content": "var age: Int = 18\n    set(value){\n        println(\"Call setter\")\n        if((value>0) and (value <110))\n            field = value\n    }\n    get(){\n        println(\"Call getter\")\n        return field\n    }"
          },
          {
            "type": "text",
            "content": "Если геттер оформлен в блок кода, то для возвращения значения необходимо использовать оператор return. И, таким образом, каждый раз, когда мы будем получать значение переменной age(например, в случае с вызовом println(age)), будет срабатывать геттер, когда возвращает значение. Например:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    println(age)    // срабатывает get\n    age = 45        // срабатывает set\n    println(age)    // срабатывает get\n}"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Call getter\n18\nCall setter\nCall getter\n45"
          },
          {
            "type": "subtitle",
            "content": "\nИспользование геттеров и сеттеров в классах"
          },
          {
            "type": "text",
            "content": "Хотя геттеры и сеттеры могут использоваться к глобальным переменным, как правило, они применяются для опосредования доступа к свойствам класса."
          },
          {
            "type": "text",
            "content": "Используем сеттер:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val bob: Person = Person(\"Bob\")\n    bob.age = 25        // вызываем сеттер\n \n    println(bob.age)   // 25\n    bob.age = -8        // вызываем сеттер\n    println(bob.age)   // 25\n}\nclass Person(val name: String){\n \n    var age: Int = 1\n        set(value){\n            if((value>0) and (value <110))\n                field = value\n        }\n}"
          },
          {
            "type": "text",
            "content": "При втором обращении к сеттеру (bob.age = -8) можно заметить, что значение свойства age не изменилось. Так как новое значение -8 не входит в диапазон от 0 до 110."
          },
          {
            "type": "subtitle",
            "content": "\nВычисляемый геттер"
          },
          {
            "type": "text",
            "content": "Геттер может возвращать вычисляемые значения, которые могут задействовать несколько свойств:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val tom = Person(\"Tom\", \"Smith\")\n    println(tom.fullname)   // Tom Smith\n    tom.lastname = \"Simpson\"\n    println(tom.fullname)   // Tom Simpson\n}\nclass Person(var firstname: String, var lastname: String){\n \n    val fullname: String\n        get() = \"$firstname $lastname\"\n}"
          },
          {
            "type": "text",
            "content": "Здесь свойство fullname определяет блок get, который возвращает полное имя пользователя, созданное на основе его свойств firstname и lastname. При этом значение самого свойства fullname напрямую мы изменить не можем - оно определено доступно только для чтения. Однако если изменятся значения составляющих его свойств - firstname и lastname, то также изменится значение, возвращаемое из fullname."
          },
          {
            "type": "subtitle",
            "content": "\nИспользование полей для хранения значений"
          },
          {
            "type": "text",
            "content": "Выше уже рассматривалось, что с помощью специального поля field в сеттере и геттере можно обращаться к непосредственному значению свойства, которое хранится в специальном поле. Однако мы сами можем явным образом определить подобное поле. Нередко это приватное поле:"
          },
          {
            "type": "text",
            "content": "Можно использовать одновременно и геттер, и сеттер:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"Tom\")\n    println(tom.age)    // 1\n    tom.age = 37\n    println(tom.age)    // 37\n    tom.age = 156\n    println(tom.age)    // 37\n}\nclass Person(val name: String){\n \n    private var _age = 1\n    var age: Int\n        set(value){\n            if((value > 0) and (value < 110))\n                _age = value\n        }\n        get()=  _age\n}"
          },
          {
            "type": "text",
            "content": "Здесь для свойства age добавлены геттер и сеттер, которые фактически являются надстройкой над полей _age, которое собственно хранит значение."
          }
        ]
      },
      {
        "id": 8,
        "title": "Абстрактные классы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Абстрактные классы и методы"
          },
          {
            "type": "text",
            "content": "Абстрактные классы - это классы, определенные с модификатором abstract. \nОтличительной особенностью абстрактных классов является то, что мы не можем создать объект подобного класса. \nНапример, определим абстрактный класс Human:"
          },
          {
            "type": "code",
            "content": "abstract class Human(val name: String)"
          },
          {
            "type": "text",
            "content": "Абстрактный класс, как и обычный, может иметь свойства, функции, конструкторы, но создать его объект напрямую вызвав его конструктор мы не можем:"
          },
          {
            "type": "code",
            "content": "val kate: Human     // норм, просто определение переменной\nval alice: Human = Human(\"Alice\")   // ! ошибка, создать объект нельзя"
          },
          {
            "type": "text",
            "content": "Такой класс мы можем только унаследовать:"
          },
          {
            "type": "code",
            "content": "abstract class Human(val name: String){\n \n    fun hello(){\n        println(\"My name is $name\")\n    }\n}\nclass Person(name: String): Human(name)"
          },
          {
            "type": "text",
            "content": "Стоит отметить, что в данном случае перед абстрактным классом не надо указывать аннотацию open, как при наследовании неабстрактных классов."
          },
          {
            "type": "code",
            "content": "fun main(args: Array<String>) {\n \n    val kate: Person = Person(\"Kate\")\n    val slim: Human = Person(\"Slim Shady\")\n    kate.hello()    // My name is Kate\n    slim.hello()    // My name is Slim Shady\n}"
          },
          {
            "type": "text",
            "content": "Абстрактные классы могут иметь абстрактные методы и свойства. Это такие функции и свойства, которые определяются с ключевым словом abstract. \nАбстрактные методы не содержат реализацию, то есть у них нет тела. А для абстрактных свойств не указывается значение. \nПри этом абстрактные методы и свойства можно определить только в абстрактных классах:"
          },
          {
            "type": "code",
            "content": "abstract class Human(val name: String){\n \n    abstract var age: Int\n    abstract fun hello()\n}\nclass Person(name: String): Human(name){\n     \n    override var age : Int = 1\n    override fun hello(){\n        println(\"My name is $name\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Если класс наследуется от абстрактного класса, то он должен либо реализовать все его абстрактные методы и свойства, либо также быть абстрактным."
          },
          {
            "type": "text",
            "content": "Так, в данном случае класс Person должен обязательно определить реализацию для функции hello() и свойства age. При этом, как и при переопределении обычных методов и свойств, применяется аннотация override."
          },
          {
            "type": "text",
            "content": "Абстрактные свойства также можно реализовать в первичном конструкторе:"
          },
          {
            "type": "code",
            "content": "abstract class Human(val name: String){\n \n    abstract var age: Int\n    abstract fun hello()\n}\nclass Person(name: String, override var age : Int): Human(name){\n    override fun hello(){\n        println(\"My name is $name\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Зачем нужны абстрактные классы? \nКлассы обычно отражают какие-то сущности реального мира. Но некоторые из этих сущностей представляют абстракцию, которая непосредственного воплощения не имеет. \nНапример, возьмем систему геометрических фигур. В реальности не существует геометрической фигуры как таковой. Есть круг, прямоугольник, квадрат, но просто фигуры нет. Однако же и круг, и прямоугольник имеют что-то общее и являются фигурами. В этом случае мы можем определить абстрактный класс фигуры и затем от него унаследовать все остальные классы фигур:"
          },
          {
            "type": "code",
            "content": "// абстрактный класс фигуры\nabstract class Figure {\n    // абстрактный метод для получения периметра\n    abstract fun perimeter(): Float\n \n    // абстрактный метод для получения площади\n    abstract fun area(): Float\n}\n// производный класс прямоугольника\nclass Rectangle(val width: Float, val height: Float) : Figure()\n{\n    // переопределение получения периметра\n    override fun perimeter(): Float{\n        return width * 2 + height * 2;\n    }\n    // переопрелеление получения площади\n    override fun area(): Float{\n        return width * height;\n    }\n}"
          }
        ]
      },
      {
        "id": 9,
        "title": "Интерфейсы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Интерфейсы"
          },
          {
            "type": "text",
            "content": "Интерфейсы представляют контракт - набор функциональности, который должен реализовать класс. \nИнтерфейсы могут содержать объявления свойств и функций, а также могут содержать их реализацию по умолчанию. \nИнтерфейсы позволяют реализовать в программе концепцию полиморфизма и решить проблему множественного наследования, поскольку класс может унаследовать только один класс, зато интерфейсов он может реализовать множество."
          },
          {
            "type": "text",
            "content": "Для определения интерфейса применяется ключевое слово interface:"
          },
          {
            "type": "code",
            "content": "interface название_интерфейса{\n    // определения функций и свойств\n}"
          },
          {
            "type": "text",
            "content": "Для применения интерфейса после имени класса через двоеточие (как при наследовании) указывается имя применяемого интерфейса:"
          },
          {
            "type": "code",
            "content": "interface Movable{}\nclass Car : Movable {}"
          },
          {
            "type": "text",
            "content": "В данном случае класс Car реализует интерфейс Movable."
          },
          {
            "type": "text",
            "content": "Интерфейс может определять функции без реализации. Например:"
          },
          {
            "type": "code",
            "content": "interface Movable{\n    fun move()      // определение функции без реализации\n}"
          },
          {
            "type": "text",
            "content": "Например, в данном случае интерфейс Movable представляет функционал транспортного средства и определяет одну функцию без реализации - функцию move(), которая условно предназначена для передвижения транспортного средства."
          },
          {
            "type": "text",
            "content": "Таким образом, у нас еть интерфейс Movable, которое представляет непонятно какое транспортное средство, и есть функция move, которая предназначена для перемещения транспортного средства, но как именно это перемещение осуществляется - неизвестно."
          },
          {
            "type": "text",
            "content": "Стоит отметить, что мы не можем напрямую создать объект интерфейса, так как интерфейс не поддерживает конструкторы и просто представляет шаблон, которому класс должен соответствовать."
          },
          {
            "type": "text",
            "content": "Определим два класса, которые применяют этот интерфейс:"
          },
          {
            "type": "code",
            "content": "// класс машины\nclass Car : Movable{\n    override fun move(){\n        println(\"Едем на машине\")\n    }\n}\n// класс самолета\nclass Aircraft : Movable{\n    override fun move(){\n        println(\"Летим на самолете\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь определены классы Car и Aircraft, которые условно представляют машину и самолет. При применении интерфейса класс должен реализовать все его абстрактные методы и свойства. При реализации функций и свойств перед ними ставится ключевое слово override."
          },
          {
            "type": "text",
            "content": "Так, класс Car применяет интерфейс Movable. Так как интерфейс содержит абстрактный метод move(), то класс Car обязательно должен его реализовать. То же самое касается класса Aircraft."
          },
          {
            "type": "text",
            "content": "Далее мы можем вызвать реализованный метод move как любую другую функцию класса:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val car = Car()\n    val aircraft = Aircraft()\n    car.move()\n    aircraft.move()\n}"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Едем на машине\nЛетим на самолете"
          },
          {
            "type": "text",
            "content": "И реализация интерфейса также означает, что мы можем рассматривать объекты классом Car и Aircraft как объекты Movable. И тут в дело вступает полиморфизм:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val car = Car()\n    val aircraft = Aircraft()\n    travel(car)         // Едем на машине\n    travel(aircraft)    // Летим на самолете\n}\n \nfun travel(obj: Movable) = obj.move()\n \ninterface Movable{\n    fun move()\n}\nclass Car : Movable{\n    override fun move(){\n        println(\"Едем на машине\")\n    }\n}\nclass Aircraft : Movable{\n    override fun move(){\n        println(\"Летим на самолете\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае функция travel (условная функция путешествия на транспорте) в качестве параметра получает объект Movable. Это может быть машина, и самолет, и любой другой объект, класс которого реализует интерфейс Movable"
          },
          {
            "type": "text",
            "content": "Также стоит отметить, что мы можем напрямую определить объекты типа интерфейса, но для их создания будут применяться конструкторы классов, которые реализуют интерфейс:"
          },
          {
            "type": "code",
            "content": "val car : Movable = Car()\nval aircraft : Movable = Aircraft()"
          },
          {
            "type": "subtitle",
            "content": "\nМножественная реализация интерфейсов"
          },
          {
            "type": "text",
            "content": "Мы не можем наследовать один класс от нескольких классов, зато класс может реализовать множество интерфейсов. \nНапример, у нас есть два интерфейса:"
          },
          {
            "type": "code",
            "content": "interface Worker{\n    fun work()\n}\ninterface Student{\n    fun study()\n}"
          },
          {
            "type": "text",
            "content": "Интерфейс Worker представляет работающего, а интерфейс Student - учащегося. А что если нам надо определить сущность работающего студента? \nВ этом случае мы можем реализовать в классе оба этих интерфейса:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val tom = WorkingStudent(\"Tom\")\n    work(tom)   // Tom работает\n    study(tom)  // Tom учится\n}\nfun work(worker:Worker) = worker.work()\nfun study(student:Student) = student.study()\n \ninterface Worker{\n    fun work()\n}\ninterface Student{\n    fun study()\n}\nclass WorkingStudent(val name:String) : Worker, Student{\n    override fun work() = println(\"$name работает\")\n    override fun study() = println(\"$name учится\")\n}"
          },
          {
            "type": "text",
            "content": "Класс WorkingStudent реализует оба интерфейса - Worker и Student. Все реализуемые интерфейсы передаются после двоеточия через запятую."
          },
          {
            "type": "subtitle",
            "content": "\nРеализация методов по умолчанию."
          },
          {
            "type": "text",
            "content": "Интерфейс может также определять реализацию по умолчанию для своих методов. \nВ свою очередь, класс, который реализует этот интерфейс, может принять эти методы как есть, а может и переопределить их. Например:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val car = Car()\n    val aircraft = Aircraft()\n \n    car.move()  // Едем на машине\n    car.stop()  // Останавливаемся...\n \n    aircraft.move() // Летим на самолете\n    aircraft.stop() // Приземляемся...\n}\ninterface Movable{\n    fun move()      // определение функции без реализации\n    fun stop() {     // определение функции с реализацией по умолчанию\n        println(\"Останавливаемся...\")\n    }\n}\nclass Car : Movable{\n    override fun move(){\n        println(\"Едем на машине\")\n    }\n}\nclass Aircraft : Movable{\n    override fun move(){\n        println(\"Летим на самолете\")\n    }\n    override fun stop() = println(\"Приземляемся...\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь в интерфейсе Movable для функции stop определена реализация по умолчанию. Класс Car не изменяет ее. А класс Aircraft переопределяет эту функцию."
          },
          {
            "type": "subtitle",
            "content": "\nРеализация свойств"
          },
          {
            "type": "text",
            "content": "Интерфейс может определять свойства - таким свойствам в интерфейсе им не присваиваются значения. Класс же, который реализует интерфейс, также обязан реализовать эти свойства. Например:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val car = Car()\n    val aircraft = Aircraft()\n \n    car.move()          // Едем на машине со скоростью 60 км/ч\n    aircraft.move()     // Летим на самолете со скоростью 600 км/ч\n}\ninterface Movable{\n    var speed: Int  // объявление свойства\n    fun move()      // определение функции без реализации\n}\nclass Car : Movable{\n    override var speed = 60\n    override fun move() {\n        println(\"Едем на машине со скоростью $speed км/ч\")\n    }\n}\nclass Aircraft : Movable{\n    override var speed = 600\n    override fun move(){\n        println(\"Летим на самолете со скоростью $speed км/ч\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае в интерфейсе Movable определено свойство speed. Здесь реализация свойства в классах заключается в установке для него начального значения."
          },
          {
            "type": "subtitle",
            "content": "\nУстановка свойств через конструктор"
          },
          {
            "type": "text",
            "content": "Стоит отметить, что реализуемые свойства интерфейса могут устанавливаться через конструктор. Иногда это единственное место, где можно получить значения для свойств. Например:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val tesla: Car = Car(\"Tesla\", \"2345SDG\")\n    println(tesla.model)    // Tesla\n    println(tesla.number)   // 2345SDG\n \n    tesla.move()    // Едем на машине со скоростью 60 км/ч\n}\ninterface Movable{\n    var speed: Int  // объявление свойства\n    val model: String\n    val number: String\n    fun move()      // определение функции без реализации\n}\n// в первичном конструкторе реализуем свойства интерфейса\nclass Car(override val model: String, override var number: String) : Movable{\n    override var speed = 60\n    override fun move() {\n        println(\"Едем на машине со скоростью $speed км/ч\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь интерфейс Movable также определяет свойства model (модель) и number (номер транспортного средства). Но эти характеристики различаются для каждой конкретной машины, соответственно их предпочтительнее устанавливать в конструкторе. В примере выше они устанавливаются в первичном конструкторе класса Car."
          },
          {
            "type": "subtitle",
            "content": "\nПравила переопределения"
          },
          {
            "type": "text",
            "content": "В Kotlin мы можем одновременно реализовать интерфейсы, которые определяют функцию с одним и тем же именем. \nТо же самое касается ситуации, когда класс одновременно реализует интерфейс и наследует класс, которые имеют одноименную функцию. \nВ программировании подобная проблема известна как diamond problem или проблема \"ромба\"/\"ромбовидного наследования\". В этом случае класс, реализующий интерфейсы, может определить одну функцию для всех реализаций:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val player = MediaPlayer()\n    player.play()   // Play audio and video\n}\ninterface  VideoPlayable {\n    fun play()\n}\ninterface AudioPlayable {\n    fun play()\n}\n \nclass MediaPlayer : VideoPlayable, AudioPlayable {\n    // Функция play для обоих интерфейсов\n    override fun play() = println(\"Play audio and video\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь интерфейсы VideoPlayable и  AudioPlayable определяют функцию play. В этом случае класс MediaPlayer, который применяет оба интерфейса, обязательно должен определить функцию с тем же именем, то есть play."
          },
          {
            "type": "subtitle",
            "content": "\nВызов реализации из интерфейса"
          },
          {
            "type": "text",
            "content": "Иногда может быть необходимо использовать функцию из интерфейса с реализацией по умолчанию, но при этом добавить к ней еще какой-то функционал. \nВ этом случае нет смысла дублировать в классе реализацию по умолчанию. И мы можем обратиться к реализации из интерфейса с помощью конструкции super<интерфейс>.имя_функции:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val player = MediaPlayer()\n    player.play() \n}\ninterface  VideoPlayable {\n    fun play() = println(\"Play video\")\n}\ninterface AudioPlayable {\n    fun play() = println(\"Play audio\")\n}\n \nclass MediaPlayer : VideoPlayable, AudioPlayable {\n    // Функцию play обязательно надо переопределить\n    override fun play() {\n        println(\"Start playing\")\n        super<VideoPlayable>.play() // вызываем VideoPlayable.play()\n        super<AudioPlayable>.play() // вызываем AudioPlayable.play()\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае интерфейсы VideoPlayable и AudioPlayable определяют для функции play реализацию по умолчанию, а в классе MediaPlayer вызывается эта реализация."
          }
        ]
      },
      {
        "id": 10,
        "title": "Вложенные и внутренние классы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Вложенные и внутренние классы и интерфейсы"
          },
          {
            "type": "subtitle",
            "content": "\nВложенные классы"
          },
          {
            "type": "text",
            "content": "В Kotlin одни классы могут быть определены в других классах. Такие классы называют вложенными классами или nested classes. Они обычно выполняют какую-то вспомогательную роль, а определение их внутри класса или интерфейсапозволяет разместить их как можно ближе к тому месту, где они непосредственно используются."
          },
          {
            "type": "text",
            "content": "Например, в следующем случае определяется вложенный класс:"
          },
          {
            "type": "code",
            "content": "class Person{\n    class Account(val username: String, val password: String){\n \n        fun showDetails(){\n            println(\"UserName: $username  Password: $password\")\n        }\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае класс Account является вложенным, а класс Person - внешним."
          },
          {
            "type": "text",
            "content": "По умолчанию вложенные классы имеют модификатор видимости public, то есть они видимы в любой части программы. Но для обращения к вложенному классу надо использовать имя внешнего класса. \nНапример, создание объекта вложенного класса:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val userAcc = Person.Account(\"qwerty\", \"123456\");\n    userAcc.showDetails()\n}"
          },
          {
            "type": "text",
            "content": "Если необходимо ограничить область применения вложенного класса только внешним классом, то следует определить вложенный класс с модификатором private:"
          },
          {
            "type": "code",
            "content": "class Person(username: String, password: String){\n \n    private val account: Account = Account(username, password)\n \n    private class Account(val username: String, val password: String)\n \n    fun showAccountDetails(){\n        println(\"UserName: ${account.username}  Password: $account.password\")\n    }\n}\nfun main() {\n \n    val tom = Person(\"qwerty\", \"123456\");\n    tom.showAccountDetails()\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВложенные интерфейсы"
          },
          {
            "type": "text",
            "content": "Классы также могут содержать вложенные интерфейсы. Кроме того, интерфейсы тоже могут содержать вложенные классы и интерфейсы:"
          },
          {
            "type": "code",
            "content": "interface SomeInterface {\n    class NestedClass\n    interface NestedInterface\n}\n \nclass SomeClass {\n    class NestedClass\n    interface NestedInterface\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВнутренние (inner) классы"
          },
          {
            "type": "text",
            "content": "Стоит учитывать, что вложенный (nested) класс по умолчанию не имеет доступа к свойствам и функциям внешнего класса. \nНапример, в следующем случае при попытке обратиться к свойству внешнего класса мы получим ошибку:"
          },
          {
            "type": "code",
            "content": "class BankAccount(private var sum: Int){\n     \n    fun display(){\n        println(\"sum = $sum\")\n    }\n \n    class Transaction{\n        fun pay(s: Int){\n            sum -= s\n            display()\n        }\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае у нас определен класс банковского счета BankAccount, который определяет свойство sum - сумма на счете и функцию display() для вывода информации о счете."
          },
          {
            "type": "text",
            "content": "Кроме того, в классе BankAccount определен вложенный класс Transaction, который представляет операцию по счету. \nВ данном случае класс Transaction определяет функцию pay() для оплаты со счета. \nОднако в нем мы не можем обратиться в свойствам и функциям внешнего класса BankAccount."
          },
          {
            "type": "text",
            "content": "Чтобы вложенный класс мог иметь доступ к свойствам и функциям внешнего класса, необходимо определить вложенный класс с ключевым словом inner. \nТакой класс еще называют внутренним классом (inner class), чтобы отличать от обычных вложенных классов. Например:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val acc = BankAccount(3400);\n    acc.Transaction().pay(2500)\n}\nclass BankAccount(private var sum: Int){\n \n    fun display(){\n        println(\"sum = $sum\")\n    }\n \n    inner class Transaction{\n        fun pay(s: Int){\n            sum -= s\n            display()\n        }\n    }\n}"
          },
          {
            "type": "text",
            "content": "Теперь класс Transaction определен с ключевым словом inner, поэтому имеет полный доступ к свойствам и функциям внешнего класса BankAccount. \nНо теперь если мы хотим использовать объект подобного вложенного класса, то необходимо создать объект внешнего класса:"
          },
          {
            "type": "code",
            "content": "val acc = BankAccount(3400);\n    acc.Transaction().pay(2500)"
          },
          {
            "type": "subtitle",
            "content": "\nСовпадение имен"
          },
          {
            "type": "text",
            "content": "Но что если свойства и функции внутреннего класса называются также, как и свойства и функции внешнего класса? \nВ этом случае внутренний класс может обратиться к свойствам и функциям внешнего через конструкцию this@название_класса.имя_свойства_или_функции:"
          },
          {
            "type": "code",
            "content": "class A{\n    private val n: Int = 1\n    inner class B{\n        private val n: Int = 1\n        fun action(){\n            println(n)          // n из класса B\n            println(this.n)     // n из класса B\n            println(this@B.n)   // n из класса B\n            println(this@A.n)   // n из класса A\n        }\n    }\n}"
          },
          {
            "type": "text",
            "content": "Например, перепишем случай выше с классами Account и Transaction следующим образом:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val acc = BankAccount(3400);\n    acc.Transaction(2400).pay()\n}\nclass BankAccount(private var sum: Int){\n \n    fun display(){\n        println(\"sum = $sum\")\n    }\n \n    inner class Transaction(private var sum: Int){\n        fun pay(){\n            this@BankAccount.sum -= this@Transaction.sum\n            display()\n        }\n    }\n}"
          }
        ]
      },
      {
        "id": 11,
        "title": "Data-классы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Data-классы"
          },
          {
            "type": "text",
            "content": "Иногда классы бывают необходимы только для хранения некоторых данных. В Kotlin такие классы называются data-классы. Они определяются с модификатором data:"
          },
          {
            "type": "code",
            "content": "data class Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "При компиляции такого класса компилятор автоматически добавляет в класс функции с определенной реализацией, которая учитывает свойства класса, которые определены в первичном конструкторе:"
          },
          {
            "type": "text",
            "content": "\t• equals(): сравнивает два объекта на равенство"
          },
          {
            "type": "text",
            "content": "\t• hashCode(): возвращает хеш-код объекта"
          },
          {
            "type": "text",
            "content": "\t• toString(): возвращает строковое представление объекта"
          },
          {
            "type": "text",
            "content": "\t• copy(): копирует данные объекта в другой объект"
          },
          {
            "type": "text",
            "content": "Например, возьмем функцию toString(), которая возвращает строковое представление объекта:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val alice: Person = Person(\"Alice\", 24)\n    println(alice.toString())\n}\n \nclass Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "Результатом программы будет следующий вывод:"
          },
          {
            "type": "code",
            "content": "Person@2a18f23c"
          },
          {
            "type": "text",
            "content": "По умолчанию строковое представление объекта нам практически ни о чем не говорит. Как правило, данная функция предназначена для вывода состояния объекта, но для этого ее надо переопределять. \nОднако теперь добавим модификатор data к определению класса:"
          },
          {
            "type": "code",
            "content": "data class Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "И результат будет отличаться:"
          },
          {
            "type": "code",
            "content": "Person(name=Alice, age=24)"
          },
          {
            "type": "text",
            "content": "То есть мы можем увидить, какие данные хранятся в объекте, какие они имеют значения. То же самое касается всех остальных функций. \nТаким образом, в случае с data-классами мы имеем готовую реализацию для этих функций. Их не надо вручную переопределять. Но вполне возможно нас может не устраивать эта реализация, тогда мы можем определить свою:"
          },
          {
            "type": "code",
            "content": "data class Person(val name: String, val age: Int){\n    override fun toString(): String {\n        return \"Name: $name  Age: $age\"\n    }\n}"
          },
          {
            "type": "text",
            "content": "В этом случае для функции toString() компилятор не будет определять реализацию."
          },
          {
            "type": "text",
            "content": "Другим показательным примером является копирование данных:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val alice: Person = Person(\"Alice\", 24)\n    val kate = alice.copy(name = \"Kate\")\n    println(alice.toString())   // Person(name=Alice, age=24)\n    println(kate.toString())    // Person(name=Kate, age=24)\n}\n \ndata class Person(var name: String, var age: Int)"
          },
          {
            "type": "text",
            "content": "Опять же компилятор генерирует функцию копирования по умолчанию, которую мы можем использовать. \nЕсли мы хотим, чтобы некоторые данные у объкта отличались, то мы их можем указать в функции copy в виде именованных арументов, как в случае со свойством name в примере выше."
          },
          {
            "type": "text",
            "content": "При этом чтобы класс определить как data-класс, он должен соответствовать ряду условий:"
          },
          {
            "type": "text",
            "content": "\t• Первичный конструктор должен иметь как минимум один параметр"
          },
          {
            "type": "text",
            "content": "\t• Все параметры первичного конструктора должны предваряться ключевыми словами val или var, то есть определять свойства."
          },
          {
            "type": "text",
            "content": "\t• Класс не должен определяться с модификаторами open, abstract, sealed или inner."
          },
          {
            "type": "text",
            "content": "Также стоит отметить, что несмотря на то, что мы можем определять свойства в первичном конструкторе и через val, и через var, например:"
          },
          {
            "type": "code",
            "content": "data class Person(var name: String, var age: Int)"
          },
          {
            "type": "text",
            "content": "Но вообще в ряде ситуаций рекомендуется определять свойства через val, то есть делать их неизменяемыми, поскольку на их основании вычисляет хеш-код, который используется в качестве ключа объекта в такой коллекции как HashMap."
          },
          {
            "type": "subtitle",
            "content": "\nДекомпозиция data-классов"
          },
          {
            "type": "text",
            "content": "Kotlin предоставляет для data-классов возможность декомпозиции на переменные:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val alice: Person = Person(\"Alice\", 24)\n \n    val (username, userage) = alice\n    println(\"Name: $username  Age: $userage\") // Name: Alice  Age: 24\n}\n \ndata class Person(var name: String, var age: Int)"
          }
        ]
      },
      {
        "id": 12,
        "title": "Enum классы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Enum классы (перечисления)"
          },
          {
            "type": "text",
            "content": "Enums или перечисления представляют тип данных, который позволяет определить набор логически связанных констант. \nДля определения перечисления применяются ключевые слова enum class. \nНапример, определим перечисление:"
          },
          {
            "type": "code",
            "content": "enum class Day{\n    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}"
          },
          {
            "type": "text",
            "content": "Данное перечисление Day представляет день недели. Внутри перечисления определяются константы. В данном случае это названия семи дней недели. Константы определяются через запятую. Каждая константа фактически представляет объект данного перечисления."
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val day: Day = Day.FRIDAY\n    println(day)            // FRIDAY\n    println(Day.MONDAY)     // MONDAY\n}"
          },
          {
            "type": "text",
            "content": "Классы перечислений как и обычные классы также могут иметь конструктор. Кроме того, для констант перечисления также может вызываться конструктор для их инициализации."
          },
          {
            "type": "code",
            "content": "enum class Day(val value: Int){\n    MONDAY(1), TUESDAY(2), WEDNESDAY(3),\n    THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(100500)\n}\n \nfun main() {\n \n    val day: Day = Day.FRIDAY\n    println(day.value)        // 5\n    println(Day.MONDAY.value) // 1\n}"
          },
          {
            "type": "text",
            "content": "В примере выше у класса перечисления через конструктор определяется свойство value. Соответственно при определении констант перечисления необходимо каждую из этих констант инициализировать, передав значение для свойства value."
          },
          {
            "type": "text",
            "content": "При этом перечисления - это не просто список значений. Они могут определять также свойства и функции. Но если класс перечисления содержит свойства или функции, то константы должны быть отделены точкой с запятой."
          },
          {
            "type": "code",
            "content": "enum class Day(val value: Int){\n    MONDAY(1), TUESDAY(2), WEDNESDAY(3),\n    THURSDAY(4), FRIDAY(5), SATURDAY(6),\n    SUNDAY(7);\n    fun getDuration(day: Day): Int{\n        return value - day.value;\n    }\n}\n \nfun main() {\n \n    val day1: Day = Day.FRIDAY\n    val day2: Day = Day.MONDAY\n    println(day1.getDuration(day2))        // 4\n}"
          },
          {
            "type": "text",
            "content": "В данном случае в перечислении определена функция getDuration(), которая вычисляет разницу в днях между двумя днями недели."
          },
          {
            "type": "subtitle",
            "content": "\nВстроенные свойства и вспомогательные методы"
          },
          {
            "type": "text",
            "content": "Все перечисления обладают двумя встроенными свойствами:"
          },
          {
            "type": "text",
            "content": "\t• name: возвращает название константы в виде строки"
          },
          {
            "type": "text",
            "content": "\t• ordinal: возвращает порядковый номер константы"
          },
          {
            "type": "code",
            "content": "enum class Day(val value: Int){\n    MONDAY(1), TUESDAY(2), WEDNESDAY(3),\n    THURSDAY(4), FRIDAY(5), SATURDAY(6),\n    SUNDAY(7)\n}\n \nfun main() {\n \n    val day1: Day = Day.FRIDAY\n    println(day1.name)        // FRIDAY\n    println(day1.ordinal)     // 4\n}"
          },
          {
            "type": "text",
            "content": "Кроме того, в Kotlin нам доступны вспомогательные функции:"
          },
          {
            "type": "text",
            "content": "\t• valueOf(value: String): возвращает объект перечисления по названию константы"
          },
          {
            "type": "text",
            "content": "\t• values(): возвращает массив констант текущего перечисления"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    for(day in Day.values())\n        println(day)\n \n    println(Day.valueOf(\"FRIDAY\"))\n}"
          },
          {
            "type": "subtitle",
            "content": "\nАнонимные классы и реализация интерфейсов"
          },
          {
            "type": "text",
            "content": "Константы перечисления могут определять анонимные классы, которые могут иметь собственные методы и свойства или реализовать абстрактные методы класса перечисления:"
          },
          {
            "type": "code",
            "content": "enum class DayTime{\n    DAY{\n        override val startHour = 6\n        override val endHour = 21\n        override fun printName(){\n            println(\"День\")\n        }\n    },\n    NIGHT{\n        override val startHour = 22\n        override val endHour = 5\n        override fun printName(){\n            println(\"Ночь\")\n        }\n    };\n    abstract fun printName()\n    abstract val startHour: Int\n    abstract val endHour: Int\n}\n \nfun main() {\n \n    DayTime.DAY.printName()     // День\n    DayTime.NIGHT.printName()   // Ночь\n \n    println(\"Day from ${DayTime.DAY.startHour} to ${DayTime.DAY.endHour}\")\n \n}"
          },
          {
            "type": "text",
            "content": "В данном случае класс перечисления DayTime определяет абстрактный метод printName() и две переменных - startHour (начальный час) и endHour (конечный час). А константы определяют анонимные классы, которые реализуют эти свойства и функцию."
          },
          {
            "type": "text",
            "content": "Также, классы перечислений могут применять интерфейсы. Для этого для каждой константы определяется анонимный класс, который содержат все реализуемые свойства и функции:"
          },
          {
            "type": "code",
            "content": "interface Printable{\n    fun printName()\n}\nenum class DayTime: Printable{\n    DAY{\n        override fun printName(){\n            println(\"День\")\n        }\n    },\n    NIGHT{\n        override fun printName(){\n            println(\"Ночь\")\n        }\n    }\n}\n \nfun main() {\n \n    DayTime.DAY.printName()     // День\n    DayTime.NIGHT.printName()   // Ночь\n}"
          },
          {
            "type": "subtitle",
            "content": "\nХранение состояния"
          },
          {
            "type": "text",
            "content": "Нередко перечисления применяются для хранения состояния в программе. И в зависимоси от этого состояния мы можем направить действие программы по определенному пути. \nНапример, определим перечисление, которое представляет арифметические операции, и функцию, которая в зависимости от переданной операции выполняет то или иное действие:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    println(operate(5, 6, Operation.ADD))         // 11\n    println(operate(5, 6, Operation.SUBTRACT))   // -1\n    println(operate(5, 6, Operation.MULTIPLY))   // 30\n}\nenum class Operation{\n \n    ADD, SUBTRACT, MULTIPLY\n}\nfun operate(n1: Int, n2: Int, op: Operation): Int{\n \n    when(op){\n        Operation.ADD -> return n1 + n2\n        Operation.SUBTRACT -> return n1 - n2\n        Operation.MULTIPLY -> return n1 *n2\n    }\n}"
          },
          {
            "type": "text",
            "content": "Функция operate() принимает два числа - операнды операции и тип операции в виде перечисления Operation. И в зависимоси от значения перечисления возвращает либо сумму, либо разность, либо произведение двух чисел."
          }
        ]
      },
      {
        "id": 13,
        "title": "Делегирование",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Делегирование"
          },
          {
            "type": "text",
            "content": "Делегирование представляет паттерн объектно-ориентированного программирования, который позволяет одному объекту делегировать/перенаправить все запросы другому объекту. \nВ определенной степени делегирование может выступать альтернативой наследованию. И преимуществом Kotlin в данном случае состоит в том, что Kotlin нативно поддерживает данный паттерн, предоставляя необходимый инструментарий."
          },
          {
            "type": "text",
            "content": "Формальный синтаксис:"
          },
          {
            "type": "code",
            "content": "interface Base {\n    fun someFun()\n}\n \nclass BaseImpl() : Base {\n    override fun someFun() { }\n}\n \nclass Derived(someBase: Base) : Base by someBase"
          },
          {
            "type": "text",
            "content": "Есть некоторый интерфейс - Base, который определяет некоторый функционал. Есть его реализация в виде класса Base."
          },
          {
            "type": "text",
            "content": "И есть еще один класс - Derived, который также применяет интерфейс Base. Причем после указания применяемого интерфейса идет ключевое слово by, а после него - объект, которому будут делегироваться вызовы."
          },
          {
            "type": "code",
            "content": "class Derived(someBase: Base) : Base by someBase"
          },
          {
            "type": "text",
            "content": "То есть в данной схеме класс Derived будет делегировать вызовы объекту someBase, который представляет интерфейс Base и передается через первичный конструктор. \nПри этом Derived может не реализовать интерфейс Base или реализовать неполностью - какие-то отдельные свойства и функции."
          },
          {
            "type": "text",
            "content": "Например, рассмотрим следующие классы:"
          },
          {
            "type": "code",
            "content": "interface Messenger{\n    fun send(message: String)\n}\nclass InstantMessenger(val programName: String) : Messenger{\n \n    override fun send(message: String){\n        println(\"Message `$message` has been sent\")\n    }\n}\nclass SmartPhone(val name: String, m: Messenger): Messenger by  m"
          },
          {
            "type": "text",
            "content": "Здесь определен интерфейс Messenger, который представляет условно программу для отправки сообщений. Для условной отправки сообщений определена функция send()."
          },
          {
            "type": "text",
            "content": "Также есть класс InstantMessenger - программа мгновенных сообщений или проще говоря мессенджер, который применяет интерфейс Messenger, реализуя его функцию send()"
          },
          {
            "type": "text",
            "content": "Далее определен класс SmartPhone, который представляет смартфон и также применяет интерфейс Messenger, но не реализует его. Вместо этого он принимает через первичный конструктор объект Messenger и делегирует ему обращение к функции send()."
          },
          {
            "type": "text",
            "content": "Применим классы:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val telegram = InstantMessenger(\"Telegram\")\n    val pixel = SmartPhone(\"Pixel 5\", telegram)\n    pixel.send(\"Hello Kotlin\")\n    pixel.send(\"Learn Kotlin on Metanit.com\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь создан объект pixel, который представляет класс SmartPhone. Поскольку SmartPhone применяет интерфейс Messenger, то мы можем вызвать у объекта pixel функцию send() для отправки условного сообщения. \nОднако сам класс SmartPhone НЕ реализует функцию send - само выполнение этой функции делегируется объекту telegram, который в реальности выполняет отправку сообщения. \nСоответственно при выполнении программы мы увидим следующий консольный вывод:"
          },
          {
            "type": "code",
            "content": "Message `Hello Kotlin` has been sent\nMessage `Learn Kotlin on Metanit.com` has been sent"
          },
          {
            "type": "subtitle",
            "content": "\nМножественное делегирование"
          },
          {
            "type": "text",
            "content": "Подобным образом один  объект может делегировать выполнение различных функций разным объектам. Например:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val telegram = InstantMessenger(\"Telegram\")\n    val photoCamera = PhotoCamera()\n    val pixel = SmartPhone(\"Pixel 5\", telegram, photoCamera)\n    pixel.send(\"Hello Kotlin\")\n    pixel.takePhoto()\n}\n \ninterface Messenger{\n    fun send(message: String)\n}\nclass InstantMessenger(val programName: String) : Messenger{\n    override fun send(message: String) = println(\"Send message: `$message`\")\n}\ninterface PhotoDevice{\n    fun takePhoto()\n}\nclass PhotoCamera: PhotoDevice{\n    override fun takePhoto() = println(\"Take a photo\")\n}\nclass SmartPhone(val name: String, m: Messenger, p: PhotoDevice)\n    : Messenger by  m, PhotoDevice by p"
          },
          {
            "type": "text",
            "content": "Здесь класс SmartPhone также реализует интерфейс PhotoDevice, который предоставляет функцию takePhoto() для съемки фото. Но выполнение этой функции он делегирует параметру p, который представляет интерфейс PhotoDevice и в роли которого выступает объект PhotoCamera."
          },
          {
            "type": "subtitle",
            "content": "\nПереопределение функций"
          },
          {
            "type": "text",
            "content": "Класс может переопределять часть функций интерфейса, в этом случае выполнение этих функций не делегируется. Например:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val telegram = InstantMessenger(\"Telegram\")\n    val pixel = SmartPhone(\"Pixel 5\", telegram)\n    pixel.sendTextMessage()\n    pixel.sendVideoMessage()\n}\n \ninterface Messenger{\n    fun sendTextMessage()\n    fun sendVideoMessage()\n}\nclass InstantMessenger(val programName: String) : Messenger{\n    override fun sendTextMessage() = println(\"Send text message\")\n    override fun sendVideoMessage() = println(\"Send video message\")\n}\nclass SmartPhone(val name: String, m: Messenger) : Messenger by  m{\n    override fun sendTextMessage() = println(\"Send sms\")\n}"
          },
          {
            "type": "text",
            "content": "В данном случае класс SmartPhone реализует функцию sendTextMessage(), поэтому ее выполнение не делегируется. Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Send sms\nSend video message"
          },
          {
            "type": "subtitle",
            "content": "\nДелегирование свойств"
          },
          {
            "type": "text",
            "content": "По аналогии с функциями объект может делегировать обращение к свойствам:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val telegram = InstantMessenger(\"Telegram\")\n    val pixel = SmartPhone(\"Pixel 5\", telegram)\n    println(pixel.programName)  // Telegram\n}\ninterface Messenger{\n    val programName: String\n}\nclass InstantMessenger(override val programName: String) : Messenger\nclass SmartPhone(val name: String, m: Messenger) : Messenger by  m"
          },
          {
            "type": "text",
            "content": "Здесь при интерфейс Messenger определяет свойство programName - название программы отправки. Класс SmartPhone не реализует это свойство, поэтому обращение к этому свойству делегируется объекту m."
          },
          {
            "type": "text",
            "content": "Если бы класс SmartPhone сам реализовал это свойство, то делегирования бы не было:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val telegram = InstantMessenger(\"Telegram\")\n    val pixel = SmartPhone(\"Pixel 5\", telegram)\n    println(pixel.programName)  // Default Messenger\n}\ninterface Messenger{\n    val programName: String\n}\nclass InstantMessenger(override val programName: String) : Messenger\nclass SmartPhone(val name: String, m: Messenger) : Messenger by  m{\n    override val programName = \"Default Messenger\"\n}"
          }
        ]
      },
      {
        "id": 14,
        "title": "Анонимные классы и объекты",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Анонимные классы и объекты"
          },
          {
            "type": "text",
            "content": "Иногда возникает необходимость создать объект некоторого класса, который больше нигде в программе не используется. То есть класс необходим только для создания только одного объекта. В этом случае мы, конечно, можем, как и обычно, определить класс и затем создать объект этого класса. Но Kotlin для таких ситуаций предоставлять возможность определить объект анонимного класса."
          },
          {
            "type": "text",
            "content": "Анонимные классы не используют ключевое слово class для определения. Они не имеют имени, но как и обычные классы могут наследовать другие классы или  применять интерфейсы. Объекты анонимных классов называют анонимыми объктами."
          },
          {
            "type": "text",
            "content": "Для определения анонимного объекта применяется ключевое слово object:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val person = object {\n        val name = \"Tom\"\n        var age = 37\n        fun sayHello(){\n            println(\"Hi, my name is $name\")\n        }\n    }\n    println(\"Name: ${person.name}  Age: ${person.age}\")\n    person.sayHello()\n}"
          },
          {
            "type": "text",
            "content": "После ключевого слова object идет блок кода в фигурных скобках, в которые помещается определение объекта. Ссылка на этот объект присваивается переменной person. Как и в обычном классе, анонимный объект может содержать свойства, функции. И далее по имени переменной person мы можем обращаться к свойствам и функциям этого объекта."
          },
          {
            "type": "text",
            "content": "Если объект определяется вне функции как глобальный объект, то имя объекта указывается после слова object:"
          },
          {
            "type": "code",
            "content": "object person{\n    val name = \"Tom\"\n    var age = 37\n    fun sayHello(){\n        println(\"Hi, my name is $name\")\n    }\n}\n \nfun main() {\n    println(\"Name: ${person.name}  Age: ${person.age}\")\n    person.sayHello()\n}"
          },
          {
            "type": "subtitle",
            "content": "\nНаследование анонимных объектом"
          },
          {
            "type": "text",
            "content": "При наследовании после слова object через двоеточия указывается имя наследуемого класса или его первичный конструктор:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = object : Person(\"Tom\"){\n \n        val company = \"JetBrains\"\n        override fun sayHello(){\n            println(\"Hi, my name is $name. I work in $company\")\n        }\n    }\n \n    tom.sayHello()  // Hi, my name is Tom. I work in JetBrains\n}\nopen class Person(val name: String){\n    open fun sayHello(){\n        println(\"Hi, my name is $name\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь класс анонимного объекта наследует класс Person и переопределяет его функцию sayHello()."
          },
          {
            "type": "subtitle",
            "content": "\nАнонимный объект как аргумент функции"
          },
          {
            "type": "text",
            "content": "Анонимный объект может передаваться в качестве аргумента в вызов функции:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    hello(\n        object : Person(\"Sam\"){\n            val company = \"JetBrains\"\n            override fun sayHello(){\n                println(\"Hi, my name is $name. I work in $company\")\n            }\n    })\n}\nfun hello(person: Person){\n    person.sayHello()\n}\nopen class Person(val name: String){\n    open fun sayHello() = println(\"Hi, my name is $name\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь поскольку класс анонимного объекта наследуется от класса Person, мы можем передавать этот анонимный объект параметру функции, который имеет тип Person."
          },
          {
            "type": "subtitle",
            "content": "\nАнонимный объект как результат функции"
          },
          {
            "type": "text",
            "content": "Функция может возвращать анонимный объект:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val tom = createPerson(\"Tom\", \"JetBrains\")\n    tom.sayHello()\n}\nprivate fun createPerson(_name: String, _company: String) = object{\n    val name = _name\n    val company = _company\n    fun sayHello() = println(\"Hi, my name is $name. I work in $company\")\n}"
          },
          {
            "type": "text",
            "content": "Однако тут есть нюансы. Чтобы мы могли обращаться к свойствам и функциям анонимного объекта, функция, которая возвращает этот объект, должна быть приватной, как в примере выше."
          },
          {
            "type": "text",
            "content": "Если функция имеет модификатор public или private inline, то в этом случае свойства и функции анонимного класса (за исключением унаследованных) недоступны:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val tom = createPerson(\"Tom\", \"JetBrains\")\n    println(tom.name)   // норм - свойство name унаследовано от Person\n    println(tom.company)    // ! Ошибка - свойство недоступно\n}\nprivate inline fun createPerson(_name: String, _comp: String) = object: Person(_name){\n    val company = _comp\n}\n \nopen class Person(val name: String)"
          },
          {
            "type": "text",
            "content": "В данном случае функция createPerson() имеет модификатор private inline, поэтому у анонимного объекта будут доступны только унаследованные свойства и функции от класса Person, но собственные свойства и функции будут не доступны."
          }
        ]
      },
      {
        "id": 15,
        "title": "Companion-объекты",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Companion-объекты"
          },
          {
            "type": "text",
            "content": "Класс в языке Kotlin может содержать так называемые companion-объекты. \nСompanion-объект определяется внутри некоторого класса и позволяет определить свойства и методы, которые будут общими для всех объектов этого класса. \nВ ряде языков программирования есть похожая концепция - статические поля/свойства и методы. \nТо есть companion-объекты определяют свойства и методы классав целом, а не объекта."
          },
          {
            "type": "text",
            "content": "Общий синтаксис опредедения companion-объекта:"
          },
          {
            "type": "code",
            "content": "class ClassName{\n \n    // свойства и методы класса\n    companion object {\n \n        // свойства и методы companion-объекта\n    }\n \n}"
          },
          {
            "type": "text",
            "content": "Например, нам надо подсчитать, сколько было создано объектов определенного класса. Для этого определим следующую программу:"
          },
          {
            "type": "code",
            "content": "class Person(val name: String){\n   \n    init{\n        counter++\n    }\n    companion object {\n        var counter = 0\n    }\n}\nfun main (){\n    println(Person.counter) // 0\n    Person(\"Tom\")\n    println(Person.counter) // 1\n    Person(\"Bob\")\n    Person(\"Sam\")\n    println(Person.counter) // 3\n \n}"
          },
          {
            "type": "text",
            "content": "Здесь в классе Person определен следующий companion-объект:"
          },
          {
            "type": "code",
            "content": "companion object {\n    var counter = 0\n}"
          },
          {
            "type": "text",
            "content": "Для его определения применяется ключевое слово companion. Внутри этого объекта определено свойство counter - счетчик, который по умолчанию равен 0."
          },
          {
            "type": "text",
            "content": "В теле класса Person мы можем напрямую обращаться к свойствам и методам companion-объекта. \nВ данном случае при создании объекта в инициализаторе мы увеличиваем этот счетчик на 1:"
          },
          {
            "type": "code",
            "content": "init{\n    counter++\n}"
          },
          {
            "type": "text",
            "content": "То есть при создании каждого объекта счетчик увеличивается на единицу. И поскольку companion-объекты определяют свойства и методы, общие для всех объектов класса, то этот счетчик будет один общий для всех объектов класса Person. И для обращения к нему вне класса применяется имя класса, а не объекта:"
          },
          {
            "type": "code",
            "content": "println(Person.counter) // 0\nPerson(\"Tom\")\nprintln(Person.counter) // 1\nPerson(\"Bob\")\nPerson(\"Sam\")\nprintln(Person.counter) // 3"
          },
          {
            "type": "text",
            "content": "И здесь мы видим, что изначально счетчик равен 0. После создания одного объекта он равен 1, а после создания еще двух объектов - 3."
          },
          {
            "type": "text",
            "content": "Если же мы попробуем обратиться к переменной counter через имя объекта, то мы получим ошибку:"
          },
          {
            "type": "code",
            "content": "val tom = Person(\"Tom\")\nprintln(tom.counter) // Ошибка"
          },
          {
            "type": "text",
            "content": "Теоретически мы, конечно, можем определить и для объектов одноименное свойство. Например:"
          },
          {
            "type": "code",
            "content": "class Person(val name: String){\n   \n    var counter = 22\n    init{\n        Person.counter++\n    }\n    companion object {\n        var counter = 0\n    }\n}\nfun main (){\n    println(Person.counter) // 0\n    val tom = Person(\"Tom\")\n    println(tom.counter) // 22\n    Person(\"Bob\")\n    Person(\"Sam\")\n    println(Person.counter) // 3\n}"
          },
          {
            "type": "text",
            "content": "Здесь в классе Person определено свойство counter, которое по умолчанию равно 22:"
          },
          {
            "type": "code",
            "content": "var counter = 22"
          },
          {
            "type": "text",
            "content": "И для обращения к этому свойству мы можем использовать имя объекта:"
          },
          {
            "type": "code",
            "content": "val tom = Person(\"Tom\")\nprintln(tom.counter) // 22"
          },
          {
            "type": "text",
            "content": "В этом случае, если внутри класса мы хотим обратиться не к этому свойству, а к свойству companion-объекта, то мы также должны указывать имя класса:"
          },
          {
            "type": "code",
            "content": "init{\n    Person.counter++\n}"
          },
          {
            "type": "subtitle",
            "content": "\nСтатические методы"
          },
          {
            "type": "text",
            "content": "Companion-объекты также могут определять методы, общие для всего класса и для обращения к которым также используется имя класса, а не объекта. \nНапример, в примерах выше у нас определенно есть проблема с целостностью данных, так как мы можем из внешнего кода присвоить счетчику любое значение:"
          },
          {
            "type": "code",
            "content": "Person.counter = -100500"
          },
          {
            "type": "text",
            "content": "Естественно это нежелательная ситуация. Поэтому опосредуем доступ к свойству counter:"
          },
          {
            "type": "code",
            "content": "class Person(val name: String){\n   \n    init{\n        counter++\n    }\n    companion object {\n        private var counter = 0\n        fun printCounter() = println(counter)\n    }\n}\nfun main (){\n    Person.printCounter() // 0\n    Person(\"Tom\")\n    Person.printCounter() // 22\n    Person(\"Bob\")\n    Person(\"Sam\")\n    Person.printCounter() // 3\n}"
          },
          {
            "type": "text",
            "content": "Итак, переменная counter теперь приватная, она недоступна вне своего класса. Однако внутри класса мы по прежнему можем к ней обращаться."
          },
          {
            "type": "text",
            "content": "А для того, чтобы внешний код также мог получить ее значение, в companion-объекте определен метод printCounter:"
          },
          {
            "type": "code",
            "content": "fun printCounter() = println(counter)"
          },
          {
            "type": "text",
            "content": "Для доступа к этому методу применяется имя класса:"
          },
          {
            "type": "code",
            "content": "Person.printCounter()"
          },
          {
            "type": "subtitle",
            "content": "\nНаследование"
          },
          {
            "type": "text",
            "content": "Методы и свойства companion-объекта не наследуются, поэтому для обращения к ним применяется имя базового класса, в котором определен companion-объект:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String){\n   \n    init{\n        counter++\n    }\n    companion object {\n        private var counter = 0\n        fun printCounter() = println(counter)\n    }\n}\nclass Employee(name:String):Person(name)\n \nfun main (){\n    Person.printCounter() // 0\n    Employee(\"Tom\")\n    Person.printCounter() // 1\n    // Employee.printCounter() ! Так нельзя - error: unresolved reference: printCounter\n}"
          }
        ]
      }
    ]
  },
  {
    "chapterId": 5,
    "chapterTitle": "Обобщения",
    "articles": [
      {
        "id": 1,
        "title": "Обобщенные классы и функции",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Обобщенные классы и функции"
          },
          {
            "type": "text",
            "content": "Generics или обобщения представляют технику, посредством которой методы и классы могут использовать объекты, типы которых на момент определения классов и функций неизвестны. Обобщения позволяют определять шаблоны, в которые можно подставлять различные типы."
          },
          {
            "type": "subtitle",
            "content": "\nОбобщенные типы"
          },
          {
            "type": "text",
            "content": "Обобщенные типы (generic types) представляют типы, в которых типы объектов параметризированы. Что это значит? \nРассмотрим следующий класс:"
          },
          {
            "type": "code",
            "content": "class Person<T>(val id: T, val name: String)"
          },
          {
            "type": "text",
            "content": "Класс Person использует параметр T. Параметры указываются после имени класса в угловых скобках. Данный параметр будет представлять некоторый тип данных, который на момент определения класса неизвестен."
          },
          {
            "type": "text",
            "content": "В первичном конструкторе определяется свойство id, которое представляет идентификатор. Оно представляет тип, который передается через параметр T. На момент определения класса Person мы не знаем, что это будет за тип."
          },
          {
            "type": "text",
            "content": "Само название параметра произвольное (если оно не совпадает с ключевыми словами). Но нередко используется T как сокращение от слова type."
          },
          {
            "type": "text",
            "content": "При использовании типа Person необходимо его типизировать определенным типом, то есть указать, какой тип будет передаваться через параметр T:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom: Person<Int> = Person(367, \"Tom\")\n    val bob: Person<String> = Person(\"A65\", \"Bob\")\n \n    println(\"${tom.id} - ${tom.name}\")\n    println(\"${bob.id} - ${bob.name}\")\n}\n \nclass Person<T>(val id: T, val name: String)"
          },
          {
            "type": "text",
            "content": "Для типизации объекта после названия типа в угловых скобках указывается конкретный тип:"
          },
          {
            "type": "code",
            "content": "val tom: Person<Int>"
          },
          {
            "type": "text",
            "content": "В данном случае мы говорим, что параметр T фактически будет представлять тип Int. Поэтому в конструктор объекта Person для свойства id необходимо передать числовое значение Int:"
          },
          {
            "type": "code",
            "content": "Person(367, \"Tom\")"
          },
          {
            "type": "text",
            "content": "Второй объект типизируется типом String, поэтому в конструкторе для свойства id передается строка:"
          },
          {
            "type": "code",
            "content": "val bob: Person<String> = Person(\"A65\", \"Bob\")"
          },
          {
            "type": "text",
            "content": "Если конструктор использует параметр T, то в принципе мы можем не указывать, каким типом типизируется объект - данный тип будет выводиться из типа параметра конструктора:"
          },
          {
            "type": "code",
            "content": "val tom = Person(367, \"Tom\")\nval bob = Person(\"A65\", \"Bob\")"
          },
          {
            "type": "text",
            "content": "При этом параметры типа могут широко применяться внутри класса, не только при определении свойств, но и в функциях:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"qwrtf2\", \"Tom\")\n    tom.checkId(\"qwrtf2\")   // The same\n    tom.checkId(\"q34tt\")    // Different\n}\n \nclass Person<T>(val id: T, val name: String){\n \n    fun checkId(_id: T){\n        if(id == _id){\n            println(\"The same\")\n        }\n        else{\n            println(\"Different\")\n        }\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь класс Person определяет функцию checkId(), которая проверяет, равен ли id значению параметра _id. При этом параметр _id имеет тип T - то есть он будет представлять тот же тип, что и свойство id."
          },
          {
            "type": "text",
            "content": "Стоит отметить, что generic-типы широко используются в Kotlin. Самый показательный пример, который представлен классом - Array<T>. Параметр класса определяет, элементы какого типа массив будет хранить:"
          },
          {
            "type": "code",
            "content": "val people: Array<String> = arrayOf(\"Tom\", \"Bob\", \"Sam\")\nval numbers: Array<Int> = arrayOf(1, 2, 3, 4)"
          },
          {
            "type": "subtitle",
            "content": "\nПрименение нескольких параметров"
          },
          {
            "type": "text",
            "content": "Можно одновременно использовать несколько параметров:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    var word1: Word<String, String> = Word(\"one\", \"один\")\n    var word2: Word<String, Int> = Word(\"two\", 2)\n \n    println(\"${word1.source} - ${word1.target}\")    // one - один\n    println(\"${word2.source} - ${word2.target}\")    // two - 2\n}\n \nclass Word<K, V>(val source: K, var target: V)"
          },
          {
            "type": "text",
            "content": "В данном случае класс Word применяет два параметра - K и V. При создании объекта Word эти параметры могут представлять один и тот же тип, а могут представлять и разные типы."
          },
          {
            "type": "subtitle",
            "content": "\nОбобщенные функции"
          },
          {
            "type": "text",
            "content": "Функции, как и классы, могут быть обобщенными."
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    display(\"Hello Kotlin\")\n    display(1234)\n    display(true)\n}\nfun <T> display(obj: T){\n    println(obj)\n}"
          },
          {
            "type": "text",
            "content": "Функция display() параметризирована параметром T. Параметр также указывается в угловых скобках после слова fun и перед названием функции. Функция принимает один параметр типа T и выводит его значение на консоль. И при использовании функции мы можем передавать в нее данные любых типов."
          },
          {
            "type": "text",
            "content": "Другой более практический пример - определим функцию, которая будет возвращать наибольший массив:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val arr1 = getBiggest(arrayOf(1,2,3,4), arrayOf(3, 4, 5, 6, 7, 7))\n    arr1.forEach { item -> print(\"$item \") }    // 3  4  5  6  7  7\n \n    println()\n     \n    val arr2 = getBiggest(arrayOf(\"Tom\", \"Sam\", \"Bob\"), arrayOf(\"Kate\", \"Alice\"))\n    arr2.forEach { item -> print(\"$item \") }    // Tom  Sam  Bob\n}\n \nfun <T> getBiggest(args1: Array<T>, args2: Array<T>): Array<T>{\n    if(args1.size > args2.size) return args1\n    return  args2\n}"
          },
          {
            "type": "text",
            "content": "Здесь функция getBiggest() в качестве параметров принимает два массива. При этом мы точно не значем, объекты какого типа эти массивы будут содержать. Однако оба массива типизированы параметром T, что гарантирует, что оба массива будут хранить объекты одного и того же типа. Внутри функции сравниваем размер массивов с помощью их свойств size и возвращаем наибольший массив."
          }
          ]
          },
          {
            "id": 2,
            "title": "Ограничения обобщений",
            "blocks": [
              {
                "type": "subtitle",
                "content": "Ограничения обобщений"
              },
              {
                "type": "text",
                "content": "Ограничения обобщений (generic constraints) ограничивают набор типов, которые могут передаваться вместо параметра в обобщениях."
              },
              {
                "type": "text",
                "content": "Например, мы хотим определить универсальную функцию для сравнения двух объектов и возвращать из функции наибольший объект. На первый взгляд мы можем просто определить обобщенную функцию:"
              },
              {
                "type": "code",
                "content": "fun <T> getBiggest(a: T, b: T): T{\n    if(a > b) return a   // ! Ошибка\n    return b\n}"
              },
              {
                "type": "text",
                "content": "Но компилятор не скомпилирует эту функцию, потому что вместо параметра типа T могут передаваться самые различные типы, в том числе такие, которые не поддерживают операцию сравнения."
              },
              {
                "type": "text",
                "content": "Однако все типы, которые по умолчанию поддерживают эту операцию сравнения, применяют интерфейс Comparable. \nТо есть нам надо, чтобы два параметра представляли один и тот же тип, который реализует тип Comparable. И в этом случае можно определить одну обобщенную функцию, которая будет ограниченна типом Comparable:"
              },
              {
                "type": "code",
                "content": "fun main() {\n \n    val result1 = getBiggest(1, 2)\n    println(result1)\n    val result2 = getBiggest(\"Tom\", \"Sam\")\n    println(result2)\n \n}\nfun <T: Comparable<T>> getBiggest(a: T, b: T): T{\n    return if(a > b) a\n    else b\n}"
              },
              {
                "type": "text",
                "content": "Ограничение указывается после названия параметра через двоеточие: \n<T: Comparable<T>> - то есть в данном случае тип T ограничен типом Comparable<T>, иначе говоря должен представлять тип Comparable<T>. Причем тип Comparable сам является обобщенным."
              },
              {
                "type": "text",
                "content": "Стоит отметить, что по умолчанию ко всем параметрам типа также применяется ограничение в виде типа Any?. То есть определение параметра типа <T> фактически аналогично определению <T: Any?>"
              },
              {
                "type": "text",
                "content": "Подобным образом мы можем использовать в качестве ограничений собственные типы. Например, нам надо определить функцию для условной отправки сообщения:"
              },
              {
                "type": "code",
                "content": "fun<T:Message> send(message: T){\n    println(message.text)\n}\n \ninterface Message{\n    val text: String\n}\nclass EmailMessage(override val text: String): Message\nclass SmsMessage(override val text: String): Message"
              },
              {
                "type": "text",
                "content": "Здесь определен интерфейс Message, который имеет одно свойство - text и представляет условное сообщение. \nИ также есть два класса, которые реализуют этот интерфейс: EmailMessageиSmsMessage."
              },
              {
                "type": "text",
                "content": "Функция send() использует ограничение <T:Message>, то есть она принимает объект некоторого типа, который должен реализовать интерфейс Message."
              },
              {
                "type": "text",
                "content": "Далее мы можем вызвать эту функцию, передав ей соответствующий объект:"
              },
              {
                "type": "code",
                "content": "fun main() {\n    val email1 = EmailMessage(\"Hello METANIT.COM\")\n    send(email1)\n    val sms1 = SmsMessage(\"Привет, ты спишь?\")\n    send(sms1)\n}"
              },
              {
                "type": "text",
                "content": "Здесь в обоих вызовах функция send() ожидает объект Message. Однако мы можем указать точный тип, используемый функцией:"
              },
              {
                "type": "code",
                "content": "fun main() {\n    val email1 = EmailMessage(\"Hello METANIT.COM\")\n    send<EmailMessage>(email1)\n    val sms1 = SmsMessage(\"Привет, ты спишь?\")\n    send<SmsMessage>(sms1)\n}"
              },
              {
                "type": "subtitle",
                "content": "\nУстановка нескольких ограничений"
              },
              {
                "type": "text",
                "content": "В примере выше мы могли передавать в функцию getBiggest() любой объект, который реализует интерфейс Comparable. Но что, если мы хотим, чтобы функция могла сравнивать только числа? \nВсе числовые типы данных наследуются от базового класса Number. И мы можем задать еще одно ограничение - чтобы сравниваемый объект представлял тип Number:"
              },
              {
                "type": "code",
                "content": "fun <T> getBiggest(a: T, b: T): T where T: Comparable<T>, \n                                        T: Number {\n    return if(a > b) a\n    else b\n}"
              },
              {
                "type": "text",
                "content": "Если параметра типа надо установить несколько ограничений, то все они указываются после возвращаемого типа функции после слова where через запятую в форме:"
              },
              {
                "type": "code",
                "content": "параметр_типа: ограничений"
              },
              {
                "type": "text",
                "content": "И в этом случае мы сможем передать в функцию объекты, которые одновременно реализуют интерфейс Comparable и являются наследниками класса Number:"
              },
              {
                "type": "code",
                "content": "fun main() {\n \n    val result1 = getBiggest(1, 2)\n    println(result1)    // 2\n \n    val result2 = getBiggest(1.6, -2.8)\n    println(result2)    // 1.6\n     \n    // val result3 = getBiggest(\"Tom\", \"Sam\")  // ! Ошибка - String не является производным от класса Number\n    // println(result3)\n}"
              },
              {
                "type": "text",
                "content": "Подобным образом мы можем использовать собственные типы в качестве ограничений:"
              },
              {
                "type": "code",
                "content": "fun main() {\n    val email1 = EmailMessage(\"Hello METANIT.COM\")\n    send(email1)\n    val sms1 = SmsMessage(\"Привет, ты спишь?\")\n    send(sms1)\n}\nfun<T> send(message: T) where T: Message, T: Logger{\n    message.log()\n}\n \ninterface Message{ val text: String }\ninterface Logger{ fun log() }\n \nclass EmailMessage(override val text: String): Message, Logger{\n    override fun log() = println(\"Email: $text\")\n}\nclass SmsMessage(override val text: String): Message, Logger{\n    override fun log() = println(\"SMS: $text\")\n}"
              },
              {
                "type": "text",
                "content": "Здесь для функции send() установлено два ограничения: используемый параметр типа T должен представлять одновременно оба интерфейса - Message и Logger."
              },
              {
                "type": "subtitle",
                "content": "\nОграничения в классах"
              },
              {
                "type": "text",
                "content": "Классы, как и функции, могут принимать ограничения обощений. Например, установка одного ограничения:"
              },
              {
                "type": "code",
                "content": "class Messenger<T:Message>(){\n    fun send(mes: T){\n        println(mes.text)\n    }\n}"
              },
              {
                "type": "text",
                "content": "Установка нескольких ограничений:"
              },
              {
                "type": "code",
                "content": "fun main() {\n    val email1 = EmailMessage(\"Hello METANIT.COM\")\n    val outlook = Messenger<EmailMessage>()\n    outlook.send(email1)\n \n    val skype = Messenger<SmsMessage>()\n    val sms1 = SmsMessage(\"Привет, ты спишь?\")\n    skype.send(sms1)\n}\nclass Messenger<T>() where T: Message, T: Logger{\n    fun send(mes: T){\n        mes.log()\n    }\n}\ninterface Message{ val text: String }\ninterface Logger{ fun log() }\n \nclass EmailMessage(override val text: String): Message, Logger{\n    override fun log() = println(\"Email: $text\")\n}\nclass SmsMessage(override val text: String): Message, Logger{\n    override fun log() = println(\"SMS: $text\")\n}"
              },
              {
                "type": "text",
                "content": "Здесь стоит обратить внимание, что поскольку конструктор класса Messenger не принимает параметров типа T, то нам надо явным образом указать, какой именно тип будет использоваться:"
              },
              {
                "type": "code",
                "content": "val outlook = Messenger<EmailMessage>()"
              },
              {
                "type": "text",
                "content": "В качестве альтернативы можно было бы явным образом указать тип переменной:"
              },
              {
                "type": "code",
                "content": "val outlook: Messenger<EmailMessage> = Messenger()"
              }
            ]
          }
        ]
      },
  {
    "chapterId": 6,
    "chapterTitle": "Дополнительные возможности ООП",
    "articles": [
      {
        "id": 1,
        "title": "Обработка исключений",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Обработка исключений"
          },
          {
            "type": "text",
            "content": "Исключение представляет событие, которое возникает при выполнении программы и нарушает ее нормальной ход. \nНапример, при передаче файла по сети может оборваться сетевое подключение, и в результате чего может быть сгенерировано исключение. Если исключение не обработано, то программа падает и прекращает свою работу. Поэтому при возникновении исключений их следует обрабатывать."
          },
          {
            "type": "text",
            "content": "Для обработки исключений применяется конструкция try..catch..finally. \nВ блок try помещаются те действия, которые потенциально могут вызвать исключение (например, передача файла по сети, открытие файла и т.д.). \nБлок catch перехватывает возникшее исключение и обрабатывает его. \nБлок finally выполняет некоторые завершающие действия."
          },
          {
            "type": "code",
            "content": "try {\n    // код, генерирующий исключение\n}\ncatch (e: Exception) {\n    // обработка исключения\n}\nfinally {\n    // постобработка\n}"
          },
          {
            "type": "text",
            "content": "После оператора catch в скобках помещается параметр, который представляет тип исключения. Из этого параметра можно получить информацию о произошедшем исключении."
          },
          {
            "type": "text",
            "content": "Блок finally является необязательным, его можно опустить. Блок catch также может отсутствовать, однако обязательно должен быть блок try и как минимум один из блоков: либо catch, либо finally. \nТакже конструкция может содержать несколько блоков catch для обработки каждого типа исключения, которое может возникнуть."
          },
          {
            "type": "text",
            "content": "Блок catch выполняется, если только возникло исключение. Блок finally выполняется в любом случае, даже если нет исключения."
          },
          {
            "type": "text",
            "content": "Например, при делении на ноль Kotlin генерирует исключение:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n   try{\n        val n1 = 2\n        val n2 = 0\n        val result = n1 / n2\n        println(result)\n   }\n   catch(e: Exception){\n       println(\"Exception\")\n   }\n}"
          },
          {
            "type": "text",
            "content": "Действие, которое может вызвать исключение, то есть операция деления, помещается в блок try. В блоке catch перехватываем исключение. При этом каждое исключение имеет определенный тип. В данном случае используется общий тип исключений - класс Exception."
          },
          {
            "type": "text",
            "content": "Если необходимы какие-то завершающие действия, то можно добавить блок finally (например, если при работе с файлом возникает исключение, то в блоке finally можно прописать закрытие файла):"
          },
          {
            "type": "code",
            "content": "try{\n    val n1 = 2\n    val n2 = 0\n    val result = n1 / n2\n    println(result)\n}\ncatch(e: Exception){\n    println(\"Exception\")\n}\nfinally{\n    println(\"Program has been finished\")\n}"
          },
          {
            "type": "text",
            "content": "В этом случае консольный вывод будет выглядеть следующим образом:"
          },
          {
            "type": "code",
            "content": "Exception\nProgram has been finished"
          },
          {
            "type": "subtitle",
            "content": "\nИнформация об исключении"
          },
          {
            "type": "text",
            "content": "Базовый класс исключений - класс Exception предоставляет ряд свойств, которые позволяют получить различную информацию об исключении:"
          },
          {
            "type": "text",
            "content": "\t• message: сообщение об исключении"
          },
          {
            "type": "text",
            "content": "\t• stackTrace: трассировка стека исключения - набор строк, где было сгенерировано исключение"
          },
          {
            "type": "text",
            "content": "Из функций класса Exception следует выделить функцию printStackTrace(), которая выводит ту информацию, которая обычно отображается при необработанном исключении."
          },
          {
            "type": "text",
            "content": "Применение свойств:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    try{\n        val n1 = 2\n        val n2 = 0\n        val result = n1 / n2\n        println(result)\n    }\n    catch(e: Exception){\n        println(e.message)\n        for(line in e.stackTrace) {\n            println(\"at $line\")\n        }\n    }\n}"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "/ by zero\nat AppKt.main(app.kt:5)\nat AppKt.main(app.kt)"
          },
          {
            "type": "subtitle",
            "content": "\nОбработка нескольких исключений"
          },
          {
            "type": "text",
            "content": "Одна программа, один код может генерировать сразу несколько исключений. Для обработки каждого отдельного типа исключений можно определить отдельный блок catch. \nНапример, при одном исключении мы хотим производить одни действия, при другом - другие."
          },
          {
            "type": "code",
            "content": "try {\n    val nums = arrayOf(1, 2, 3, 4)\n    println(nums[6])\n}\ncatch(e:ArrayIndexOutOfBoundsException){\n    println(\"Out of bound of array\")\n}\ncatch (e: Exception){\n    println(e.message)\n}"
          },
          {
            "type": "text",
            "content": "В данном случае при доступе по недействительному индексу в массиве будет генерироваться исключение типа ArrayIndexOutOfBoundsException. С помощью блока catch(e: ArrayIndexOutOfBoundsException). Если в программе будут другие исключения, которые не представляют тип ArrayIndexOutOfBoundsException, то они будут обрабатываться вторым блоком catch."
          },
          {
            "type": "subtitle",
            "content": "\nОператор throw"
          },
          {
            "type": "text",
            "content": "Возможно, в каких-то ситуациях мы вручную захотим генерировать исключение. Для генерации исключения применяется оператор throw, после которого указывается объект исключения"
          },
          {
            "type": "text",
            "content": "Например, в функции проверки возраста мы можем генерировать исключение, если возраст не укладывается в некоторый диапазон:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val checkedAge1 = checkAge(5)\n    val checkedAge2 = checkAge(-115)\n}\nfun checkAge(age: Int): Int{\n    if(age < 1 || age > 110) throw  Exception(\"Invalid value $age. Age must be greater than 0 and less than 110\")\n    println(\"Age $age is valid\")\n    return age\n}"
          },
          {
            "type": "text",
            "content": "После оператора throw указан объект исключения. Для определения объекта Exception применяется конструктор, который принимает в качестве параметра сообщение об исключении. \nВ данном случае это сообщение о некорректности введенного значения."
          },
          {
            "type": "text",
            "content": "И если при вызове функции checkAge() в нее будет передано число меньше 1 или больше 110, то будет сгенерировано исключение. Так, в данном случае консольный вывод будет следующим:"
          },
          {
            "type": "code",
            "content": "Age 5 is valid\nException in thread \"main\" java.lang.Exception: Invalid value -115. Age must be greater than 0 and less than 110\n\tat AppKt.checkAge(app.kt:7)\n\tat AppKt.main(app.kt:4)\n\tat AppKt.main(app.kt)"
          },
          {
            "type": "text",
            "content": "Но опять же поскольку генерируемое здесь исключение не обаботано, то программа при генерации исключения аварийно завершает работу. Чтобы этого не произошло, мы можем обработать генерируемое исключение:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    try {\n        val checkedAge1 = checkAge(5)\n        val checkedAge2 = checkAge(-115)\n    }\n    catch (e: Exception){\n        println(e.message)\n    }\n}\nfun checkAge(age: Int): Int{\n    if(age < 1 || age > 110) throw  Exception(\"Invalid value $age. Age must be greater than 0 and less than 110\")\n    println(\"Age $age is valid\")\n    return age\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВозвращение значения"
          },
          {
            "type": "text",
            "content": "Конструкция try может возвращать значение. Например:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val checkedAge1 = try { checkAge(5) } catch (e: Exception) { null }\n    val checkedAge2 = try { checkAge(-125) } catch (e: Exception) { null }\n    println(checkedAge1)    // 5\n    println(checkedAge2)    // null\n}\nfun checkAge(age: Int): Int{\n    if(age < 1 || age > 110) throw  Exception(\"Invalid value $age. Age must be greater than 0 and less than 110\")\n    println(\"Age $age is valid\")\n    return age\n}"
          },
          {
            "type": "text",
            "content": "В данном случае переменная checkedAge1 получает результат функцию checkAge(). Если же произойдет исключение, тогда переменная checkedAge1 получает то значение, которое указано в блоке catch, то есть в данном случае значение null."
          },
          {
            "type": "text",
            "content": "При необрабходимости в блок catch можно добавить и другие выражения или возвратить другое значение:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val checkedAge2 = try { checkAge(-125) } catch (e: Exception) { println(e.message); 18 }\n    println(checkedAge2)\n}\nfun checkAge(age: Int): Int{\n    if(age < 1 || age > 110) throw  Exception(\"Invalid value $age. Age must be greater than 0 and less than 110\")\n    println(\"Age $age is valid\")\n    return age\n}"
          },
          {
            "type": "text",
            "content": "В данном случае, если будет сгенерировано исключение, то конструкция try выведет исключение и возвратит число 18. \nВозвращаемое значение указывается после всех остальных инструкций в блоке catch."
          }
        ]
      },
      {
        "id": 2,
        "title": "Null и nullable-типы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Null и nullable-типы"
          },
          {
            "type": "text",
            "content": "Ключевое слово null представляет специальный литерал, который указывает, что переменная не имеет как такового значения. То есть у нее по сути отсутствует значение."
          },
          {
            "type": "code",
            "content": "val n = null\nprintln(n)  // null"
          },
          {
            "type": "text",
            "content": "Подобное значение может быть полезно в ряде ситуациях, когда необходимо использовать данные, но при этом точно неизвестно, а есть ли в реальности эти данные. \nНапример, мы получаем данные по сети, данные могут прийти или не прийти. Либо может быть ситуация, когда нам надо явным образом указать, что данные не установлены."
          },
          {
            "type": "text",
            "content": "Однако переменным стандартных типов, например, типа Int или String или любых других классов, мы не можем просто взять и присвоить значение null:"
          },
          {
            "type": "code",
            "content": "val n : Int = null   // ! Ошибка, переменная типа Int допускает только числа"
          },
          {
            "type": "text",
            "content": "Мы можем присвоить значение null только переменной, которая представляет тип Nullable. Чтобы превратить обычный тип в тип nullable, достаточно поставить после названия типа вопросительный знак:"
          },
          {
            "type": "code",
            "content": "// val n : Int = null  //! ошибка, Int не допускает значение null\nval d : Int? = null // норм, Int? допускает значение null"
          },
          {
            "type": "text",
            "content": "При этом мы можем передавать переменным nullable-типов как значение null, так и конкретные значения, которые укладываются в диапазон значений данного типа:"
          },
          {
            "type": "code",
            "content": "var age : Int? = null\nage = 34              // Int? допускает null и числа\nvar name : String? = null\nname = \"Tom\"        // String? допускает null и строки"
          },
          {
            "type": "text",
            "content": "Nullable-типы могут представлять и создаваемые разработчиком классы:"
          },
          {
            "type": "code",
            "content": "fun main() {\n     \n    var bob: Person = Person(\"Bob\")\n    // bob = null // ! Ошибка - bob представляет тип Person и не допускает null\n    var tom: Person? = Person(\"Tom\")\n    tom = null  // норм - tom представляет тип Person? и допускает null\n}\nclass Person(val name: String)"
          },
          {
            "type": "text",
            "content": "В то же время надо понимать, что String? и Int? - это не то же самое, что и String и Int. Nullable типы имеют ряд ограничений:"
          },
          {
            "type": "text",
            "content": "\t• Значения nullable-типов нельзя присвоить напрямую переменным, которые не допускают значения null"
          },
          {
            "type": "code",
            "content": "var message : String? = \"Hello\"\nval hello: String = message     // ! Ошибка - hello не допускает значение null"
          },
          {
            "type": "text",
            "content": "\t• У объектов nullable-типов нельзя вызвать напрямую те же функции и свойства, которые есть у обычных типов"
          },
          {
            "type": "code",
            "content": "var message : String? = \"Hello\"\n// у типа String свойство length возвращает длину строки\nprintln(\"Message length: ${message.length}\")    // ! Ошибка"
          },
          {
            "type": "text",
            "content": "\t• Нельзя передавать значения nullable-типов в качестве аргумента в функцию, где требуется конкретное значение, которое не может представлять null"
          },
          {
            "type": "text",
            "content": "Нельзя передавать значения nullable-типов в качестве аргумента в функцию, где требуется конкретное значение, которое не может представлять null"
          },
          {
            "type": "subtitle",
            "content": "\nОператор ?:"
          },
          {
            "type": "text",
            "content": "Одним из преимуществ Kotlin состоит в том, что его система типов позволяет определять проблемы, связанные с использованием null, во время компиляции, а не во время выполнения. \nНапример, возьмем следующий код:"
          },
          {
            "type": "code",
            "content": "var name : String?  = \"Tom\"\nval userName: String = name // ! Ошибка"
          },
          {
            "type": "text",
            "content": "Переменная name хранит строку \"Tom\". Переменная userName представляет тип String и тоже может хранить строки, но тем не менее напрямую в данном случае мы не можем передать значение из переменной name в userName. В данном случае для компилятора неизвестно, каким значением инициализирована переменная name. Ведь переменная name может содержать и значение null, которое недопустимо для типа String."
          },
          {
            "type": "text",
            "content": "В этом случае мы можем использовать оператор '?:', который позволяет предоставить альтернативное значение, если присваиваемое значение равно null:"
          },
          {
            "type": "code",
            "content": "var name : String?  = \"Tom\"\nval userName: String = name ?: \"Undefined\"  // если name = null, то присваивается \"Undefined\"\n \nvar age: Int? = 23\nval userAge: Int = age ?:0  // если age равно null, то присваивается число 0"
          },
          {
            "type": "text",
            "content": "Оператор '?:' принимает два операнда. Если первый операнд не равен null, то возвращается значение первого операнда. Если первый операнд равен null, то возвращается значение второго операнда."
          },
          {
            "type": "text",
            "content": "То есть это все равно, если бы мы написали:"
          },
          {
            "type": "code",
            "content": "var name : String?  = \"Tom\"\nval userName: String\nif(name!=null){\n \n    userName = name\n}"
          },
          {
            "type": "text",
            "content": "Но оператор ?: позволяет сократить подобную конструкцию."
          },
          {
            "type": "subtitle",
            "content": "\nОператор ?."
          },
          {
            "type": "text",
            "content": "Оператор '?.' позволяет объединить проверку значения объекта на null и обратиться к функциям или свойствам этого объекта."
          },
          {
            "type": "text",
            "content": "Например, у строк есть свойство length, которое возвращает длину строки в символах. У объекта String? мы просто так не можем обратиться к свойству length, так как если объект String? равен null, то и строки как таковой нет, и соответственно длину строки нельзя определить. И в этом случае мы можем применить оператор '?.' :"
          },
          {
            "type": "code",
            "content": "var message : String? = \"Hello\"\nval length: Int? = message?.length"
          },
          {
            "type": "text",
            "content": "Если переменная message вдруг равна null, то переменная length получит значение null. Если переменная name содержит строку, то возвращается длина этой строки. По сути выражение val length: Int? = message?.length эквивалентно следующему коду:"
          },
          {
            "type": "code",
            "content": "val length: Int?\nif(message != null)\n    length = message.length\nelse\n    length = null"
          },
          {
            "type": "text",
            "content": "С помощью оператора '?.' подобным образом можно обращаться к любым свойствам и функциям объекта."
          },
          {
            "type": "text",
            "content": "Также в данном случае мы могли совместить оба выше рассмотренных оператора:"
          },
          {
            "type": "code",
            "content": "val message : String?  = \"Hello\"\nval length: Int = message?.length ?:0"
          },
          {
            "type": "text",
            "content": "Теперь переменная length не допускает значения null. И если переменная name не определена, то length получает число 0."
          },
          {
            "type": "text",
            "content": "Используя этот оператор, можно создавать цепочки проверок на null:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    var tom: Person? = Person(\"Tom\")\n    val tomName: String? = tom?.name?.uppercase()\n    println(tomName)        // TOM\n \n    var bob: Person? = null\n    val bobName: String? = bob?.name?.uppercase()\n    println(bobName)        // null\n \n    var sam: Person? = Person(null)\n    val samName: String? = sam?.name?.uppercase()\n    println(samName)        // null\n \n}\nclass Person(val name: String?)"
          },
          {
            "type": "text",
            "content": "Здесь класс Person в первичном конструкторе принимает значение типа String?, то есть это можт быть строка, а может быть null."
          },
          {
            "type": "text",
            "content": "Допустим, мы хотим получить переданное через конструктор имя пользователя в верхнем регистре (заглавными буквами). Для перевода текста в верхний регистр у класса String есть функция uppercase(). Однако может сложиться ситуация, когда либо объект Person равен null, либо его свойство name (которое представляет тип String?) равно null. И в этом случае перед вызовом функции uppercase() нам надо проверять на null все эти объекты. А оператор '?.' позволяет сократить код проверки:"
          },
          {
            "type": "code",
            "content": "val tomName: String? = tom?.name?.uppercase()"
          },
          {
            "type": "text",
            "content": "То есть если tom не равен null, то обращаемся к его свойству name. Далее если name не равен null, то обращаемся к ее функции uppercase(). Если какое-то звено в этой проверки возвратит null, переменная tomName тоже будет равна null."
          },
          {
            "type": "text",
            "content": "Но здесь мы также можем избежать финального возвращения null и присвоить значение по умолчанию:"
          },
          {
            "type": "code",
            "content": "val tomName: String = tom?.name?.uppercase() ?: \"Undefined\""
          },
          {
            "type": "subtitle",
            "content": "\nОператор !!"
          },
          {
            "type": "text",
            "content": "Оператор '!!' (not-null assertion operator) принимает один операнд. Если операнд равен null, то генерируется исключение. Если операнд не равен null, то возвращается его значение."
          },
          {
            "type": "text",
            "content": "Например, следующий код компилятор не пропустит:"
          },
          {
            "type": "code",
            "content": "var name : String? = \"Tom\"\nval id: String = name       // Ошибка"
          },
          {
            "type": "text",
            "content": "Так как name потенциально может быть равно null, поэтому мы не можем присвоить это значение переменной id. Но здесь по коду очевидно, что name НЕ равно null. Возможно, где-то дальше в программе оно может измениться на null, но здесь мы уверены, что оно не равно null. Поэтому для утверждения, что nullable-переменная не равна null, мы как раз можем использовать оператор '!!':"
          },
          {
            "type": "code",
            "content": "fun main() {\n    var name : String? = \"Tom\"\n    val id: String = name!!\n    println(id)\n}"
          },
          {
            "type": "text",
            "content": "Поскольку данный оператор возвращает объект, который не представляет nullable-тип, то после применения оператора мы можем обратиться к методам и свойствам этого объекта:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    var name : String? = \"Tom\"\n    val nameLength = name!!.length\n    println(nameLength)\n}"
          },
          {
            "type": "text",
            "content": "То есть данный оператор применяется, когда мы уверены, что значение НЕ равно null. Если же мы применим этот оператор к значению null, то программа сгенерирует исключение:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    try{\n        var name : String? = null\n        val id= name!!\n        println(id)\n    }\n    catch(e:Exception){\n        println(e.message)\n    }\n}"
          }
        ]
      },
      {
        "id": 3,
        "title": "Преобразование типов",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Преобразование типов"
          },
          {
            "type": "text",
            "content": "Нередко может возникать задача по преобразованию типов, например, чтобы использовать данные одного типа в констексте, где требуются данные другого типа. \nВ этом случае Kotlin представляет ряд возможностей по преобразованию типов."
          },
          {
            "type": "subtitle",
            "content": "\nВстроенные методы преобразования типов"
          },
          {
            "type": "text",
            "content": "Для преобразования данных одного типа в другой можно использовать встроенные следующие функции, которые есть у базовых типов:"
          },
          {
            "type": "text",
            "content": "\t• toByte"
          },
          {
            "type": "text",
            "content": "\t• toShort"
          },
          {
            "type": "text",
            "content": "\t• toInt"
          },
          {
            "type": "text",
            "content": "\t• toLong"
          },
          {
            "type": "text",
            "content": "\t• toFloat"
          },
          {
            "type": "text",
            "content": "\t• toDouble"
          },
          {
            "type": "text",
            "content": "\t• toChar"
          },
          {
            "type": "text",
            "content": "Все эти функции преобразуют данные в тот тип, которые идет после префикса to:"
          },
          {
            "type": "code",
            "content": "val s: String = \"12\"\nval d: Int = s.toInt()\nprintln(d)"
          },
          {
            "type": "subtitle",
            "content": "\nSmart cast и оператор is"
          },
          {
            "type": "text",
            "content": "Оператор is позволяет проверить выражение на принадлежность определенному типу данных:"
          },
          {
            "type": "code",
            "content": "значение is тип_данных"
          },
          {
            "type": "text",
            "content": "Этот оператор возвращает true, если значение слева от оператора принадлежит типу, указанному справа от оператора. Если локальная переменная или свойство успешно пройдет проверку на принадлежность определенному типу, то далее нет нужды дополнительно приводить значение к этому типу. \nДанные преобразования еще называются smart cast sили \"умные преобразования\"."
          },
          {
            "type": "text",
            "content": "Данный оператор можно применять как к базовым типам, но к собственным классам и интерфейсам, которые находятся в одной и той же иерархии наследования."
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"Tom\")\n    val bob = Employee(\"Bob\", \"JetBrains\")\n \n    checkEmployment(tom)    // Tom does not have a job\n    checkEmployment(bob)    // Bob works in JetBrains\n}\n \nfun checkEmployment(person: Person){\n    // println(\"${person.name} works in ${person.company}\")    // Ошибка - у Person нет свойства company\n    if(person is Employee){\n        println(\"${person.name} works in ${person.company}\")\n    }\n    else{\n        println(\"${person.name} does not have a job\")\n    }\n}\nopen class Person(val name: String)\nclass Employee(name: String, val company: String): Person(name)"
          },
          {
            "type": "text",
            "content": "Здесь класс Employee наследуется от класса Person. В функции checkEmployment() получаем объект Person. С помощью оператора is проверяем, представляет ли он тип Employee (так как не каждый объект Person может представлять тип Employee). Если он представляет тип Employee, то выводим название его компании, если он не представляет тип Employee, то выводим, сообщение, что он безработный."
          },
          {
            "type": "text",
            "content": "Причем даже если значение представляет тип Employee, то до применения оператора is оно тем не менее принадлежит типу Person. И только применение оператора is преобразует значение из типа Person в тип Employee."
          },
          {
            "type": "text",
            "content": "Также можно применять другую форму оператора - !is. Она возвращает true, если значение НЕ представляет указанный тип данных:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"Tom\")\n    val bob = Employee(\"Bob\", \"JetBrains\")\n \n    checkEmployment(tom)    // Tom does not have a job\n    checkEmployment(bob)    // Bob works in JetBrains\n}\n \nfun checkEmployment(person: Person){\n    // println(\"${person.name} works in ${person.company}\")    // Ошибка - у Person нет свойства company\n    if(person !is Employee){\n        println(\"${person.name} does not have a job\")\n    }\n    else{\n        println(\"${person.name} works in ${person.company}\")\n    }\n}\nopen class Person(val name: String)\nclass Employee(name: String, val company: String): Person(name)"
          },
          {
            "type": "text",
            "content": "Однако, что, если свойство company имеет пустую строку, например \nval bob = Employee(\"Bob\", \"\")\nто есть фактически компания не указана. А мы хотим выводить компанию, если это свойство имеет какое-нибудь содержимое. В этом случае мы можем выполнить проверку на длину строки сразу же после применения оператора is:"
          },
          {
            "type": "code",
            "content": "fun checkEmployment(person: Person){\n    if(person is Employee && person.company.length > 0){\n        println(\"${person.name} works in ${person.company}\")\n    }\n    else{\n        println(\"${person.name} does not have a job\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "в выражении"
          },
          {
            "type": "code",
            "content": "person.company.length > 0){"
          },
          {
            "type": "text",
            "content": "компилятор уже видит, что person - это объект типа Employee, поэтому позволяет обращаться к его свойствам и функциям."
          },
          {
            "type": "text",
            "content": "Если необходимо определить различные действия в зависимости от типа объекта, то удобно использовать конструкцию when:"
          },
          {
            "type": "code",
            "content": "fun identifyPerson(person: Person){\n    when(person){\n        is Manager -> println(\"${person.name} is a manager\")\n        is Employee -&t; println(\"${person.name} is an employee\")\n        is Person -> println(\"${person.name} is just a person\")\n    }\n}\n \nopen class Person(val name: String)\nopen class Employee(name: String, val company: String): Person(name)\nclass Manager(name: String, company: String): Employee(name, company)"
          },
          {
            "type": "subtitle",
            "content": "\nОграничения умных преобразований"
          },
          {
            "type": "text",
            "content": "Подобные smart-преобразования тем не менее имеют ограничения. \nОни могут применяться, только если компилятор может гарантировать, что переменная не изменила своего значения в промежутке между проверкой и использованием. Для smart-преобразований действуют следующие правила:"
          },
          {
            "type": "text",
            "content": "\t1) smart-преобразования применяются к локальным val-переменным (за исключением делегированных свойств)"
          },
          {
            "type": "text",
            "content": "\t2) smart-преобразования применяются к val-свойствам, за исключением свойств с модификатором open (то есть открытых к переопределению в производных классах) или свойств, для которых явным образом определен геттер"
          },
          {
            "type": "text",
            "content": "\t3) smart-преобразования применяются к локальным var-переменным (то есть к переменным, определенным в функциях), если переменная не изменяет своего значения в промежутке между проверкой и использованием и не используется в лямбда-выражении, которое изменяет ее, а также не является локальным делегированным свойством"
          },
          {
            "type": "text",
            "content": "\t4) к var-свойствам smart-преобразования не применяются"
          },
          {
            "type": "text",
            "content": "Рассмотрим некоторые случаи. Возьмем последнее правило про var-свойства:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"Tom\")\n \n    if(tom.phone is SmartPhone){\n \n        println(\"SmartPhone: ${tom.phone.name}, OS: ${tom.phone.os}\")   // ! Ошибка\n    }\n    else{\n        println(\"Phone: ${tom.phone.name}\")\n    }\n}\nopen class Phone(val name: String)\nclass SmartPhone(name: String, val os: String) : Phone(name)\n \nopen class Person(val name: String){\n    var phone: Phone = SmartPhone(\"Pixel 5\", \"Android\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь класс Person хранит var-свойство класса Phone, которому присваивается объект класса SmartPhone. Соответственно в выражении:"
          },
          {
            "type": "code",
            "content": "if(tom.phone is SmartPhone){"
          },
          {
            "type": "text",
            "content": "очевидно, что свойство tom.phone представляет класс SmartPhone, однако поскольку это свойство определено с помощью var, то к нему не применяются smart -преобразования. То есть если в данном случае мы заменим var на val, то у нас проблем не возникнет."
          },
          {
            "type": "text",
            "content": "Или второе правило - изменим класс Person, определив для свойства геттер:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String){\n    val phone: Phone\n        get()  = SmartPhone(\"Pixel 5\", \"Android\")\n}"
          },
          {
            "type": "text",
            "content": "В соответствии с вторым правилом опять же к такому свойству не применяются smart-преобразования, так как оно имеет геттер."
          },
          {
            "type": "subtitle",
            "content": "\nЯвные преобразования и оператор as"
          },
          {
            "type": "text",
            "content": "С помощью оператора as мы можем приводить значения одного типа к другому типу:"
          },
          {
            "type": "code",
            "content": "значение as тип_данных"
          },
          {
            "type": "text",
            "content": "Слева от оператора указывается значение, а справа - тип данных, в которых надо преобразовать значение. Например, преобразуем значение типа String? в тип String:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val hello: String? = \"Hello Kotlin\"\n    val message: String = hello as String\n    println(message)\n}"
          },
          {
            "type": "text",
            "content": "Здесь переменная hello хранит строку и может быть удачно преобразована в значение типа String. Однако если переменная hello равна null:"
          },
          {
            "type": "code",
            "content": "val hello: String? = null\nval message: String = hello as String\nprintln(message)"
          },
          {
            "type": "text",
            "content": "В этом случае преобразование завершится неудачно - ведь значение null нельзя преобразовать в значение типа String. Поэтому будет сгенерировано исключение NullPointerException."
          },
          {
            "type": "text",
            "content": "Чтобы избежать генерации исключения мы можем применять более безопасную версию оператора as?, которая в случае неудачи преобразования возвращает null."
          },
          {
            "type": "code",
            "content": "val hello: String? = null\n    val message: String? = hello as? String\n    println(message)"
          },
          {
            "type": "text",
            "content": "В данном случае оператор as? возвратит null, так как null нельзя преобразовать в строку."
          },
          {
            "type": "text",
            "content": "Также можно применять данный оператор к преобразованиям своих типов:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"Tom\")\n    val bob = Employee(\"Bob\", \"JetBrains\")\n    checkCompany(tom)\n    checkCompany(bob)\n}\nfun checkCompany(person: Person){\n    val employee = person as? Employee\n    if (employee!=null){\n        println(\"${employee.name} works in ${employee.company}\")\n    }\n    else{\n        println(\"${person.name} is not an employee\")\n    }\n}\nopen class Person(val name: String)\nopen class Employee(name: String, var company: String): Person(name)"
          },
          {
            "type": "text",
            "content": "Здесь функция checkCompany() принимает объект класса Person и пытается преобразовать его в объект типа Employee. Но если каждый объект Employee представляет также объект Person (каждый работник является человеком), то не каждый объект Person представляет объект Employee (не каждый человек является работником). И в этом случае чтобы получить значение типа Employee, применяется оператор as?. Если объект person представляет тип Employee, то возвращается объект этого типа, иначе возвращается null. И далее мы можем проверить на значение null и выполнить те или иные действия."
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Tom is not an employee\nBob works in JetBrains"
          }
        ]
      },
      {
        "id": 4,
        "title": "Функции расширения",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Функции расширения"
          },
          {
            "type": "text",
            "content": "Функции расширения (extension function) позволяют добавить функционал к уже определенным типам. При этом типы могут быть определены где-то в другом месте, например, в стандартной библиотеке."
          },
          {
            "type": "text",
            "content": "Функция расширения определяется следующим образом:"
          },
          {
            "type": "code",
            "content": "fun тип.имя_функции(параметры) : возвращаемый_тип{\n    тело функции\n}"
          },
          {
            "type": "text",
            "content": "По большому счету определение аналогично определению обычной функции за тем исключением, что после слова fun идет название типа, для которого определяется функция, и через точку название функции."
          },
          {
            "type": "text",
            "content": "Определим пару функций расширения к стандартным типам Int и String:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val hello: String = \"hello world\"\n    println(hello.wordCount('l'))   // 3\n    println(hello.wordCount('o'))   // 2\n    println(4.square())                 // 16\n    println(6.square())                 // 36\n}\n \nfun String.wordCount(c: Char) : Int{\n    var count = 0\n    for(n in this){\n        if(n == c) count++\n    }\n    return count\n}\nfun Int.square(): Int{\n    return this * this\n}"
          },
          {
            "type": "text",
            "content": "Для типа Int определена функция возведения в квадрат. В каждой функции расширения через ключевое слово this мы можем ссылаться на текущий объект того типа, для которого создается функция. Например, в функции:"
          },
          {
            "type": "code",
            "content": "fun Int.square(): Int{\n    return this * this\n}"
          },
          {
            "type": "text",
            "content": "Через this обращаемся к тому объекту, для которого будет вызывться функция. И затем вы можем вызвать ее следующим образом:"
          },
          {
            "type": "code",
            "content": "4.square()  // 16"
          },
          {
            "type": "text",
            "content": "Для типа String определена функция wordCount, которая подсчитывает, сколько встречается определенный символ в строке."
          },
          {
            "type": "text",
            "content": "Следует учитывать, что в функциях расширения мы можем обращаться к любым общедоступным свойствам и методам объекта, однако не можем обращаться к свойствам и методам с модификаторам иprivate и protected."
          }
        ]
      },
      {
        "id": 5,
        "title": "Перегрузка операторов",
        "blocks": [
          {
            "type": "text",
            "content": "Kotlin позволяет определить для типов ряд встроенных операторов. Для определения оператора для типа определяется функция с ключевым словом operator:"
          },
          {
            "type": "code",
            "content": "operator fun название_оператора([параметры_оператора]) : возвращаемый_тип{\n    // действия функции оператора\n}"
          },
          {
            "type": "text",
            "content": "После ключевого слова fun идет название оператора и далее скобки. Если оператор бинарный, то в скобках указывается параметр оператора. После скобок через двоеточие указывается возвращаемый тип.\n\nРассмотрим простейший пример. Допустим, у нас есть класс Counter, который представляет некоторый счетчик:"
          },
          {
            "type": "code",
            "content": "class Counter(var value: Int)"
          },
          {
            "type": "text",
            "content": "Свойство value собственно хранит значение счетчика.\n\nИ допустим, у нас есть два объекта класса Counter - два счетчика, которые мы хотим сравнивать или складывать на основании их свойства value, используя стандартные операции сравнения и сложения:"
          },
          {
            "type": "code",
            "content": "val counter1 = Counter(5)\nval counter2 = Counter(7)\n \nval result = counter1 > counter2;\nval counter3: Counter = counter1 + counter2;"
          },
          {
            "type": "text",
            "content": "Но на данный момент ни операция сравнения, ни операция сложения для объектов Counter не доступны. Эти операции могут использоваться для ряда встроенных типов. \nНапример, по умолчанию мы можем складывать числовые значения, но как складывать объекты классов, которые создаются непосредственно разработчиком, компилятор не знает. И для этого нам надо выполнить перегрузку нужных нам операторов:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    val counter1 = Counter(5)\n    val counter2 = Counter(7)\n \n    val counter1IsGreater = counter1 > counter2\n    val counter3: Counter = counter1 + counter2\n     \n    println(counter1IsGreater)  // false\n    println(counter3.value)     // 12\n}\n \nclass Counter(var value: Int){\n \n    operator fun compareTo(counter: Counter) : Int{\n        return this.value - counter.value\n    }\n    operator fun plus(counter: Counter): Counter {\n        return Counter(this.value + counter.value)\n    }\n}"
          },
          {
            "type": "text",
            "content": "Переопределение операторов предполагает переопределение соответствующих этим операторам функций. Например, операция сравнения"
          },
          {
            "type": "code",
            "content": "counter1 > counter2"
          },
          {
            "type": "text",
            "content": "транслируется в функцию"
          },
          {
            "type": "code",
            "content": "counter1.compareTo(counter2) > 0"
          },
          {
            "type": "text",
            "content": "То есть, если левый операнд (counter1) операции больше чем правый операнд (counter2), то функция оператора должна возвращать число больше 0. И в данном случае мы можем просто вычесть из counter1.value значение counter2.value, чтобы определить, больше ли counter1 чем counter2:"
          },
          {
            "type": "code",
            "content": "operator fun compareTo(counter: Counter) : Int{\n    return this.value - counter.value\n}"
          },
          {
            "type": "text",
            "content": "Оператор сложения + транслируется в функцию plus(). Параметр этой функции представляет правый операнд операции. Левый операнд доступен через ключевое слово this:"
          },
          {
            "type": "code",
            "content": "operator fun plus(counter: Counter): Counter {\n    return Counter(this.value + counter.value)\n}"
          },
          {
            "type": "text",
            "content": "Возвращаемое значение операции сложения может быть любым, но в данном случае мы предполагаем, что это будет также объект Counter."
          },
          {
            "type": "subtitle",
            "content": "\nОператоры в виде функций расширений"
          },
          {
            "type": "text",
            "content": "Операторы могут быть определены как в виде функций класса, так и в виде функций расширений. А это значит, что мы можем переопределить операторы даже для встроенных типов:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    val counter1 = Counter(5)\n    val counter2 = Counter(3)\n \n    val counter3: Counter = counter1 + counter2\n \n    val counter4: Counter = 33 + counter1\n     \n    println(counter3.value)     // 8\n    println(counter4.value)     // 38\n}\n \nclass Counter(val value: Int)\n \noperator fun Counter.plus(counter: Counter): Counter {\n    return Counter(this.value + counter.value)\n}\n \noperator fun Int.plus(counter: Counter): Counter {\n    return Counter(this + counter.value)\n}"
          },
          {
            "type": "text",
            "content": "Здесь для класса Counter определена опрерация сложения с помощью функции расширения. Но кроме того, здесь также определен оператор сложения и для встроенного типа Int - в данном случае в качестве правого операнда будет передаваться объект Counter и результатом операции также будет объект Counter:"
          },
          {
            "type": "code",
            "content": "operator fun Int.plus(counter: Counter): Counter {\n    return Counter(this + counter.value)\n}"
          },
          {
            "type": "text",
            "content": "Благодаря этому мы также сможем складывать объекты Int и Counter:"
          },
          {
            "type": "code",
            "content": "val counter4: Counter = 33 + counter1"
          },
          {
            "type": "text",
            "content": "Рассмотрим, какие операторы мы можем переопределить"
          },
          {
            "type": "subtitle",
            "content": "\nУнарные операторы"
          },
          {
            "type": "image",
            "content": "ch6ar5_1"
          },
          {
            "type": "text",
            "content": "Например, переопределение операции унарного минуса"
          },
          {
            "type": "code",
            "content": "fun main(){\n    val counter1 = Counter(5)\n    val counter2 = -counter1\n \n    println(counter2.value)     // -5\n}\n \nclass Counter(var value: Int){\n \n    operator fun unaryMinus(): Counter{\n        return Counter(-value)\n    }\n}"
          },
          {
            "type": "subtitle",
            "content": "\nИнкремент/декремент"
          },
          {
            "type": "image",
            "content": "ch6ar5_2"
          },
          {
            "type": "text",
            "content": "Следует отметить, что эти операторы не должны именять текущий объект, к которому применяется операция инкремента/декремента, а должны возвращать новый объект этого типа. Например:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    var counter1 = Counter(5)\n    var counter2 = counter1++\n \n    println(counter1.value)     // 6\n    println(counter2.value)     // 5\n \n    var counter3 = ++counter1\n    println(counter1.value)     // 7\n    println(counter3.value)     // 7\n}\n \nclass Counter(var value: Int){\n \n    operator fun inc(): Counter{\n        return Counter(value + 1)\n    }\n    operator fun dec(): Counter{\n        return Counter(value - 1)\n    }\n}"
          },
          {
            "type": "text",
            "content": "При операции постфиксного инкремента (counter1++) компилятор сначала создает временную переменную, в которую сохраняет текущий объект. Затем текущий объект замещает значением, полученным из функции inc(). В качестве результата операции возвращается значение временной переменной:"
          },
          {
            "type": "code",
            "content": "var counter1 = Counter(5)\nvar counter2 = counter1++   // counter2 получает старое значение объекта counter1 из временной переменной\n \nprintln(counter1.value)     // 6\nprintln(counter2.value)     // 5"
          },
          {
            "type": "text",
            "content": "При префиксном инкременте (++counter1) компилятор возвращает новое значение, полученное из функции inc():"
          },
          {
            "type": "code",
            "content": "println(counter1.value)     // 6\n \nvar counter3 = ++counter1\nprintln(counter1.value)     // 7\nprintln(counter3.value)     // 7"
          },
          {
            "type": "text",
            "content": "Те же правила касаются и префиксного/постфиксного декремента."
          },
          {
            "type": "subtitle",
            "content": "\nБинарные арифметические операторы"
          },
          {
            "type": "image",
            "content": "ch6ar5_3"
          },
          {
            "type": "text",
            "content": "Пример операции сложения:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    val counter1 = Counter(5)\n    val counter2 = Counter(25)\n    val counter3: Counter = counter1 + counter2\n    println(counter3.value)     // 30\n \n    val counter4: Counter = counter1 + 4\n    println(counter4.value)     // 9\n}\n \nclass Counter(var value: Int){\n \n    operator fun plus(counter: Counter): Counter{\n        return Counter(value + counter.value)\n    }\n    operator fun plus(number: Int): Counter{\n        return Counter(value + number)\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь реализовано две версии оператора. Первая складывает объект Counter с другим объектом Counter. Вторая версия складывает объект Counter с целым числом."
          },
          {
            "type": "subtitle",
            "content": "\nОператоры сравнения"
          },
          {
            "type": "image",
            "content": "ch6ar5_4"
          },
          {
            "type": "text",
            "content": "Для первых двух операторов (== и !=) необходимо переопределить функцию equals(value: Any?), которая должна иметь один параметр типа Any? и возвращать значение Boolean"
          },
          {
            "type": "code",
            "content": "fun main(){\n    val counter1 = Counter(5)\n    val counter2 = Counter(5)\n    val counter3 = Counter(7)\n \n    println(counter1 == counter2)   // true\n    println(counter1 == counter3)   // false\n}\nclass Counter(var value: Int){\n \n    override operator fun equals(counter: Any?): Boolean{\n        if(counter is Counter) return this.value == counter.value\n        return false\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае два объекта Counter равны, если равны значения их свойств value.\n\nДля остальных операций сравнения реализуется функция compareTo(), которая должна возвращать число - значение типа Int. Если левый операнд больше правого, то возвращает число больше 0, если меньше, то возвращается число меньше 0. Если операнды равны, возвращается 0."
          },
          {
            "type": "code",
            "content": "fun main(){\n    val counter1 = Counter(5)\n    val counter2 = Counter(4)\n    val counter3 = Counter(7)\n \n    println(counter1 > counter2)   // true\n    println(counter1 > counter3)   // false\n    println(counter1 > 1)   // true\n    println(counter1 > 56)   // false\n}\nclass Counter(var value: Int){\n \n    operator fun compareTo(counter: Counter): Int{\n        return this.value - counter.value\n    }\n    operator fun compareTo(number: Int): Int{\n        return this.value - number\n    }\n}"
          },
          {
            "type": "subtitle",
            "content": "\nОператоры присвоения"
          },
          {
            "type": "image",
            "content": "ch6ar5_5"
          },
          {
            "type": "text",
            "content": "Все функции операторов присвоения должны возвращать значение типа Unit:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    val counter1 = Counter(5)\n    val counter2 = Counter(4)\n    val counter3 = Counter(7)\n \n    counter1 += counter2\n    println(counter1.value)   // 9\n \n    counter3 += 3\n    println(counter3.value)   // 10\n}\nclass Counter(var value: Int){\n \n    operator fun plusAssign(counter: Counter){\n        this.value += counter.value\n    }\n    operator fun plusAssign(number: Int){\n        this.value += number\n    }\n}"
          },
          {
            "type": "subtitle",
            "content": "\nОператор in"
          },
          {
            "type": "image",
            "content": "ch6ar5_6"
          },
          {
            "type": "text",
            "content": "Как правило, под операндом b подразумевается некоторая коллекция, которая в качестве элемента может иметь операнд a:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    val tom = Person(\"Tom\")\n    val mike = Person(\"Mike\")\n    val bob = \"Bob\"\n    val alice = \"Alice\"\n    val jetBrains = Company(arrayOf(Person(\"Tom\"), Person(\"Bob\"), Person(\"Sam\")))\n \n    val tomInJetBrains = tom in jetBrains\n    println(tomInJetBrains) // true\n \n    val mikeInJetBrains = mike in jetBrains\n    println(mikeInJetBrains) // false\n \n    val bobInJetBrains = bob in jetBrains\n    println(bobInJetBrains) // true\n \n    val aliceInJetBrains = alice in jetBrains\n    println(aliceInJetBrains) // false\n}\nclass Person(val name:String)\nclass Company(private val personal: Array<Person>){\n    operator fun contains(person: Person): Boolean{\n        for (employee in personal) {\n            if(employee.name == person.name) return true\n        }\n        return false\n    }\n    operator fun contains(personName: String): Boolean{\n        for (employee in personal) {\n            if(employee.name == personName) return true\n        }\n        return false\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае класс компании Company хранит в свойстве personal штат сотрудников в виде массива объекта Person. И класс Company реализует две версии оператора in: одна версия для проверки наличия объекта Person в массиве, другая для проверки наличия объект Person, имя которого соответствует строке - условному имени сотрудника."
          },
          {
            "type": "subtitle",
            "content": "\nОператоры доступа по индексу"
          },
          {
            "type": "image",
            "content": "ch6ar5_7"
          },
          {
            "type": "text",
            "content": "Применим оператор доступа по индексу"
          },
          {
            "type": "code",
            "content": "fun main(){\n    val jetBrains = Company(arrayOf(Person(\"Tom\"), Person(\"Bob\"), Person(\"Sam\")))\n \n    // получаем пользователей\n    val firstPerson: Person? = jetBrains[0]\n    println(firstPerson?.name) // Tom\n \n    val fifthPerson: Person? = jetBrains[5]\n    println(fifthPerson?.name) // null\n \n    // устанавливаем пользователей\n    jetBrains[0] = Person(\"Mike\")\n    println(jetBrains[0]?.name) // Mike\n}\nclass Person(val name:String)\nclass Company(private val personal: Array<Person>){\n    operator fun set(index: Int, person: Person){\n        // если индекс есть в массиве personal\n        if(index in personal.indices)\n            personal[index] = person    // то переустанавливаем значение в массиве\n    }\n    operator fun get(index: Int): Person?{\n        // если индекс есть в массиве personal\n        if(index in personal.indices)\n            return personal[index] // то возвращаем значение из массива\n        return null // иначе возвращаем null\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае с помощью функций get/set опосредуется доступ к массиву personal в рамках объекта People. А благодаря операторам-индексаторам мы сможем использовать объект People как массив."
          },
          {
            "type": "subtitle",
            "content": "\nОператоры вызова"
          },
          {
            "type": "text",
            "content": "Операторы вызова в виде реализации функции invoke() применяются для выполнения объекта на манер функции:"
          },
          {
            "type": "image",
            "content": "ch6ar5_8"
          },
          {
            "type": "text",
            "content": "Применение:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    val message=Message()\n    message(\"Hello Kotlin\")     // Message text: Hello Kotlin\n}\nclass Message(){\n    operator fun invoke(text: String) {\n        println(\"Message text: $text\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Подобный оператор удобно использовать в качестве фабрики объекта:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    val message1=Message(\"Hello\")\n    val message2 = message1(\"World\")\n    val message3 = message2(\"!!!\")\n    println(message3.text)  // Hello World !!!\n}\nclass Message(val text: String){\n    operator fun invoke(addition: String) : Message {\n        return Message(\"$text $addition\")\n    }\n}"
          }
        ]
      },
      {
        "id": 6,
        "title": "Делегированные свойства",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Делегированные свойства"
          },
          {
            "type": "text",
            "content": "Делегированные свойства позволяют делегировать получение или присвоение их значения во вне - другому классу. \nЭто позволяет нам добавить некоторую дополнительную  логику при операции со свойствами, например, логгирование, какую-то предобработку и т.д."
          },
          {
            "type": "text",
            "content": "Формальный синтаксис делегированного свойства:"
          },
          {
            "type": "code",
            "content": "val/var имя_свойства: тип_данных by выражение"
          },
          {
            "type": "text",
            "content": "После типа данных свойства идет ключевое слово by, после которого указывается выражение. \nВыражение представляет класс, который условно называется делегатом. Делегаты свойств могут не применять никаких интерфейсов, однако они должны предоставлять функции getValue() и setValue(). А выполнение методов доступ аget() и set(), которые есть у свойства, делегируется функциям getValue() и setValue() класса делегата."
          },
          {
            "type": "text",
            "content": "Стоит отметить, что мы не можем объявлять делегированные свойства в первичном конструкторе."
          },
          {
            "type": "subtitle",
            "content": "\nДелегированные свойства для чтения"
          },
          {
            "type": "text",
            "content": "Для свойств только для чтения (то есть val-свойств), делегат должен предоставлять функцию getValue(), которая принимает следующие параметры:"
          },
          {
            "type": "text",
            "content": "\t• thisRef: должен представлять тот же тип, что и свойство, к которому применяется делегат. Это может быть и родительский тип."
          },
          {
            "type": "text",
            "content": "\t• property: должен представлять тот же тип KProperty<*> или его родительский тип"
          },
          {
            "type": "text",
            "content": "При этом функция getValue() должна возвращать результат того же типа, что и тип свойства (либо его производного типа)."
          },
          {
            "type": "text",
            "content": "Рассмотрим на примере:"
          },
          {
            "type": "code",
            "content": "import kotlin.reflect.KProperty\n \nfun main() {\n \n    val tom = Person()\n    println(tom.name)   // Tom\n     \n    val bob = Person()\n    println(bob.name)   // Tom\n}\nclass Person{\n    val name: String by LoggerDelegate()\n}\nclass LoggerDelegate {\n    operator fun getValue(thisRef: Person, property: KProperty<*>): String {\n        println(\"Запрошено свойство: ${property.name}\")\n        return \"Tom\"\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь класс Person определяет свойство name, которое является делегированным - оно делегирует операцию получения значения функции getValue() класса LoggerDelegate."
          },
          {
            "type": "text",
            "content": "Поскольку свойство определено в классе Person, то первый параметр функции getValue() представляет тип Person. Благодаря этому мы можем выудить из этого параметра какую-то дополнительную информацию об объекте, если она необходима."
          },
          {
            "type": "text",
            "content": "Поскольку свойство представляет тип String, то функция также возвращает значение типа String- это то значение, которое будет возвращаться самим свойство мname. В данном случае возвращается строка \"Tom\". \nТо есть при каждом обращении к свойству name объекта Person будет возвращаться строка \"Tom\"."
          },
          {
            "type": "text",
            "content": "Теперь немного видоизменим пример:"
          },
          {
            "type": "code",
            "content": "import kotlin.reflect.KProperty\nfun main() {\n    val tom = Person(\"Tom\")\n    println(tom.name)   \n \n    val bob = Person(\"Bob\")\n    println(bob.name)\n}\nclass Person(_name: String){\n    val name: String by LoggerDelegate(_name)\n}\nclass LoggerDelegate(val personName: String) {\n    operator fun getValue(thisRef: Person, property: KProperty<*>): String {\n        println(\"Запрошено свойство ${property.name}\")\n        println(\"Устанавливаемое значение: $personName\")\n        return personName\n    }\n}"
          },
          {
            "type": "text",
            "content": "Теперь первичный конструктор Person принимает устанавливаемое значение для свойства name. \nДалее оно передается в конструктор классу LoggerDelegate, который использует его для логгирования на консоль. \nИ в конце возвращает его в качестве значения свойства name."
          },
          {
            "type": "subtitle",
            "content": "\nИзменяемые свойства"
          },
          {
            "type": "text",
            "content": "Для изменяемых свойств (var-свойств) делегат должен также предоставить функцию setValue(), которая принимает следующие параметры:"
          },
          {
            "type": "text",
            "content": "\t• thisRef: должен представлять тот же тип, что и свойство, к которому применяется делегат. Это может быть и родительский тип."
          },
          {
            "type": "text",
            "content": "\t• property: должен представлять тот же тип KProperty<*> или его родительский тип"
          },
          {
            "type": "text",
            "content": "\t• value: должен представлять тот же тип, что и свойство, или его родительский тип"
          },
          {
            "type": "text",
            "content": "Рассмотрим на примере:"
          },
          {
            "type": "code",
            "content": "import kotlin.reflect.KProperty\n \nfun main() {\n \n    val tom = Person(\"Tom\", 37)\n    println(tom.age)    //37\n    tom.age = 38\n    println(tom.age)    //38\n    tom.age = -139\n    println(tom.age)    //38\n \n}\nclass Person(val name: String, _age: Int){\n    var age: Int by LoggerDelegate(_age)\n}\nclass LoggerDelegate(private var personAge: Int) {\n    operator fun getValue(thisRef: Person, property: KProperty<*>): Int{\n        return personAge\n    }\n    operator fun setValue(thisRef: Person, property: KProperty<*>, value: Int){\n        println(\"Устанавливаемое значение: $value\")\n        if(value > 0 && value < 110) personAge = value\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь класс Person определяет делегированное свойство age. Оно делегирует установку и получение значения классу LoggerDelegate и его функциям getValue() и setValue(). Само значение сохраняется в свойстве personAge класса LoggerDelegate. Функция getValue() просто возвращает значение это свойства."
          },
          {
            "type": "text",
            "content": "Функция setValue() с помощью третьего параметра - value, которое представляет тот же тип, что и свойство - типInt, получает устанавливаемое значение. И если оно соответствует некоторому диапазону, то передает в свойство personAge."
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "37\nУстанавливаемое значение: 38\n38\nУстанавливаемое значение: -139\n38"
          }
        ]
      },
      {
        "id": 7,
        "title": "Scope - функции",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Scope-функции"
          },
          {
            "type": "text",
            "content": "Scope-функции (можно перевести как \"функции контекста\" или \"функции области видимости\") позволяют выполнить для некоторого объекта некоторый код в виде лямбда-выражение. \nПри вызове подобной функции, создается временная область видимости. В этой области видимости можно обращаться к объекту без использования его имени.\n\nВ Kotlin есть пять подобных функций: let, run, with, apply и also. \nЭти функции похожи по своему действию и различаются прежде всего по параметрам и возвращаемым результатам"
          },
          {
            "type": "subtitle",
            "content": "\nlet"
          },
          {
            "type": "text",
            "content": "Лямбда-выражение в функции let в качестве параметра it получает объект, для которого вызывается функция. \nВозвращаемый результат функции let представляет результат данного лямбда-выражения."
          },
          {
            "type": "code",
            "content": "inline fun <T, R> T.let(block: (T) -> R): R"
          },
          {
            "type": "text",
            "content": "Распространенным сценарием, где применяется данная функция, представляет проверка на null:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val sam = Person(\"Sam\", \"sam@gmail.com\")\n    sam.email?.let{ println(\"Email: $it\") }     // Email: sam@gmail.com\n    // аналог без функции let\n    //if(sam.email!=null) println(\"Email:${sam.email}\")\n \n    val tom = Person(\"Tom\", null)\n    tom.email?.let{ println(\"Email: $it\") } // функция let не будет выполняться\n \n}\ndata class Person(val name: String, val email: String?)"
          },
          {
            "type": "text",
            "content": "Допустим, мы хотим вывести значение свойства Email объекта Person. Но это свойство может хранить значение null (например, если электронный адрес у пользователя не установлен). \nС помощью выражения sam.email?. проверяем значение свойства email на null. Если email не равно null, то для строки в свойстве email вызывается функция let, которая создает временную область видимости и передает в нее значение свойства email через параметр it. Если же свойство email равно null, то функция let не вызывается.\n\nЕсли лямбда-выражение вызывает лишь одну функцию, в которую передается параметр it, то можно сократить вызов - указать после оператора :: название вызываемой функции:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val sam = Person(\"Sam\", \"sam@gmail.com\")\n    sam.email?.let(::println)   // sam@gmail.com\n \n    val tom = Person(\"Tom\", \"tom@gmail.com\")\n    tom.email?.let(::printEmail)    // Email: tom@gmail.com\n \n}\n \nfun printEmail(email: String){\n    println(\"Email: $email\")\n}\ndata class Person(val name: String, var email: String?)"
          },
          {
            "type": "subtitle",
            "content": "\nwith"
          },
          {
            "type": "text",
            "content": "Лямбда-выражение в функции with в качестве параметра this получает объект, для которого вызывается функция. \nВозвращаемый результат функции with представляет результат данного лямбда-выражения."
          },
          {
            "type": "code",
            "content": "inline fun <T, R> with(receiver: T, block: T.() -> R): R"
          },
          {
            "type": "text",
            "content": "Функция with принимает объект, для которого надо выполнить блок кода, в качестве параметра. Далее в самом блоке кода мы можем обращаться к общедоступным свойствам и методам объекта без его имени.\n\nОбычно функция with() применяется, когда надо выполнить над объектом набор операций как единое целое:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"Tom\", null)\n    val emailOfTom = with(tom) {\n        if(email==null)\n            email = \"${name.lowercase()}@gmail.com\"\n        email\n    }\n    println(emailOfTom) // tom@gmail.com\n}\ndata class Person(val name: String, var email: String?)"
          },
          {
            "type": "text",
            "content": "В данном случае функция with получает объект tom, поверяет его свойство email - если оно равно null, то устанавливает его на основе его имени. В качестве результата функции возвращается значение свойства email.\n\nЧасто with применяется для установки свойств объектов. Например:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"Tom\", -19,null)\n    with(tom) {\n        if(email==null) email = \"${name.lowercase()}@gmail.com\"\n        if(age !in 1..110) age = 18\n    }\n    println(\"${tom.name} (${tom.age}) - ${tom.email}\") // Tom (18) - tom@gmail.com\n}\ndata class Person(val name: String, var age:Int, var email: String?)"
          },
          {
            "type": "code",
            "content": "В данном случае функция with устанавливает свойства для объекта tom, если через конструктор им были переданы некорректные значения."
          },
          {
            "type": "subtitle",
            "content": "\nrun"
          },
          {
            "type": "text",
            "content": "Лямбда-выражение в функции run в качестве параметра this получает объект, для которого вызывается функция. \nВозвращаемый результат функции run представляет результат данного лямбда-выражения."
          },
          {
            "type": "code",
            "content": "inline fun <T, R> T.run(block: T.() -> R): R"
          },
          {
            "type": "text",
            "content": "Функция run похожа на функцию with за тем исключением, что run реализована как функция расширения. \nФункция run также принимает объект, для которого надо выполнить блок кода, в качестве параметра. Далее в самом блоке кода мы можем обращаться к общедоступным свойствам и методам объекта без его имени."
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"Tom\", null)\n    val emailOfTom = tom.run {\n        if(email==null)\n            email = \"${name.lowercase()}@gmail.com\"\n        email\n    }\n    println(emailOfTom) // tom@gmail.com\n}\ndata class Person(val name: String, var email: String?)"
          },
          {
            "type": "text",
            "content": "В данном случае функция run выполняет действия, аналогичные примеру с функцией with.\n\nРеализация run как функции расширения упрощает проверку на null:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"Tom\", null)\n    val validationResult = tom.email?.run {\"valid\"} ?: \"undefined\"\n    println(validationResult) // undefined\n}\ndata class Person(val name: String, var email: String?)"
          },
          {
            "type": "text",
            "content": "Также есть другая разновидность функции run(), которая просто позволяет выполнить некоторое лямбда-выражение:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val randomText = run{ \"hello world\"}\n    println(randomText)  // hello world\n \n    run{ println(\"run function\")}    // run function\n}"
          },
          {
            "type": "subtitle",
            "content": "\napply"
          },
          {
            "type": "text",
            "content": "Лямбда-выражение в функции apply в качестве параметра this получает объект, для которого вызывается функция. \nВозвращаемым результатом функции фактически является передаваемый в функцию объект для которого выполняется функция."
          },
          {
            "type": "code",
            "content": "inline fun T.apply(block: T.() -> Unit): T"
          },
          {
            "type": "text",
            "content": "Например:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"Tom\", null)\n    tom.apply {\n        if(email==null) email = \"${name.lowercase()}@gmail.com\"\n    }\n    println(tom.email) // tom@gmail.com\n}\ndata class Person(val name: String, var email: String?)"
          },
          {
            "type": "text",
            "content": "В данном случае, как и в примерах с функциями with и run, проверяем значение свойства email, и если оно равно null, устанавливаем его, используя свойство name.\n\nРаспространенным сценарием применения функции apply() является построение объекта в виде реализации вариации паттерна \"Строитель\":"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val bob = Employee()\n    bob.name(\"Bob\")\n    bob.age(26)\n    bob.company(\"JetBrains\")\n    println(\"${bob.name} (${bob.age}) - ${bob.company}\") // Bob (26) - JetBrains\n}\n \ndata class Employee(var name: String = \"\", var age: Int = 0, var company: String = \"\") {\n    fun age(_age: Int): Employee = apply { age = _age }\n    fun name(_name: String): Employee = apply { name = _name }\n    fun company(_company: String): Employee = apply { company = _company }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае класс Employee содержит три метода, которые устанавливают каждое из свойств класса. \nПричем каждый подобный метод вызывает функцию apply(), которое передает значение соответствующему свойству и возвращает текущий объект Employee."
          },
          {
            "type": "subtitle",
            "content": "\nalso"
          },
          {
            "type": "text",
            "content": "Лямбда-выражение в функции also в качестве параметра it получает объект, для которого вызывается функция. \nВозвращаемым результатом функции фактически является передаваемый в функцию объект для которого выполняется функция."
          },
          {
            "type": "code",
            "content": "inline fun T.also(block: (T) -> Unit): T"
          },
          {
            "type": "text",
            "content": "Эта функция аналогична функции apply за тем исключением, что внутри also объект, над которым выполняется блок кода, доступен через параметр it:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"Tom\", null)\n    tom.also {\n        if(it.email==null)\n            it.email = \"${it.name.lowercase()}@gmail.com\"\n    }\n    println(tom.email) // tom@gmail.com\n}\ndata class Person(val name: String, var email: String?)"
          }
        ]
      },
      {
        "id": 8,
        "title": "Инфиксная нотация",
        "blocks": [
      {
        "type": "subtitle",
        "content": "Инфиксная нотация"
      },
      {
        "type": "text",
        "content": "Инфиксная нотация представляет помещение оператора или функции перед операндами или аргументами. \nИнфиксная нотация часто применяется для определения математических и логических выражений. К примеру, выражение (+ a b) представляет инфиксную нотацию записи суммы чисел a + b.\n\nДля определения инфиксной функции вначале ее определения указывается ключевое слово infix:"
      },
      {
        "type": "code",
        "content": "infix fun название_функции(параметр: тип_параметра): тип_возвращаемого_значения{\n    // действия функции\n}"
      },
      {
        "type": "text",
        "content": "Инфиксная функция должна принимать только один параметр. При этом параметр не должен иметь значение по умолчанию и не должен представлять неопределенный набор значений.\n\nЕсть два способа определения инфиксной функции: либо внутри класса, либо как функции расширения.\n\nОпределим вначале внутри класса:"
      },
      {
        "type": "code",
        "content": "fun main() {\n \n    val acc = Account(1000)\n    acc put 150\n    // равноценно вызову\n    acc.put(150)\n    acc.printSum()  // 1300\n}\nclass Account(var sum: Int) {\n \n    infix fun put(amount: Int){\n        sum = sum + amount\n    }\n    fun printSum() = println(sum)\n}"
      },
      {
        "type": "text",
        "content": "Здесь определен класс Account - класс банковского счета, который через конструктор принимает начальную сумму на счете. С помощью инфиксной функции put() определяем добавление на счет суммы, переданной через параметр функции.\n\nВызов функции выглядит следующим образом:"
      },
      {
        "type": "code",
        "content": "acc put 150"
      },
      {
        "type": "text",
        "content": "Первый параметр (здесь переменная acc) представляет объект, который вызывает функцию. А второй параметр - данные, которые непосредственно будут передаваться инфиксной функции через ее параметр. То есть данный вызов фактически аналогичен вызову:"
      },
      {
        "type": "code",
        "content": "acc.put(150)"
      },
      {
        "type": "text",
        "content": "Также инфиксная функция может определяться как функция расширения. Например, перепишем выше использованную функцию put() в виде функции расширения:"
      },
      {
        "type": "code",
        "content": "fun main() {\n \n    val acc = Account(1000)\n    acc put 150\n    acc.put(150)\n    acc.printSum()  // 1300\n}\ninfix fun Account.put(amount: Int){\n    this.sum = this.sum + amount\n}\nclass Account(var sum: Int) {\n    fun printSum() = println(sum)\n}"
      },
      {
        "type": "text",
        "content": "Стоит отметить, что функция расширения в отличие от функции внутри класса имеет доступ только тем свойствам, которые являются публичными.\n\nОднако использование функций расширений позволяет добавить инфиксные функции к уже существующим типам. \nНапример, определим инфиксную функцию для подсчета частоты символа в строке:"
      },
      {
        "type": "code",
        "content": "fun main() {\n \n    val hello = \"hello world\"\n    val lCount = hello wordCount 'l'\n    val oCount = hello wordCount 'o'\n    println(lCount)   // 3\n    println(oCount)   // 2\n}\n \ninfix fun String.wordCount(c: Char) : Int{\n    var count = 0\n    for(n in this){\n        if(n == c) count++\n    }\n    return count\n}"
      },
      {
        "type": "text",
        "content": "Здесь функция wordCount проходит по всем символам строки и подсчитывает, сколько раз встречается символ, передаваемый через параметр функции. Результат возвращается функцией. Затем мы можем применить инфиксную нотацию:"
      },
      {
        "type": "code",
        "content": "val lCount = hello wordCount 'l'"
      },
      {
        "type": "text",
        "content": "Поскольку функция возвращает результат типа Int, то мы можем получить этот результат в переменную.\n\nИнфиксная функция позволяет задать способ описания действия, более близкий к естественному языку. Например:"
      },
      {
        "type": "code",
        "content": "fun main() {\n \n    val tom = Person(\"Tom\")\n    tom says \"Hello\"\n}\nclass Person(val name: String) {\n \n    infix fun says(words: String){\n        println(\"$name says: ${words}\")\n    }\n}"
      },
      {
        "type": "text",
        "content": "Здесь определен класс Person, который представляет человека и который через параметр name конструктора получает имя человека. \nВ этом классе в виде инфиксной функции определен метод \"says\", который принимает параметр words - это условные слова, которые произносит человек.\n\nДля вызова метода says мы можем написать следующим образом:"
      },
      {
        "type": "code",
        "content": "tom says \"Hello\""
      },
      {
        "type": "text",
        "content": "что может показаться более естественным выражения действия на английском, нежели:"
      },
      {
        "type": "code",
        "content": "tom.says(\"Hello\")"
      },
      {
        "type": "text",
        "content": "И не только на английском. Например:"
      },
      {
        "type": "code",
        "content": "fun main() {\n \n    val Том = Person(\"Tom\")\n    Том говорит \"Привет\"\n}\nclass Person(val name: String) {\n \n    infix fun говорит(words: String){\n        println(\"$name говорит: ${words}\")\n    }\n}"
      }
        ]
      }
    ]
  },
  {
    "chapterId": 7,
    "chapterTitle": "Коллекции",
    "articles": [
      {
        "id": 1,
        "title": "List",
        "blocks": [
          {
            "type": "subtitle",
            "content": "List"
          },
          {
            "type": "text",
            "content": "List представляет последовательный список элементов. При этом List представляет неизменяемую (immutable) коллекцию, которая в основном только обеспечивает получение элементов по позиции."
          },
          {
            "type": "text",
            "content": "Интерфейс List расширяет интерфейс Collection, поэтому перенимает его возможности."
          },
          {
            "type": "text",
            "content": "Для создания объекта List применяется метод listOf():"
          },
          {
            "type": "code",
            "content": "var numbers = listOf(1, 2, 3, 4, 5)     // объект List<Int>\nval people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")   // объект List<String>"
          },
          {
            "type": "text",
            "content": "Списки поддерживают перебор с помощью цикла for, кроме для списка по умолчанию задача реализация toString, которая выводит все элементы списка в удобочитаемом виде:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")\n \nfor(person in people) println(person)\nprintln(people) // [Tom, Sam, Kate, Bob, Alice]"
          },
          {
            "type": "subtitle",
            "content": "\nМетоды списков"
          },
          {
            "type": "text",
            "content": "Кроме унаследованных методов класс List имеет ряд специфичных. Рассмотрим некоторые из них."
          },
          {
            "type": "text",
            "content": "Для получения элемента по индексу можно применять метод get(index), который возвращает элемент по индексу"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")\nval first = people.get(0)\nval second = people.get(1)\nprintln(first)      // Tom\nprintln(second)     // Sam"
          },
          {
            "type": "text",
            "content": "Вместо метода get для обращения по индексу можно использовать квадратные скобки []:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")\nval first = people[0]\nval second = people[1]\nprintln(first)      // Tom\nprintln(second)     // Sam"
          },
          {
            "type": "text",
            "content": "Однако, если индекс выходит за границы списка, то при использовании метода get() и квадратных скобок генерируется исключение. \nЧтобы избежать подобной ситуации, можно применять метод getOrNull(), который возвращает null, если индекс находится вне границ списка:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")\nval first = people.getOrNull(0)\nval tenth = people.getOrNull(10)\nprintln(first)      // Tom\nprintln(tenth)     // null"
          },
          {
            "type": "text",
            "content": "Либо в качестве альтернативы можно применять метод getOrElse():"
          },
          {
            "type": "code",
            "content": "getOrElse(index: Int, defaultValue: (Int) -> T): T"
          },
          {
            "type": "text",
            "content": "Первый параметр представляет индекс, а второй параметр - функция, которая получает запрошенный индекс и возвращает значение, которое возвращается, если индекс выходит за границы списка:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")\nval first = people.getOrElse(0){\"Undefined\"}\nval seventh = people.getOrElse(7){\"Invalid index $it\"}\nval tenth = people.getOrElse(10){\"Undefined\"}\n     \nprintln(first)      // Tom\nprintln(seventh)    // Invalid index 7\nprintln(tenth)     // Undefined"
          },
          {
            "type": "subtitle",
            "content": "\nПолучение части списка"
          },
          {
            "type": "text",
            "content": "Метод subList() возвращает часть списка и в качестве параметров принимает начальный и конечный индексы извлекаемых элементов:"
          },
          {
            "type": "code",
            "content": "subList(fromIndex: Int, toIndex: Int): List<E>"
          },
          {
            "type": "text",
            "content": "Например, получим подсписок с 1 по 4 индексы:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\", \"Mike\")\nval subPeople = people.subList(1, 4)\nprintln(subPeople)      // [Sam, Kate, Bob]"
          },
          {
            "type": "subtitle",
            "content": "\nИзменяемые списки"
          },
          {
            "type": "text",
            "content": "Изменяемые списки представлены интерфейсом MutableList. Он расширяет интерфейс List и позволяют добавлять и удалять элементы. Данный интерфейс реализуется классом ArrayList."
          },
          {
            "type": "text",
            "content": "Для создания изменяемых списков можно использовать ряд методов:"
          },
          {
            "type": "text",
            "content": "\t• arrayListOf(): создает объект ArrayList"
          },
          {
            "type": "text",
            "content": "\t• mutableListOf(): создает объект MutableList"
          },
          {
            "type": "text",
            "content": "Создание изменяемых списков:"
          },
          {
            "type": "code",
            "content": "var numbers : ArrayList<Int> = arrayListOf(1, 2, 3, 4, 5)\nvar numbers2: MutableList<Int> = mutableListOf(5, 6, 7)"
          },
          {
            "type": "text",
            "content": "Если необходимо добавлять или удалять элементы, то надо использовать методы MutableList:"
          },
          {
            "type": "text",
            "content": "\t• add(index, element): добавлят элемент по индексу"
          },
          {
            "type": "text",
            "content": "\t• add(element): добавляет элемент"
          },
          {
            "type": "text",
            "content": "\t• addAll(collection): добавляет коллекцию элементов"
          },
          {
            "type": "text",
            "content": "\t• remove(element): удаляет элемент"
          },
          {
            "type": "text",
            "content": "\t• removeAt(index): удаляет элемент по индексу"
          },
          {
            "type": "text",
            "content": "\t• clear(): удаляет все элементы коллекции"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val numbers1 : ArrayList<Int> = arrayListOf(1, 2, 3, 4, 5)\n    numbers1.add(4)\n    numbers1.clear()\n     \n    val numbers2: MutableList<Int> = mutableListOf(5, 6, 7)\n \n    numbers2.add(12)\n    numbers2.add(0, 23)\n    numbers2.addAll(0, listOf(-3, -2, -1))\n    numbers2.removeAt(0)\n    numbers2.remove(5)\n \n    for (n in numbers2){ println(n) }\n}"
          }
        ]
      },
      {
        "id": 2,
        "title": "Set",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Set"
          },
          {
            "type": "text",
            "content": "Интерфейс Set представляет неупорядоченный набор объектов, который хранит только уникальные объекты. \nSet представляет неизменяемый (immutable) набор. Set расширяет интерфейс Collection и соответственно все его методы."
          },
          {
            "type": "text",
            "content": "Для создания неизменяемого (immutable) набора используется функция setOf()."
          },
          {
            "type": "code",
            "content": "val numbers = setOf(5, 6, 7)            // объект Set<Int>\nval people = setOf(\"Tom\", \"Sam\", \"Bob\") // объект Set<String>"
          },
          {
            "type": "text",
            "content": "Для перебора Set можно применять цикл for:"
          },
          {
            "type": "code",
            "content": "val people = setOf(\"Tom\", \"Sam\", \"Bob\")\n \nfor(person in people) println(person)\nprintln(people) // [Tom, Sam, Bob]"
          },
          {
            "type": "text",
            "content": "Set реализует метод toString таким образом, что возвращает в удобочитабельном виде все элементы в виде строки"
          },
          {
            "type": "text",
            "content": "Причем, поскольку Set представляет набор уникальных объектов, то даже если мы передадим через функцию setOf() повторяющиеся значения, то в наборе все равно будут только уникальные значения:"
          },
          {
            "type": "code",
            "content": "val numbers = setOf(5, 6, 7, 5, 6)\nval people = setOf(\"Tom\", \"Sam\", \"Bob\", \"Tom\")\n \nprintln(numbers) // [5, 6, 7]\nprintln(people) // [Tom, Sam, Bob]"
          },
          {
            "type": "text",
            "content": "Для преобразования других коллекций к типу множества Kotlin предоставляет функцию toSet(). Например, у нас есть список, из которого мы хотим удалить повторяющиеся значения. И самым простым способом  сделать это будет преобразование списка к множеству:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val people = listOf(\"Tom\", \"Bob\", \"Sam\", \"Tom\", \"Bob\", \"Alex\")\n    val uniquePeople = people.toSet()\n    println(uniquePeople)  // [Tom, Bob, Sam, Alex]\n}"
          },
          {
            "type": "subtitle",
            "content": "\nМетоды Set"
          },
          {
            "type": "text",
            "content": "Рассмотрим некоторые специфичные операции Set. Прежде всего это методы для операций с множествами:"
          },
          {
            "type": "text",
            "content": "\t• union: объединение множеств"
          },
          {
            "type": "text",
            "content": "\t• intersect: пересечение множеств (возвращает элементы, которые есть в обоих множествах)"
          },
          {
            "type": "text",
            "content": "\t• subtract: вычитание множеств (возвращает элементы, которые есть в первом множестве, но отсутствуют во втором)"
          },
          {
            "type": "text",
            "content": "Хотя эти операции могут применяться и к спискам List, но возвращают они всегда объект Set и более уместны для множеств Set."
          },
          {
            "type": "code",
            "content": "val people = setOf(\"Tom\", \"Sam\", \"Bob\", \"Mike\")\nval employees = setOf(\"Tom\", \"Sam\", \"Kate\", \"Alice\")\n \n//  объединение множеств\nval all = people.union(employees)\n// пересечение множеств\nval common = people.intersect(employees)\n// вычитание множеств\nval different = people.subtract(employees)\n \nprintln(all)        // [Tom, Sam, Bob, Mike, Kate, Alice]\nprintln(common)     // [Tom, Sam]\nprintln(different)  // [Bob, Mike]"
          },
          {
            "type": "text",
            "content": "Причем данные методы можно применять как обычные операции:"
          },
          {
            "type": "code",
            "content": "//  объединение множеств\nval all = people union employees\n// пересечение множеств\nval common = people intersect employees\n// вычитание множеств\nval different = people subtract employees"
          },
          {
            "type": "subtitle",
            "content": "\nИзменяемые коллекции"
          },
          {
            "type": "text",
            "content": "Изменяемые (mutable) наборы представлены интерфейсом MutableSet, который расширяет интерфейсы Set и MutableCollection, соответственно поддерживает методы по изменению коллекции."
          },
          {
            "type": "text",
            "content": "Для создания изменяемых (mutable) наборов применяется функция mutableSetOf()."
          },
          {
            "type": "code",
            "content": "val numbers: MutableSet<Int> = mutableSetOf(35, 36, 37)"
          },
          {
            "type": "text",
            "content": "Интерфейс MutableSet реализуется следующими типами изменяемых наборов:"
          },
          {
            "type": "text",
            "content": "\t• LinkedHashSet: объединяет возможности хеш-таблицы и связанного списка. Создается с помощью функции linkedSetOf()."
          },
          {
            "type": "text",
            "content": "\t• HashSet: представляет хеш-таблицу. Создается с помощью функции hashSetOf()."
          },
          {
            "type": "code",
            "content": "val numbers1: HashSet<Int> = hashSetOf(5, 6, 7)\nval numbers2: LinkedHashSet<Int> = linkedSetOf(25, 26, 27)\nval numbers3: MutableSet<Int> = mutableSetOf(35, 36, 37)"
          },
          {
            "type": "text",
            "content": "Изменение набора с помощьюMutableSet:"
          },
          {
            "type": "code",
            "content": "val numbers: MutableSet<Int> = mutableSetOf(35, 36, 37)\nprintln(numbers.add(2))\nprintln(numbers.addAll(setOf(4, 5, 6)))\nprintln(numbers.remove(36))\n     \nfor (n in numbers){ println(n) }    // 35 37 2 4 5 6\nnumbers.clear()"
          }
        ]
      },
      {
        "id": 3,
        "title": "Map",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Map"
          },
          {
            "type": "text",
            "content": "Коллекция Map представляет коллекцию объектов, где каждый элемент имеет ключ и сопоставляемое с ним значение. \nПри этом все ключи в коллекции являются уникальными. В отличие от List и Set интерфейс Map не расширяет интерфейс Collection."
          },
          {
            "type": "text",
            "content": "Map представляет неизменяемую коллекцию, для создания которой применяется метод mapOf()."
          },
          {
            "type": "code",
            "content": "val people = mapOf(1 to \"Tom\", 5 to \"Sam\", 8 to \"Bob\")"
          },
          {
            "type": "text",
            "content": "Функция mapOf принимает набор элементов, каждый из которых с помощью оператора to сопоставляет ключ со значением, например, 1 to \"Tom\" . В данном случае переменная people представляет объект Map<Int, String>, где первый тип - Int представляет тип ключей, а второй тип - String представляет тип значений."
          },
          {
            "type": "text",
            "content": "Для перебора Map можно использовать цикл for, при этом каждый элемент будет представлять объект Map.Entry<K, V>. Через его свойство key можно получить ключ, а с помощью value- значение:"
          },
          {
            "type": "code",
            "content": "val people = mapOf(1 to \"Tom\", 5 to \"Sam\", 8 to \"Bob\")\nfor(person in people){\n    println(\"${person.key} - ${person.value}\")\n}\nprintln(people)     // {1=Tom, 5=Sam, 8=Bob}"
          },
          {
            "type": "text",
            "content": "Консольный вывод:"
          },
          {
            "type": "code",
            "content": "1 - Tom\n5 - Sam\n8 - Bob\n{1=Tom, 5=Sam, 8=Bob}"
          },
          {
            "type": "subtitle",
            "content": "\nОбращение к элементам Map"
          },
          {
            "type": "text",
            "content": "Для получения элементов по ключу может применяться метод get(), в который передается ключ элемента:"
          },
          {
            "type": "code",
            "content": "val dictionary = mapOf(\"red\" to \"красный\", \"blue\" to \"синий\", \"green\" to \"зеленый\")\nval blue = dictionary.get(\"blue\")\nprintln(blue)   // синий"
          },
          {
            "type": "text",
            "content": "В данном случае переменная dictionary представляет объект Map<String, String>, где ключи представляют строки, а значения - то же строки (условный перевод слова). Для получения значения по ключу \"blue\", применяется выражение dictionary.get(\"blue\")"
          },
          {
            "type": "text",
            "content": "Также можно сократить получение элемента с помощью квадратных скобок:"
          },
          {
            "type": "code",
            "content": "val dictionary = mapOf(\"red\" to \"красный\", \"blue\" to \"синий\", \"green\" to \"зеленый\")\nval blue = dictionary[\"blue\"]\nprintln(blue)   // синий"
          },
          {
            "type": "text",
            "content": "Если в Map нет элемента с указанным ключом, то возвращается null:"
          },
          {
            "type": "code",
            "content": "val yellow = dictionary.get(\"yellow\")\n// либо так \n// val yellow = dictionary[\"yellow\"]\nprintln(yellow)   // null"
          },
          {
            "type": "text",
            "content": "Такое поведение не всегда может быть предпочтительно. И в этом случае можно использовать пару других методов для получения элементов. \nТак, метод getOrDefault() позволяет задать значение по умолчанию, которое будет возврашаться, если по указанному ключу нет элементов:"
          },
          {
            "type": "code",
            "content": "val dictionary = mapOf(\"red\" to \"красный\", \"blue\" to \"синий\", \"green\" to \"зеленый\")\nval yellow = dictionary.getOrDefault(\"yellow\", \"Undefined\")\nprintln(yellow)   // Undefined\nval blue = dictionary.getOrDefault(\"blue\", \"Undefined\")\nprintln(blue)   // синий"
          },
          {
            "type": "text",
            "content": "Еще один метод - getOrElse() в качестве второго параметра принимает функцию, которая задает значение на случай, если по указанному ключу нет элементов:"
          },
          {
            "type": "code",
            "content": "val dictionary = mapOf(\"red\" to \"красный\", \"blue\" to \"синий\", \"green\" to \"зеленый\")\nval yellow = dictionary.getOrElse(\"yellow\"){\"Not found\"}\nprintln(yellow)   // Not found\nval blue = dictionary.getOrElse(\"blue\"){\"Not found\"}\nprintln(blue)   // синий"
          },
          {
            "type": "text",
            "content": "Кроме получения отдельных элементов Map позволяет получить отдельно ключи и значения с помощью свойств :"
          },
          {
            "type": "code",
            "content": "val dictionary = mapOf(\"red\" to \"красный\", \"blue\" to \"синий\", \"green\" to \"зеленый\")\nprintln(dictionary.values)  // [красный, синий, зеленый]\nprintln(dictionary.keys)   // [red, blue, green]"
          },
          {
            "type": "text",
            "content": "Также с помощью методов containsKey() и containsValue() можно проверить наличие в Map определенного ключа и значения соответственно:"
          },
          {
            "type": "code",
            "content": "val dictionary = mapOf(\"red\" to \"красный\", \"blue\" to \"синий\", \"green\" to \"зеленый\")\nprintln(dictionary.containsKey(\"blue\"))     // true\nprintln(dictionary.containsKey(\"yellow\"))  // false\n \nprintln(dictionary.containsValue(\"желтый\"))    // false\nprintln(dictionary.containsValue(\"зеленый\"))  // true"
          },
          {
            "type": "subtitle",
            "content": "\nMutableMap"
          },
          {
            "type": "text",
            "content": "Изменяемые коллекции представлены интерфейсом MutableMap, который расширяет интерфейс Map. \nДля создания объекта MutableMap применяется функция mutableMapOf()."
          },
          {
            "type": "code",
            "content": "val people = mutableMapOf(220 to \"Tom\", 225 to \"Sam\", 228 to \"Bob\") // MutableMap<Int, String>"
          },
          {
            "type": "text",
            "content": "Интерфейс MutableMap реализуется рядом коллекций:"
          },
          {
            "type": "text",
            "content": "\t• HashMap: простейшая реализация интерфейса MutableMap, не гарантирует порядок элементов в коллекции. Создается функцией hashMapOf()"
          },
          {
            "type": "text",
            "content": "\t• LinkedHashMap: представляет комбинацию HashMap и связанного списка, создается функцией linkedMapOf()"
          },
          {
            "type": "code",
            "content": "val linkedMap = linkedMapOf(220 to \"Tom\", 225 to \"Sam\", 228 to \"Bob\")  // объект типа LinkedHashMap<Int, String>\nval hashMap = hashMapOf(220 to \"Tom\", 225 to \"Sam\", 228 to \"Bob\")   // объект типа HashMap<Int, String>"
          },
          {
            "type": "text",
            "content": "Для изменения Map можно применять ряд методов:"
          },
          {
            "type": "text",
            "content": "\t• put(key: K, value: V): добавляет элемент с ключом key и значением value"
          },
          {
            "type": "text",
            "content": "\t• putAll(): добавляет набор объектов типаPair<K, V>. В качестве такого набора могут выступать объекты Iterable, Sequence и Array"
          },
          {
            "type": "text",
            "content": "\t• set(key: K, value: V): устанавливает для элемента с ключом key значение value"
          },
          {
            "type": "text",
            "content": "\t• remove(key: K): V?: удаляет элемент с ключом key. Если удаление успешно произведено, то возвращается значение удаленного элемента, иначе возвращается null."
          },
          {
            "type": "text",
            "content": "\t  Дополнительная версия метода"
          },
          {
            "type": "code",
            "content": "remove(key: K, value: V): Boolean"
          },
          {
            "type": "text",
            "content": "удаляет элемент с ключом key, если он имеет значение value, и возвращает true, если элемент был успешно удален"
          },
          {
            "type": "text",
            "content": "Добавление данных:"
          },
          {
            "type": "code",
            "content": "val people = mutableMapOf(1 to \"Tom\", 2 to \"Sam\", 3 to \"Bob\")\n \n// добавляем один элемент с ключом 229 и значением Mike\npeople.put(229, \"Mike\")\nprintln(people)     // {1=Tom, 2=Sam, 3=Bob, 229=Mike}\n \n// добавляем другую коллекцию\nval employees = mapOf(301 to \"Kate\", 302 to \"Bill\")\npeople.putAll(employees)\nprintln(people)     // {1=Tom, 2=Sam, 3=Bob, 229=Mike, 301=Kate, 302=Bill}"
          },
          {
            "type": "text",
            "content": "Изменение данных:"
          },
          {
            "type": "code",
            "content": "val people = mutableMapOf(1 to \"Tom\", 2 to \"Sam\", 3 to \"Bob\")\n \n// изменяем элемент с ключом 1\npeople.set(1, \"Tomas\")\nprintln(people) // {1=Tomas, 2=Sam, 3=Bob}"
          },
          {
            "type": "text",
            "content": "Вместо метода set для установки значения могут применяться квадратные скобки, в которые передается ключ элемента:"
          },
          {
            "type": "code",
            "content": "val people = mutableMapOf(1 to \"Tom\", 2 to \"Sam\", 3 to \"Bob\")\n \n// изменяем элемент с ключом 1\npeople[1] = \"Tomas\"\nprintln(people) // {1=Tomas, 2=Sam, 3=Bob}\n// изменяем элемент с ключом 5\npeople[5] = \"Adam\"\nprintln(people) // {1=Tomas, 2=Sam, 3=Bob, 5=Adam}"
          },
          {
            "type": "text",
            "content": "Причем если с указанным ключом нет элемента, то он добавляется, как в примере выше в случае с ключом 5."
          },
          {
            "type": "text",
            "content": "Удаление данных:"
          },

          {
            "type": "code",
            "content": "val people = mutableMapOf(1 to \"Tom\", 2 to \"Sam\", 3 to \"Bob\")\n \n// удаляем элемент с ключом 1\npeople.remove(1)\nprintln(people) // {2=Sam, 3=Bob}\n     \n// удаляем элемент с ключом 3, если его значение - \"Alice\"\npeople.remove(3, \"Alice\")\nprintln(people) // {2=Sam, 3=Bob}\n \n// удаляем элемент с ключом 3, если его значение - \"Bob\"\npeople.remove(3, \"Bob\")\nprintln(people) // {2=Sam}"
          }
        ]
      },
      {
        "id": 4,
        "title": "Последовательности",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Последовательности в Kotlin"
          },
          {
            "type": "text",
            "content": "Sequence<T> — это интерфейс в стандартной библиотеке Kotlin, предназначенный для ленивой обработки коллекций. \n\nВ отличие от обычных коллекций (List, Set), последовательности не хранят все элементы в памяти, а вычисляют их по мере необходимости. \nЭто позволяет эффективно обрабатывать большие или потенциально бесконечные наборы данных."
          },
          {
            "type": "subtitle",
            "content": "\nСоздание последовательностей"
          },
          {
            "type": "text",
            "content": "Создать последовательность можно несколькими способами:"
          },
          {
            "type": "text",
            "content": "\t• sequenceOf(\"a\", \"b\", \"c\") — создаёт последовательность из заданных элементов."
          },
          {
            "type": "text",
            "content": "\t• listOf(1, 2, 3).asSequence() — преобразует существующую коллекцию в последовательность."
          },
          {
            "type": "text",
            "content": "\t• generateSequence { ... } — создаёт потенциально бесконечную последовательность."
          },
          {
            "type": "text",
            "content": "\t• sequence { yield(...) } — использует корутины для генерации элементов."
          },
          {
            "type": "subtitle",
            "content": "\nЛенивые вычисления и типы операций"
          },
          {
            "type": "text",
            "content": "Последовательности поддерживают два типа операций:"
          },
          {
            "type": "text",
            "content": "\t• Промежуточные (intermediate) — возвращают новую последовательность и не выполняются сразу (например, map, filter, distinct)."
          },
          {
            "type": "text",
            "content": "\t• Терминальные (terminal) — завершают цепочку операций и инициируют выполнение (например, toList, first, count)."
          },
          {
            "type": "text",
            "content": "Благодаря ленивым вычислениям, последовательности обрабатывают элементы по одному, что повышает производительность при сложных цепочках преобразований."
          },
          {
            "type": "subtitle",
            "content": "\nПример: сравнение с коллекциями"
          },
          {
            "type": "text",
            "content": "Рассмотрим пример обработки чисел от 1 до 10:"
          },
          {
            "type": "code",
            "content": "val result = (1..10)\n    .asSequence()\n    .filter { it % 2 == 1 }\n    .map { it * 2 }\n    .take(2)\n    .toList()\n"
          },
          {
            "type": "text",
            "content": "В этом примере:"
          },
          {
            "type": "text",
            "content": "\t• filter выбирает нечётные числа."
          },
          {
            "type": "text",
            "content": "\t• map удваивает их."
          },
          {
            "type": "text",
            "content": "\t• take(2) берёт первые два результата."
          },
          {
            "type": "text",
            "content": "Благодаря последовательности, операции выполняются по одному элементу, что эффективнее по сравнению с коллекциями, где каждое преобразование создаёт новую промежуточную коллекцию."
          },
          {
            "type": "subtitle",
            "content": "\nКогда использовать последовательности"
          },
          {
            "type": "text",
            "content": "Использование последовательностей оправдано в следующих случаях:"
          },
          {
            "type": "text",
            "content": "\t• Обработка больших объёмов данных, где важно избежать создания промежуточных коллекций."
          },
          {
            "type": "text",
            "content": "\t• Работа с потенциально бесконечными источниками данных."
          },
          {
            "type": "text",
            "content": "\t• Ситуации, где важна производительность при цепочках преобразований."
          },
          {
            "type": "text",
            "content": "Однако следует учитывать, что последовательности не всегда эффективнее коллекций, особенно при небольших объёмах данных, из-за накладных расходов на создание объектов."
          },
          {
            "type": "subtitle",
            "content": "\nПолезные функции последовательностей"
          },
          {
            "type": "text",
            "content": "Kotlin предоставляет множество функций для работы с последовательностями:"
          },
          {
            "type": "text",
            "content": "\t• map, filter, flatMap, distinct, sorted, take, drop, zip, chunked, windowed, groupBy, associate, sumOf, count, first, last, single, any, all, none."
          },
          {
            "type": "text",
            "content": "Полный список доступен в официальной документации:"
          },
          {
            "type": "url",
            "content": "https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.sequences/?utm_source=chatgpt.com"
          }
        ]
      },
      {
        "id": 5,
        "title": "Массивы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Массивы"
          },
          {
            "type": "text",
            "content": "Массивы во многом аналогичны коллекциям. \nМассивы характеризуются постоянной длиной, соответственно  мы не можем динамически добавлять или удалять элементы из массива. Но мы можем изменять значение уже имеющихся элементов."
          },
          {
            "type": "text",
            "content": "Для создания массива применяется функция arrayOf():"
          },
          {
            "type": "code",
            "content": "val numbers = arrayOf(1, 2, 3, 4, 5)     // объект Array<Int>\nval people = arrayOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")   // объект Array<String>"
          },
          {
            "type": "text",
            "content": "В этом случае тип элементов массива будет выводиться из типа значений из функции arrayOf()"
          },
          {
            "type": "text",
            "content": "Встроенная функция arrayOfNulls() позволяет создать массив из элементов, каждый из который имеет значение  null - то есть фактически не установленное значение. В эту функцию передается количество элементов:"
          },
          {
            "type": "code",
            "content": "val numbers = arrayOfNulls<Int>(3)  // [null, null, null]"
          },
          {
            "type": "text",
            "content": "После названия функции в угловых скобках указывается тип элементов массива. \nТак, в примере выше это тип Int. В данном случае создается массив из трех элементов,  каждый из которых равен по умолчанию null, то есть не имеет никакого значения."
          },
          {
            "type": "text",
            "content": "Также имеется еще один способ создать массив и инициализировать его значениями:"
          },
          {
            "type": "code",
            "content": "val numbers = Array(3, {5}) // [5, 5, 5]"
          },
          {
            "type": "text",
            "content": "Здесь применяется конструктор класса Array. В этот конструктор передаются два значения.  \nПервое значение - число 3 - указывает, сколько элементов будет в массиве. В данном случае 3 элемента.  \nВторое значение - число 5 представляет выражение, которое генерирует элементы массива. Оно заключается в фигурные скобки. Таким образом, массив будет состоять из трех пятерок."
          },
          {
            "type": "text",
            "content": "Но выражение, которое создает элементы массива, может быть и более сложным. Например:"
          },
          {
            "type": "code",
            "content": "var i = 1;\nval numbers = Array(3, { i++ * 2}) // [2, 4, 6]"
          },
          {
            "type": "text",
            "content": "В данном случае элемент массива является результатом умножения переменной i на 2. При этом при каждом обращении к переменой i ее значение увеличивается на единицу."
          },
          {
            "type": "subtitle",
            "content": "\nОбращение к элементам массива"
          },
          {
            "type": "text",
            "content": "Для получения элемента по индексу можно применять метод get(index), который возвращает элемент по индексу"
          },
          {
            "type": "code",
            "content": "val people = arrayOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")\nval first = people.get(0)\nval second = people.get(1)\nprintln(first)      // Tom\nprintln(second)     // Sam"
          },
          {
            "type": "text",
            "content": "Вместо метода get для обращения по индексу можно использовать квадратные скобки []:"
          },
          {
            "type": "code",
            "content": "val people = arrayOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")\nval first = people[0]\nval second = people[1]\nprintln(first)      // Tom\nprintln(second)     // Sam"
          },
          {
            "type": "text",
            "content": "Однако, если индекс выходит за границы списка, то при использовании метода  get() и квадратных скобок генерируется исключение. \nЧтобы избежать подобной ситуации, можно применять метод getOrNull(), который возвращает null, если индекс находится вне границ списка:"
          },
          {
            "type": "code",
            "content": "val people = arrayOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")\nval first = people.getOrNull(0)\nval tenth = people.getOrNull(10)\nprintln(first)      // Tom\nprintln(tenth)     // null"
          },
          {
            "type": "text",
            "content": "Либо в качестве альтернативы можно применять метод getOrElse():"
          },
          {
            "type": "code",
            "content": "getOrElse(index: Int, defaultValue: (Int) -> T): T"
          },
          {
            "type": "text",
            "content": "Первый параметр представляет индекс, а второй параметр - функция, которая получает запрошенный индекс и возвращает значение, которое возвращается, если индекс выходит  за границы списка:"
          },
          {
            "type": "code",
            "content": "val people = arrayOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")\nval first = people.getOrElse(0){\"Undefined\"}\nval seventh = people.getOrElse(7){\"Invalid index $it\"}\nval tenth = people.getOrElse(10){\"Undefined\"}\n     \nprintln(first)      // Tom\nprintln(seventh)    // Invalid index 7\nprintln(tenth)     // Undefined"
          },
          {
            "type": "text",
            "content": "Также подобный метод может быть полезен, если массив изначально создан с помощью функции arrayOfNulls и может содержать null, и мы хотим в этом случае возвратить некоторое значение по умолчанию"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val people = arrayOfNulls<String>(3)  // [null, null, null]\n    people[0] = \"Tom\"\n    people[1] = \"Bob\"\n    val first = people.getOrElse(0){\"Undefined\"}\n    val last = people.getOrElse(2){\"Undefined\"}\n \n    println(first)      // Tom\n    println(last)     // Undefined\n}"
          },
          {
            "type": "text",
            "content": "Для установки значений элементов можно применять метод set(index, value), который принимает индекс элемента и новое значение, или просто индексы:"
          },
          {
            "type": "code",
            "content": "val people = arrayOf(\"Tom\", \"Bob\", \"Sam\")\npeople.set(0, \"Tomas\")\npeople[1] = \"Robert\"\nprintln(people[0])  // \"Tomas\"\nprintln(people[1])  // \"Robert\""
          },
          {
            "type": "subtitle",
            "content": "\nСвойства массива"
          },
          {
            "type": "text",
            "content": "Для работы с массивами класс Array предоставляет три свойства:"
          },
          {
            "type": "text",
            "content": "\t• size: размер массива"
          },
          {
            "type": "text",
            "content": "\t• lastIndex: индекс последнего элемента массива, тоже самое, что и size - 1"
          },
          {
            "type": "text",
            "content": "\t• indices: диапазон индексов элементов массива"
          },
          {
            "type": "text",
            "content": "Каждый массив имеет свойство size, которое хранит количество элементов массива:"
          },
          {
            "type": "code",
            "content": "val people = arrayOf(\"Tom\", \"Bob\", \"Sam\")\nprintln(people.size)  // 3\nprintln(people.lastIndex)  // 2\nprintln(people.indices)     // 0..2"
          },
          {
            "type": "subtitle",
            "content": "\nПеребор массивов"
          },
          {
            "type": "text",
            "content": "Для перебора массивов можно применять цикл for:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val numbers = arrayOf(1, 2, 3, 4, 5)\n    for(number in numbers){\n        print(\"$number \\t\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае переменная numbers представляет массив чисел. При переборе этого массива в цикле каждый его элемент оказывается в переменной number,  значение которой, к примеру, можно вывести на консоль. Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "1  2  3  4  5"
          },
          {
            "type": "text",
            "content": "Подобным образом можно перебирать массивы и других типов:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val people = arrayOf(\"Tom\", \"Sam\", \"Bob\")\n    for(person in people){\n        print(\"$person \\t\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Tom   Sam   Bob"
          },
          {
            "type": "text",
            "content": "Также при переборе мы можем использовать индексы для обращения к элементам массива:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    val people = arrayOf(\"Tom\", \"Sam\", \"Bob\")\n    for(i in 0..people.lastIndex){\n        println(\"${i+1} - ${people[i]}\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае мы перебираем не сам массив people, а последовательность чисел от 0 до people.lastIndex, то есть фактически от 0 до 2. Каждое число из этой последовательности попадает  в переменную i. Затем получаем каждый элемент массива с помощью выражения people[i]"
          },
          {
            "type": "text",
            "content": "Может показаться, что последний способ перебора избыточен - мы же напрямую можем перебрать массив, использовав выражение for(person in people). \nОднако что, если мы хотим  изменить все элементы массива? Например, следующим образом:"
          },
          {
            "type": "code",
            "content": "val numbers = arrayOf(2, 3, 4)\nfor(n in numbers){\n    n = n * n       // так нельзя изменить\n}"
          },
          {
            "type": "text",
            "content": "В данном случае мы хотим, чтобы в массиве каждое число было заменено квадратом этого числа. Однако написать, как в примере выше мы не можем."
          },
          {
            "type": "text",
            "content": "Теперь изменим подход:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    val numbers = arrayOf(2, 3, 4)\n    // заменяем число в массиве его квадратом\n    for(i in 0..numbers.lastIndex){\n        numbers[i] = numbers[i] * numbers[i]\n    }\n \n    // проверяем массив\n    for(n in numbers){\n        print(\"$n \\t\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "4 \t9 \t16 "
          },
          {
            "type": "text",
            "content": "Для упрощения перебора индексов элементов массива каждый массив предоставляет свойство indices, который представляет последовательность всех индексов начиная с 0 и  которое мы также можем перебрать:"
          },
          {
            "type": "code",
            "content": "for (i in people.indices) {\n    println(people[i])\n}\n \nval numbers = arrayOf(2, 3, 4)\nfor(i in numbers.indices){\n    numbers[i] = numbers[i] * numbers[i]\n    print(\"${numbers[i]} \\t\")\n}"
          },
          {
            "type": "text",
            "content": "Можно применять и другие типы циклов для перебора массива. Например, используем цикл while:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val people = arrayOf(\"Tom\", \"Sam\", \"Bob\")\n     \n    var i = 0\n    while( i in people.indices){\n        println(people[i])\n        i++;\n    }\n}"
          },
          {
            "type": "text",
            "content": "Также для перебора можно использовать функцию расширения forEach(). Она принимает функцию-коллбек, параметр которой представляет каждый элемент массива:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val people = arrayOf(\"Tom\", \"Bob\", \"Sam\")\n    people.forEach { p->println(p) }\n}"
          },
          {
            "type": "text",
            "content": "Для перебора вместе с индексами можно использовать функцию forEachIndexed(). Она принимает функцию с двумя параметрами: индексом элемента и самим элементом:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val people = arrayOf(\"Tom\", \"Bob\", \"Sam\")\n    people.forEachIndexed { i, p->println(\"$i. $p\") }\n}"
          },
          {
            "type": "text",
            "content": "Консольный вывод:"
          },
          {
            "type": "code",
            "content": "0. Tom\n1. Bob\n2. Sam"
          },
          {
            "type": "subtitle",
            "content": "\nДвухмерные массивы"
          },
          {
            "type": "text",
            "content": "Выше рассматривались одномерные массивы, которые можно представить в виде ряда или строки значений. Но кроме того, мы можем использовать многомерные массивы. \nК примеру, возьмем двухмерный массив - то есть такой массив, каждый элемент которого в свою очередь сам является массивом. \nДвухмерный массив  еще можно представить в виде таблицы, где каждая строка - это отдельный массив, а ячейки строки - это элементы вложенного массива."
          },
          {
            "type": "text",
            "content": "Определение двухмерных массивов менее интуитивно понятно и может вызывать сложности. Например, двухмерный массив чисел:"
          },
          {
            "type": "code",
            "content": "val table: Array<Array<Int>> = Array(3, { Array(5, {0}) })"
          },
          {
            "type": "text",
            "content": "В данном случае двухмерный массив будет иметь три элемента - три строки. Каждая строка будет иметь по пять элементов, каждый из которых равен 0."
          },
          {
            "type": "text",
            "content": "Используя индексы, можно обращаться к подмассивам в подобном массиве, в том числе переустанавливать их значения:"
          },
          {
            "type": "code",
            "content": "val table = Array(3, { Array(3, {0}) })\ntable[0] = arrayOf(1, 2, 3)     // первая строка таблицы\ntable[1] = arrayOf(4, 5, 6)     // вторая строка таблицы\ntable[2] = arrayOf(7, 8, 9)     // третья строка таблицы"
          },
          {
            "type": "text",
            "content": "Для обращения к элементам подмассивов двухмерного массива необходимы два индекса. По первому индексу идет получение строки, а по второму индексу -  столбца в рамках этой строки:"
          },
          {
            "type": "code",
            "content": "val table = Array(3, { Array(3, {0}) })\ntable[0][1] = 6  // второй элемент первой строки\nval n = table[0][1]     // n = 6"
          },
          {
            "type": "text",
            "content": "Используя два цикла, можно перебирать двухмерные массивы:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val table: Array<Array<Int>> = Array(3, { Array(3, {0}) })\n    table[0] = arrayOf(1, 2, 3)\n    table[1] = arrayOf(4, 5, 6)\n    table[2] = arrayOf(7, 8, 9)\n    for(row in table){\n \n        for(cell in row){\n            print(\"$cell \\t\")\n        }\n        println()\n    }\n}"
          },
          {
            "type": "text",
            "content": "С помощью внешнего цикла \nfor(row in table) \nпробегаемся по всем элементам двухмерного массива, то есть по строкам таблицы.  \nКаждый из элементов двухмерного массива сам представляет массив, поэтому мы можем пробежаться по этому массиву и получить из него непосредственно те значения,  которые в нем хранятся. \nВ итоге на консоль будет выведено следующее:"
          },
          {
            "type": "code",
            "content": "1 \t2 \t3 \t\n4 \t5 \t6 \t\n7 \t8 \t9"
          }
        ]
      },
      {
        "id": 6,
        "title": "Последовательности и коллекции",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Отличие последовательности от коллекций"
          },
          {
            "type": "text",
            "content": "И последовательности, и коллекции, которые реализуют интерфейс Iterable, по сути представляют набор элементов. Более того предоставляют  похожий набор операций для обработки элементов. \nНо отличие состоит, как эти операции обрабатывают элементы при применении сразу нескольких  операций."
          },
          {
            "type": "text",
            "content": "Так, при применении набора операций к коллекции Iterable каждая отдельная операция возвращает промежуточный результат -  промежуточную коллекцию. А при обработке последовательности весь набор операций выполняется только тогда,  когда требуется конечный результат обработки."
          },
          {
            "type": "text",
            "content": "Также меняется порядок применения операций. \nКоллекция применяет каждую операцию последовательно к каждому элементу. То есть сначала выполняет первую операцию для всех элементов, потом вторую операцию  для элементов коллекции, полученных после первой операции. И так далее."
          },
          {
            "type": "text",
            "content": "Последовательность применяет весь набор операций отдельно к каждому элементу. \nТо есть сначала весь набор операций применяется к первому элементу,  потом ко второму элементу и так далее. \nТаким образом, последовательность позволяет избежать создания помежуточных коллекций и в тоже  время повышают производительность при выполнении набора операций особенно для большого набора данных.  \nОднако при небольших наборах данных и малом количестве операций может быть эффективнее использовать коллекции Iterable."
          },
          {
            "type": "text",
            "content": "Рассмотрим на примере. Сначала возьмем коллекции Iterable (в данном случае List):"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    var people = listOf(\n        Person(\"Tom\", 37),\n        Person(\"Sam\", 25),\n        Person(\"Alice\", 33)\n    )\n    people = people.filter { println(\"Age filter: ${it}\"); it.age > 30 }\n                    .filter{ println(\"Name filter: ${it}\"); it.name.length == 3 }\n    println(\"Result:\")\n    for(person in people) println(person)\n}\ndata class Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "Здесь создается коллекция - список people (объект типа List), который содержит объекты Person. Далее к этому списку применяются две операции фильтрации в виде  метода filter(). Сначала получаем все объекты Person, у которых свойство age больше 30:"
          },
          {
            "type": "code",
            "content": "people.filter { println(\"Age filter: ${it}\"); it.age > 30 }"
          },
          {
            "type": "text",
            "content": "Эта операция filter() возвратит промежуточную коллекцию, которая содержит все объекты Person с возрастом больше 30. Для наглядности здесь логгируются на консоль объекты, к которым применяется операция."
          },
          {
            "type": "text",
            "content": "Затем выполняется вторая операция filter() - она возвращает из промежуточной коллекции те объекты Person,  у которых длина свойства name равна 3."
          },
          {
            "type": "code",
            "content": "filter{ println(\"Name filter: ${it}\"); it.name.length == 3 }"
          },
          {
            "type": "text",
            "content": "Опять же для наглядности здесь логгируются на консоль объекты, к которым применяется операция."
          },
          {
            "type": "text",
            "content": "Результатом будет вторая коллекция, которая будет присвоена переменной people и которую в  конце с помощью цикла foreach выводится на консоль. В итоге мы получим следующий консольный вывод:"
          },
          {
            "type": "code",
            "content": "Age filter: Person(name=Tom, age=37)\nAge filter: Person(name=Sam, age=25)\nAge filter: Person(name=Alice, age=33)\nName filter: Person(name=Tom, age=37)\nName filter: Person(name=Alice, age=33)\nResult:\nPerson(name=Tom, age=37)"
          },
          {
            "type": "text",
            "content": "Здесь мы видим, что первая операция filter пробегается по всем элементам в начальной коллекции и возвращает коллекцию с двумя  элементами. Вторая операция filter пробегается по полученной коллекции из двух элементов и возвращает коллекцию из одного элемента."
          },
          {
            "type": "text",
            "content": "\nТеперь вместо коллекций применим последовательности:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    var people = sequenceOf(\n        Person(\"Tom\", 37),\n        Person(\"Sam\", 25),\n        Person(\"Alice\", 33)\n    )\n    people = people.filter { println(\"Age filter: ${it}\"); it.age > 30 }\n                    .filter{ println(\"Name filter: ${it}\"); it.name.length == 3 }\n    println(\"Result:\")\n    for(person in people) println(person)\n}\ndata class Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "Здесь абсолютно такой же код, как и в предыдущем примере, только переменная people теперь представляет последовательность  объектов Person. Однако консольный вывод будет совершенно иным:"
          },
          {
            "type": "code",
            "content": "Result:\nAge filter: Person(name=Tom, age=37)\nName filter: Person(name=Tom, age=37)\nPerson(name=Tom, age=37)\nAge filter: Person(name=Sam, age=25)\nAge filter: Person(name=Alice, age=33)\nName filter: Person(name=Alice, age=33)"
          },
          {
            "type": "text",
            "content": "Во-первых, обратите внимание, что строка  \"Result:\" выводится до выполнения всех операций. Потому что получение результата  фактически происходит в цикле for при обращении к последовательности. До этого нет смысла выполнять операции, если элементы  последовательности никак не используются."
          },
          {
            "type": "text",
            "content": "Во-вторых, также обратите внимание на применение операций к элементам."
          },
          {
            "type": "text",
            "content": "\t• Сначала обрабатывается первый элемент -  Person(name=Tom, age=37). Поскольку он соответствует обоим фильтрам, то он в конечном счете выводится на консоль в цикле for."
          },
          {
            "type": "text",
            "content": "\t• Далее обрабатывается второй элемент - Person(name=Sam, age=25), однако после применения первой операции filter его обработка завершается,  поскольку он не соответствует условию первого фильтра"
          },
          {
            "type": "text",
            "content": "\t• В конце обрабатывается третий элемент - Person(name=Alice, age=33), к нему применяются две операции filter,  но затем его обработка завершается, поскольку он не соответствует условию второго фильтра"
          },
          {
            "type": "text",
            "content": "Получение элементов последовательности происходит, когда идет непосредственное обращение к элементам последовательности. Например,  мы можем изменить предыдущий пример следующим образом:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    var people = sequenceOf(\n        Person(\"Tom\", 37),\n        Person(\"Sam\", 25),\n        Person(\"Alice\", 33)\n    )\n    people = people.filter { println(\"Age filter: ${it}\"); it.age > 30 }\n    println(\"Between Age filter and Name filter\")\n    people = people.filter{ println(\"Name filter: ${it}\"); it.name.length == 3 }\n    for(person in people) println(person)\n}\ndata class Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "Здесь результат каждого фильтра присваивается переменной people. А между фильтрами идет вывод сообщения на консоль. \nНо все равно,  поскольку непосредственное получение элементов последовательности происходит в цикле for, то именно в этой точке кода будут выполняться  все операции с последовательностью, что можно увидеть из консольного вывода:"
          },
          {
            "type": "code",
            "content": "Between Age filter and Name filter\nAge filter: Person(name=Tom, age=37)\nName filter: Person(name=Tom, age=37)\nPerson(name=Tom, age=37)\nAge filter: Person(name=Sam, age=25)\nAge filter: Person(name=Alice, age=33)\nName filter: Person(name=Alice, age=33)"
          },
          {
            "type": "subtitle",
            "content": "\nСокращение набора операций"
          },
          {
            "type": "text",
            "content": "Применение последовательностей может значительно сократить количество применяемых операций. Например:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    var people = listOf(\n        Person(\"Tom\", 37),\n        Person(\"Sam\", 25),\n        Person(\"Alice\", 33)\n    )\n    people = people.filter { println(\"Age filter: ${it}\"); it.age > 30 }\n                    .take(1)\n    for(person in people) println(person)\n \n}\ndata class Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "Здесь опять же к списку people применяется фильтр по возрасту и затем с помощью вызова take(1) выбираем один объект  в результирующую коллекцию. И в этом случае мы получим следующий консольный вывод:"
          },
          {
            "type": "code",
            "content": "Age filter: Person(name=Tom, age=37)\nAge filter: Person(name=Sam, age=25)\nAge filter: Person(name=Alice, age=33)\nPerson(name=Tom, age=37)"
          },
          {
            "type": "text",
            "content": "Здесь опять же мы видим, что вызов filter() применяется ко всем элементам, из которых формируется промежуточная  коллекция, из которой в итоге выбирается 1 объект."
          },
          {
            "type": "text",
            "content": "Изменим тип набора на последовательность:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    var people = sequenceOf(\n        Person(\"Tom\", 37),\n        Person(\"Sam\", 25),\n        Person(\"Alice\", 33)\n    )\n    people = people.filter { println(\"Age filter: ${it}\"); it.age > 30 }\n                    .take(1)\n    for(person in people) println(person)\n \n}\ndata class Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Age filter: Person(name=Tom, age=37)\nPerson(name=Tom, age=37)"
          },
          {
            "type": "text",
            "content": "Сначала обрабатывается первый объект - Person(name=Tom, age=37) - к нему применяется вызов  filter(). Поскольку этот объект соответствует фильтру, он переходит к примению вызова take(1).  \nЭтот вызов выбирает в результирующую коллекцию первый объект. Но поскольку результирующая коллекция должна содержать только 1 объект,  то остальные элементы последовательности нет смысла обрабатывать. И на этом обработка последовательности закончилась. \nТаким образом,  вместо 3 операций filter в данном случае мы получаем только 1. Соответственно на большем количестве данных и операций сокращение набора  операций может быть более значительным."
          }
        ]
      },
      {
        "id": 7,
        "title": "Фильтрация",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Фильтрация"
          },
          {
            "type": "subtitle",
            "content": "\nФильтрация по условию"
          },
          {
            "type": "text",
            "content": "Фильтрация является одной из распространенных операций. Для фильтрации по условию применяется функция filter(),  которая в качестве параметра принимает условие-предикат в виде функции (T) -> Boolean."
          },
          {
            "type": "code",
            "content": "filter(predicate: (T) -> Boolean): List<T>/Map<K, V>/Sequence<T>"
          },
          {
            "type": "text",
            "content": "Функция предиката принимает в качестве параметра элемент набора. Если элемент соответствует условию, то возвращается true, а данный  элемент помещается в возвращаемый набор."
          },
          {
            "type": "text",
            "content": "Для коллекций List и Set эта функция возвращает объект List, для Map - объект Map, для последовательностей Sequence - также объект Sequence:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    var people = sequenceOf(\"Tom\", \"Sam\", \"Mike\", \"Bob\", \"Alice\")\n    people = people.filter{it.length == 3}    // получаем значения с длиной в 3 символа\n    println(people.joinToString())  // Tom, Sam, Bob\n \n    var employees = listOf(\n        Person(\"Tom\", 37),\n        Person(\"Bob\", 41),\n        Person(\"Sam\", 25)\n    )\n    employees = employees.filter{it.age > 30} // получаем всех Person, у которых age > 30\n    println(employees.joinToString())  // Person(name=Tom, age=37), Person(name=Bob, age=41)\n}\ndata class Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "Если надо получить элементы, которые, наоборот, НЕ соответствует условию, то можно применить функцию filterNot(),  которая работает аналогично:"
          },
          {
            "type": "code",
            "content": "var people = sequenceOf(\"Tom\", \"Sam\", \"Mike\", \"Bob\", \"Alice\")\npeople = people.filterNot{it.length == 3}    // получаем значения с длиной, не равной 3 символам\nprintln(people.joinToString())  // Mike, Alice"
          },
          {
            "type": "subtitle",
            "content": "\nФильтрация по индексу"
          },
          {
            "type": "text",
            "content": "Еще одна функция - filterIndexed() также получает индекс текущего элемента:"
          },
          {
            "type": "code",
            "content": "filterIndexed(predicate: (index: Int, T) -> Boolean): List<T>"
          },
          {
            "type": "text",
            "content": "Например, получим из коллекции строк элементы с четными индексами и длиной в 3 символа:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Mike\", \"Sam\", \"Bob\", \"Alice\")\n// получаем значения с длиной в 3 символа на четных индексах\nval filtered = people.filterIndexed{ index, s -> (index % 2 == 0) && (s.length == 3)}\nprintln(filtered)  // [Tom, Sam]"
          },
          {
            "type": "subtitle",
            "content": "\nФильтрация по типу"
          },
          {
            "type": "text",
            "content": "Если коллекция/последовательность содержит элементы разных типов, то с помощью функции filterIsInstance()  можно извлечь элементы определенного типа. Например:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    val people = listOf(\n        Person(\"Tom\"), Employee(\"Bob\"),\n        Person(\"Sam\"), Employee(\"Mike\")\n    )\n    // получаем только элементы типа Employee\n    val employees = people.filterIsInstance<Employee>();\n    println(employees)  // [Bob, Mike]\n}\nopen class Person(val name: String){\n    override fun toString(): String  = name\n}\nclass Employee(name: String): Person(name)"
          },
          {
            "type": "text",
            "content": "В данном случае получаем из коллекции people только те объекты, которые представляют тип Employee. Чтобы указать тип получаемых объектов,  при вызове функция типизируется соответствующим типом."
          },
          {
            "type": "subtitle",
            "content": "\nФильтрация по null"
          },
          {
            "type": "text",
            "content": "Функция filterNotNull() позволяет выфильтровать все значение, которые равны null:"
          },
          {
            "type": "code",
            "content": "filterNotNull(): List<T>/Sequence<T>"
          },
          {
            "type": "text",
            "content": "Например:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    val people = listOf(Person(\"Tom\"), null, Person(\"Sam\"), null)\n    println(people)     // [Tom, null, Sam, null]\n    val filtered = people.filterNotNull()\n    println(filtered)  // [Tom, Sam]\n}\nopen class Person(val name: String){\n    override fun toString(): String  = name\n}"
          }
        ]
      },
      {
        "id": 8,
        "title": "Проверка элементов",
        "blocks": [
          {
            "type": "subtitle",
            "content": "\nПроверка элементов"
          },
          {
            "type": "subtitle",
            "content": "\nПроверка соответствия элементов условию"
          },
          {
            "type": "text",
            "content": "Отдельный вид операций позволяет проверить наличие элементов."
          },
          {
            "type": "text",
            "content": "Функция all проверяет, все ли элементы коллекции/последовательности соответствуют условию предиката:"
          },
          {
            "type": "code",
            "content": "all(predicate: (T) -> Boolean): Boolean"
          },
          {
            "type": "text",
            "content": "Функция предиката получает каждый элемент и возвращает true, если элемент соответствует условию."
          },
          {
            "type": "text",
            "content": "Функция any проверяет, соответствует хотя бы один элемент коллекции/последовательности условию предиката:"
          },
          {
            "type": "code",
            "content": "any(predicate: (T) -> Boolean): Boolean"
          },
          {
            "type": "text",
            "content": "Еще одна функция - none возвращает true, если ни один из элементов НЕ соответствует условию предиката:"
          },
          {
            "type": "code",
            "content": "none(predicate: (T) -> Boolean): Boolean"
          },
          {
            "type": "text",
            "content": "Проверка элементов на соответствие условию:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Kate\", \"Sam\", \"Alice\", \"Bob\")\n// all\nprintln(people.all{it.length == 3})     // false\nprintln(people.all{it.length != 10})     // true\n \n// none\nprintln(people.none{it.length == 3})     // false\nprintln(people.none{it.length == 2})     // true\n \n// any\nprintln(people.any{it.length == 3})     // true\nprintln(people.any{it.length == 10})    // false"
          },
          {
            "type": "text",
            "content": "Также функции any() и none() имеют версии без параметров. В этом случае функция  any() возвращает true, если коллекция/последовательность содержит хотя бы один элемент, а функция  none() возвращает true, если коллекция/последовательность пуста:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Kate\", \"Sam\", \"Alice\", \"Bob\")\nval empty: List<String> = listOf()\n// any\nprintln(people.any())     // true\nprintln(empty.any())     // false\n \n// none\nprintln(people.none())     // false\nprintln(empty.none())     // true"
          },
          {
            "type": "text",
            "content": "Функция contains() возвращает true, если в коллекции/последовательности есть определенный элемент:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")\nprintln(people.contains(\"Sam\"))     // true\nprintln(people.contains(\"Bill\"))     // false"
          },
          {
            "type": "text",
            "content": "Еще одна функция - containsAll() возвращает true, если коллекция содержит все элементы другой коллекции:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")\nprintln(people.containsAll(listOf(\"Tom\", \"Sam\")) ) // true\nprintln(people.containsAll(listOf(\"Tom\", \"Bill\")) ) // false"
          }
        ]
      },
      {
        "id": 9,
        "title": "Трансформации",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Трансформации"
          },
          {
            "type": "subtitle",
            "content": "\nmap"
          },
          {
            "type": "text",
            "content": "Для трансформации одной коллекции/последовательности применяется функция map()"
          },
          {
            "type": "code",
            "content": "map(transform: (T) -> R): List<R>/Sequence<R>"
          },
          {
            "type": "text",
            "content": "В качестве параметра она принимает функцию пребразования. Функция пребразования получает текущий элемент коллекции/последовательности и  возвращает результат преобразования. Причем типа входных и выходных данных могут совпадать, а могут и отличаться. Например:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    val people = listOf(Person(\"Tom\"), Person(\"Sam\"), Person(\"Bob\"))\n \n    val names = people.map { it.name } // возвращаем имя каждого пользователя\n    println(names)  // [Tom, Sam, Bob]\n}\nclass Person(val name: String)"
          },
          {
            "type": "text",
            "content": "Здесь из списка List<Person> получаем список List<String>, который содержит имена пользователей."
          },
          {
            "type": "text",
            "content": "Другой пример - трансформируем последовательность чисел в последовательность квадратов этих чисел:"
          },
          {
            "type": "code",
            "content": "val numbers = listOf(1, 2, 3, 4, 5)\nval squares = numbers.map { it * it }\nprintln(squares)    // [1, 4, 9, 16, 25]"
          },
          {
            "type": "text",
            "content": "Еще одна функция -  mapIndexed() также передает в функцию преобразования индекс текущего элемента:"
          },
          {
            "type": "code",
            "content": "mapIndexed(transform: (index: Int, T) -> R): List<R>"
          },
          {
            "type": "text",
            "content": "Применение функции:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    val people = listOf(Person(\"Tom\"), Person(\"Sam\"), Person(\"Bob\"))\n \n    val names = people.mapIndexed{ index, p-> \"${index+1}.${p.name}\"}\n    println(names)  // [1.Tom, 2.Sam, 3.Bob]\n}\nclass Person(val name: String)"
          },
          {
            "type": "text",
            "content": "Если необходимо отсеять значения null, которые могут возникать при преобразовании, то можно применять аналоги выше упомянутых функций -  mapNotNull() и mapIndexedNotNull():"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    val people = listOf(\n        Person(\"Tom\"), Person(\"Sam\"),\n        Person(\"Bob\"), Person(\"Alice\")\n    )\n    // элементы длиной имени не равной 3 преобразуем в null\n    val names1 = people.mapNotNull{ if(it.name.length!=3) null else it.name }\n \n    // элементы на четных позициях преобразуем в null\n    val names2 = people.mapIndexedNotNull{ index, p -> if(index%2==0) null else p.name }\n \n    println(names1)  // [Tom, Sam, Bob]\n    println(names2)  // [Sam, Alice]\n}\nclass Person(val name: String)"
          },
          {
            "type": "subtitle",
            "content": "\nflatten"
          },
          {
            "type": "text",
            "content": "Функция flatten() позволяет преобразовать коллекцию/последовательность, которая содержит вложенные коллекции/последовательности:"
          },
          {
            "type": "code",
            "content": "flatten(): List<T>/Sequence<T>"
          },
          {
            "type": "text",
            "content": "Эта функция помещает элементы всех вложенных коллекций в одну:"
          },
          {
            "type": "code",
            "content": "val personal = listOf(listOf(\"Tom\", \"Bob\"), listOf(\"Sam\", \"Mike\", \"Kate\"), listOf(\"Tom\", \"Bill\"))\nval people = personal.flatten()\nprintln(people)    // [Tom, Bob, Sam, Mike, Kate, Tom, Bill]"
          }
        ]
      },
      {
        "id": 10,
        "title": "Группировки",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Группировка"
          },
          {
            "type": "text",
            "content": "Для группировки элементов коллекции/последовательности применяется функция groupBy():"
          },
          {
            "type": "code",
            "content": "groupBy(keySelector: (T) -> K): Map<K, List<T>>\ngroupBy(keySelector: (T) -> K,valueTransform: (T) -> V): Map<K, List<V>>"
          },
          {
            "type": "text",
            "content": "Обе версии в качестве параметра принимают функцию, которая определяет критерий группировки. Вторая версия в дополнение принимает функцию  преобразования. \nРезультатом функции является объект  Map, который хранит набор групп. \nКлючами являются критерии группировки - ключи групп,  а значениями - списки List, которые соответствуют этим критериям группировки и представляют группы."
          },
          {
            "type": "text",
            "content": "Например, сгруппирует сотрудников по их компаниям:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    val employees = listOf(\n        Employee(\"Tom\", \"Microsoft\"),\n        Employee(\"Bob\", \"JetBrains\"),\n        Employee(\"Sam\", \"Google\"),\n        Employee(\"Alice\", \"Microsoft\"),\n        Employee(\"Kate\", \"Google\")\n    )\n    val companies = employees.groupBy { it.company }    // объект Map<String, List<Employee>>\n \n    println(companies) // {Microsoft=[Tom, Alice], JetBrains=[Bob], Google=[Sam, Kate]}\n \n    // перебор групп\n    for (company in companies){\n        println(company.key) // название компании\n        // перебор списка сотрудников\n        for (employee in company.value){\n            println(employee.name)\n        }\n        println() // для отделения групп\n    }\n}\nclass Employee(val name: String, val company: String){\n    override fun toString(): String = name\n}"
          },
          {
            "type": "text",
            "content": "Здесь критерием группировки является свойство company объекта Employee. Соответственно ключом группы в результирующем объекте Map  будет значение этого свойства, а значением - список Employee. \nЗатем можно получить все значения из каждой группы стандартным перебором объекта Map. Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "{Microsoft=[Tom, Alice], JetBrains=[Bob], Google=[Sam, Kate]}\nMicrosoft\nTom\nAlice\n\nJetBrains\nBob\n\nGoogle\nSam\nKate"
          },
          {
            "type": "text",
            "content": "Теперь применим другую версию функции groupBy с использованием трансформации:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    val employees = listOf(\n        Employee(\"Tom\", \"Microsoft\"),\n        Employee(\"Bob\", \"JetBrains\"),\n        Employee(\"Sam\", \"Google\"),\n        Employee(\"Alice\", \"Microsoft\"),\n        Employee(\"Kate\", \"Google\")\n    )\n    val companies = employees.groupBy({it.company}) { it.name }  // объект Map<String, List<String>>\n \n    println(companies) // {Microsoft=[Tom, Alice], JetBrains=[Bob], Google=[Sam, Kate]}\n    // перебор групп\n    for (company in companies){\n        println(company.key) // название компании\n        // перебор списка сотрудников\n        for (employee in company.value){\n            println(employee)\n        }\n        println() // для отделения групп\n    }\n}\nclass Employee(val name: String, val company: String){\n    override fun toString(): String = name\n}"
          },
          {
            "type": "text",
            "content": "В данном случае в качестве критерия группировки опять выступает свойство company объектов Employee ({ it.company }),  однако сама группа будет представлять список строк - объект List<String>, поскольку функция преобразования вытаскивает значение свойства  name объекта Employee: { it.name }"
          }
        ]
      },
      {
        "id": 11,
        "title": "Сортировка",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Сортировка"
          },
          {
            "type": "text",
            "content": "Для сортировки коллекции/последовательности применяются функции sorted() (сортировка по возрастанию) и  sortedDescending() (сортировка по убыванию)."
          },
          {
            "type": "text",
            "content": "Что в данном случае значит сортировка по возрастанию или убыванию? \nПо умолчанию процесс сортировки опирается на реализацию интерфейса Comparable,  которая определяет, какой объект будет больше, а какой меньше. \nТак, для встроенных базовых типов действует следующая логика:"
          },
          {
            "type": "text",
            "content": "\t• Числа сравниваются как в математике исходя из их значения"
          },
          {
            "type": "text",
            "content": "\t• Символы (Char) и строки (String) сравниваются исходя из лексикографического порядка, то есть \"Tom\" больше, чем \"Alice\", потому что первый символ - T располагается в алфавите после символа A."
          },
          {
            "type": "text",
            "content": "Сортировка чисел и строк:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Mike\", \"Bob\", \"Sam\", \"Alice\")\nval numbers = listOf(3, 5, 2, -4, -6, 9, 1)\n \n// сортировка по возрастанию\nval sortedPeople = people.sorted()\nval sortedNumbers = numbers.sorted()\nprintln(sortedPeople)   // [Alice, Bob, Mike, Sam, Tom]\nprintln(sortedNumbers)  // [-6, -4, 1, 2, 3, 5, 9]\n \n// сортировка по убыванию\nprintln(people.sortedDescending())  // [Tom, Sam, Mike, Bob, Alice]\nprintln(numbers.sortedDescending()) // [9, 5, 3, 2, 1, -4, -6]"
          },
          {
            "type": "subtitle",
            "content": "\nРеализация интерфейса Comparable"
          },
          {
            "type": "text",
            "content": "Если мы определяем свои типы и хотим, чтобы их объекты также можно было отсортировать, то в этом случае следует реализовать  интерфейс Comparable:"
          },
          {
            "type": "code",
            "content": "public interface Comparable<in T> {\n    public operator fun compareTo(other: T): Int\n}"
          },
          {
            "type": "text",
            "content": "Его функция compareTo() должна определять логику сравнения. В качестве параметра она принимает объект, который сравнивается с текущим."
          },
          {
            "type": "text",
            "content": "В качестве результата возвращается число. Если текущий объект равен объекту other, то функция должна возвратить 0. Если текущий объект  больше объекта other, то возвращается положительное число, если меньше - то отрицательное."
          },
          {
            "type": "text",
            "content": "Посмотрим на примере реализацию интерфейса:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    val people = listOf(\n        Person(\"Tom\", 37),\n        Person(\"Bob\",41),\n        Person(\"Sam\", 25)\n    )\n    // сортировка по возрастанию\n    val sortedPeople = people.sorted()\n \n    // сортировка по  возрастанию\n    println(sortedPeople)   // [Bob (41), Sam (25), Tom (37)]\n \n    // сортировка по убыванию\n    println(people.sortedDescending())  // [Tom (37), Sam (25), Bob (41)]\n}\nclass Person(val name: String, val age: Int): Comparable<Person> {\n    override fun compareTo(other: Person): Int = name.compareTo(other.name)\n    override fun toString(): String = \"$name ($age)\"\n}"
          },
          {
            "type": "text",
            "content": "В данном случае класс Person реализует интерфейс Comparable, однако в самом методе compareTo фактически мы полагаемся на реализацию этого  интерфейса для строк. То есть мы фактически возвращаем результат сравнения двух строк - имен пользователей:"
          },
          {
            "type": "code",
            "content": "name.compareTo(other.name)"
          },
          {
            "type": "text",
            "content": "В итоге объекты Person будут сортироваться в соответствии с расположением первых букв их имен в лексикографического порядке -  стандартная сортировка для строк."
          },
          {
            "type": "text",
            "content": "Теперь изменим принцип сортировки и сравним два объекта по их возрасту - значению свойства age:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    val people = listOf(\n        Person(\"Tom\", 37),\n        Person(\"Bob\",41),\n        Person(\"Sam\", 25)\n    )\n    // сортировка по возрастанию\n    val sortedPeople = people.sorted()\n \n    // сортировка по  возрастанию\n    println(sortedPeople)   // [Sam (25), Tom (37), Bob (41)]\n \n    // сортировка по убыванию\n    println(people.sortedDescending())  // [Bob (41), Tom (37), Sam (25)]\n}\nclass Person(val name: String, val age: Int): Comparable<Person> {\n    override fun compareTo(other: Person): Int = age - other.age\n    override fun toString(): String = \"$name ($age)\"\n}"
          },
          {
            "type": "text",
            "content": "Тепрь объект Person считается \"больше\", если у него больше значение свойства age."
          },
          {
            "type": "subtitle",
            "content": "\nsortedWith и интерфейс Comparator"
          },
          {
            "type": "text",
            "content": "Интерфейс Comparable позволяет легко определить логику сортировки, однако бывает, что нам недоступен код классов, объекты которых мы хотим отсортировать. Либо мы хотим задать  для уже существующих типов, которые уже реализуют Comparable, другой способ сортировки. \nВ этом случае мы можем  использовать интерфейс Comparator (грубо говоря компаратор):"
          },
          {
            "type": "code",
            "content": "public expect fun interface Comparator<T> {\n    public fun compare(a: T, b: T): Int\n}"
          },
          {
            "type": "text",
            "content": "Его функция compare() принимает два параметра - два сравниваемых объекта и также возращает целое число. \nЕсли первый параметр  больше второго, то возвращается положительное число, если меньше - то отрицательное. Если объекты равно, возвращается 0."
          },
          {
            "type": "text",
            "content": "Kotlin имеет встроенную функцию sortedWith(), которая в качестве параметра принимает компаратор и на его основе  сортирует коллекцию/последовательность:"
          },
          {
            "type": "code",
            "content": "sortedWith(comparator: Comparator<in T>): List<T>"
          },
          {
            "type": "text",
            "content": "Пример реализации:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    val people = listOf(\n        Person(\"Tom\", 37),\n        Person(\"Bob\",41),\n        Person(\"Sam\", 25)\n    )\n    val personComparator = Comparator{ p1: Person, p2: Person -> p1.age - p2.age }\n \n    val sortedPeople = people.sortedWith(personComparator)\n    println(sortedPeople)   // [Sam (25), Tom (37), Bob (41)]\n}\nclass Person(val name: String, val age: Int){\n    override fun toString(): String = \"$name ($age)\"\n}"
          },
          {
            "type": "text",
            "content": "В данном случае компаратор определен в виде переменной personComparator. В реализации интерфейса как и в предыдущем примере сравниваем  пользователей на основе возраста: если значение свойства age больше, то и объект Person условно считается \"больше\"."
          },
          {
            "type": "text",
            "content": "В принципе в данном случае мы можем сократить вызов функции сортировки:"
          },
          {
            "type": "code",
            "content": "val sortedPeople = people.sortedWith{ p1: Person, p2: Person -> p1.age - p2.age }"
          },
          {
            "type": "text",
            "content": "или так:"
          },
          {
            "type": "code",
            "content": "val sortedPeople = people.sortedWith(compareBy{ it.age })"
          },
          {
            "type": "text",
            "content": "Благодаря компаратору можно задать свою логику сортировки к уже имеющимся типам. Например, отсортируем строки по длине:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    val people = listOf(\"Tom\", \"Alice\", \"Kate\", \"Sam\", \"Bob\")\n    // отсортируем по длине строки\n    val sorted  = people.sortedWith(compareBy{ it.length })\n    println(sorted)   // [Tom, Sam, Bob, Alice]\n}"
          },
          {
            "type": "subtitle",
            "content": "\nСортировка на основе критерия"
          },
          {
            "type": "text",
            "content": "Еще две функцию позволяют отсортировать объекты по определенному критерию:"
          },
          {
            "type": "code",
            "content": "sortedBy(crossinline selector: (T) -> R?): List<T> / Sequence<T>\nsortedByDescending(crossinline selector: (T) -> R?): List<T> / Sequence<T>"
          },
          {
            "type": "text",
            "content": "Функция sortedBy() сортирует по возрастанию, а sortedByDescending() - по убыванию. В качестве параметра  они принимают функцию, которая получает элемент и возвращает значение, применяемое для сортировки."
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    val people = listOf( Person(\"Tom\", 37), Person(\"Bob\",41), Person(\"Sam\", 25))\n \n    // сортировка по свойству name по возрастанию \n    val sortedByName = people.sortedBy { it.name }\n    println(sortedByName)   // [Bob (41), Sam (25), Tom (37)]\n \n    // сортировка по свойству age по возрастанию \n    val sortedByAge = people.sortedBy { it.age }\n    println(sortedByAge)   // [Sam (25), Tom (37), Bob (41)]\n \n    // сортировка по свойству age по убыванию \n    val sortedByAgeDesc = people.sortedByDescending { it.age }\n    println(sortedByAgeDesc)   // [Bob (41), Tom (37), Sam (25)]\n}\nclass Person(val name: String, val age: Int){\n    override fun toString(): String = \"$name ($age)\"\n}"
          },
          {
            "type": "subtitle",
            "content": "\nreverse и shaffle"
          },
          {
            "type": "text",
            "content": "Стоит отметить еще две функции, которые не сортируют, а просто меняют порядок элементов.  Функция reversed() изменяет порядок элементов на обратный, а функция shuffle() перемешивает элементы случайным  образом:"
          },
          {
            "type": "code",
            "content": "val numbers = listOf(1, 2, 3, 4, 5, 6)\nval reversed = numbers.reversed()\nprintln(reversed)   // [6, 5, 4, 3, 2, 1]\n \nval shuffled = numbers.shuffled()\nprintln(shuffled)   // [4, 6, 3, 5, 1, 2]"
          }
        ]
      },
      {
        "id": 12,
        "title": "Агрегатные операции",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Агрегатные операции"
          },
          {
            "type": "text",
            "content": "Коллекции/последовательности поддерживают ряд агрегатных операций, которые возвращают некоторое значение."
          },
          {
            "type": "subtitle",
            "content": "\nМинимальное и максимальное значение"
          },
          {
            "type": "text",
            "content": "Функции minOrNull() и maxOrNull() возвращают соответственно минимальное и максимальное значение  (если коллекция/последовательность пута, то возвращается null).  Причем для работы этих функций элементы коллекции/последовательности должны реализовать интерфейс Comparable:"
          },
          {
            "type": "code",
            "content": "val numbers = listOf(4, 6, 3, 5, 1, 2)\nval people = listOf(\"Alice\", \"Tom\", \"Sam\", \"Kate\", \"Bob\")\n \nprintln(numbers.minOrNull())   // 1\nprintln(numbers.maxOrNull())   // 6\n \nprintln(people.minOrNull())   // Alice\nprintln(people.maxOrNull())   // Tom"
          },
          {
            "type": "text",
            "content": "Функции minByOrNull() и maxByOrNull() в качестве параметра принимают функцию селектора,  которая позволяет определить критерий сравнения объектов:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    val people = listOf( Person(\"Tom\", 37), Person(\"Bob\",41), Person(\"Sam\", 25))\n    // минимальный возраст\n    val personWithMinAge = people.minByOrNull { it.age }\n    println(personWithMinAge)     // Sam (25)\n    // максимальный возраст\n    val personWithMaxAge = people.maxByOrNull { it.age }\n    println(personWithMaxAge)     // Bob (41)\n}\nclass Person(val name: String, val age: Int){\n    override fun toString(): String = \"$name ($age)\"\n}"
          },
          {
            "type": "text",
            "content": "Выше функции находили элемент с наименьшим и наибольшим значением свойства age. Но что, если мы хотим получить не весь  объект, а сами значения минимального и максимального возраста? \nВ этом случае мы можем использовать функции  minOfOrNull() и maxOfOrNull(), которые также принимают функцию селектора, но возвращает само значение,  на основе которого происходит сравнение:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    val people = listOf( Person(\"Tom\", 37), Person(\"Bob\",41), Person(\"Sam\", 25))\n    // минимальный возраст\n    val minAge = people.minOfOrNull { it.age }\n    println(minAge)     // 25\n    // максимальный возраст\n    val maxAge = people.maxOfOrNull { it.age }\n    println(maxAge)     // 41\n}\nclass Person(val name: String, val age: Int){\n    override fun toString(): String = \"$name ($age)\"\n}"
          },
          {
            "type": "text",
            "content": "\nЕще пара функций - minWithOrNull() и maxWithOrNull() в качестве параметра принимают компаратор -  реализацию интерфейса Comparator:"
          },
          {
            "type": "code",
            "content": "val colors = listOf(\"red\", \"green\", \"blue\", \"yellow\")\nval minColor = colors.minWithOrNull(compareBy {it.length})\nval maxColor = colors.maxWithOrNull(compareBy {it.length})\nprintln(minColor)   // red\nprintln(maxColor)   // yellow"
          },
          {
            "type": "text",
            "content": "В качестве критерия сравнения здесь применяется свойство length строк, то есть строки сравниваются по длине."
          },
          {
            "type": "text",
            "content": "И еще одна пара функций - minOfWithOrNull() и maxOfWithOrNull() принимают реализацию  интерфейса Comparator (первый параметр) и селектор критерия для сравнения (второй параметр):"
          },
          {
            "type": "code",
            "content": "maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R?\nminOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R?"
          },
          {
            "type": "text",
            "content": "Применим данные функции:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    val people = listOf(\n        Person(\"Tom\", 37), Person(\"Kate\",29),\n        Person(\"Sam\", 25), Person(\"Alice\", 33)\n    )\n    // самое короткое имя\n    val minName = people.minOfWithOrNull(compareBy{it.length}) { it.name }\n    println(minName)     // Tom\n    // самое длинное имя\n    val maxName = people.maxOfWithOrNull(compareBy{it.length}) { it.name }\n    println(maxName)     // Alice\n}\nclass Person(val name: String, val age: Int){\n    override fun toString(): String = \"$name ($age)\"\n}"
          },
          {
            "type": "text",
            "content": "В качестве критерия сравнения здесь применяется свойство name объектов Person, так как функция селектора определена следующим образом: { it.name } (здесь it - это текущий объект Person)"
          },
          {
            "type": "text",
            "content": "Поскольку в качестве критерия сравнения применяется свойство name, то в функцию компаратора передается значение этого свойства. И собственно  оно используется для сравнения объектов Person: compareBy{it.length} (здесь it - это значение свойства name)"
          },
          {
            "type": "subtitle",
            "content": "\nСреднее значение"
          },
          {
            "type": "text",
            "content": "Для получения среднего значения применяется функция average():"
          },
          {
            "type": "code",
            "content": "val numbers = listOf(4, 6, 3, 5, 1, 2)\nval avg = numbers.average()\nprintln(avg)    // 3.5"
          },
          {
            "type": "subtitle",
            "content": "\nСумма значений"
          },
          {
            "type": "text",
            "content": "Для получения суммы числовых значений применяется функция sum():"
          },
          {
            "type": "code",
            "content": "val numbers = listOf(4, 6, 3, 5, 1, 2)\nval sum = numbers.sum()\nprintln(sum)    // 21"
          },
          {
            "type": "subtitle",
            "content": "\nКоличество элементов"
          },
          {
            "type": "text",
            "content": "Для получения количества элементов в коллекции/последовательности применяется функция count(). Она имеет два варианта:"
          },
          {
            "type": "code",
            "content": "count(): Int\ncount(predicate: (T) -> Boolean): Int"
          },
          {
            "type": "text",
            "content": "Первая версия возвращает количество всех элементов. Вторая версия возвращает количество элементов, которые соответствуют условию предиката,  передаваемого в функцию в качестве параметра. Пример применения функций:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Bob\", \"Kate\", \"Alice\")\n// совокупное количество\nval count1 = people.count()\nprintln(count1)      // 5\n \n// количество строк, у которых длина равна 3\nval count2 = people.count{it.length == 3}\nprintln(count2)      // 3"
          },
          {
            "type": "subtitle",
            "content": "\nСведение элементов"
          },
          {
            "type": "text",
            "content": "Функция reduce() сводит все значения потока к одному значению:"
          },
          {
            "type": "code",
            "content": "reduce(operation: (acc: S, T) -> S): S"
          },
          {
            "type": "text",
            "content": "reduce принимает функцию, которая имеет два параметра. Первый параметр при первом запуске представляет первый элемент, а при  последующих запусках - результат функции над предыдущими элементами. А второй параметр функции - следующий элемент."
          },
          {
            "type": "text",
            "content": "Например, у нас есть список чисел, найдем сумму всех чисел:"
          },
          {
            "type": "code",
            "content": "val numbers = listOf(1, 2, 3, 4, 5)\nval reducedValue = numbers.reduce{ a, b -> a + b }\nprintln(reducedValue)   // 15"
          },
          {
            "type": "text",
            "content": "Здесь при первом запуске в функции в reduce параметр a равен 1, а параметр b равен 2.  При втором запуске параметр a содержит результат предыдущего выполнения функции, то если число 1 + 2 = 3, а параметр b равен 3 - следующее число в потоке."
          },
          {
            "type": "text",
            "content": "Или другой пример со строками:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Bob\", \"Kate\", \"Sam\", \"Alice\")\nval reducedValue = people.reduce{ a, b -> \"$a $b\" }\nprintln(reducedValue)   // Tom Bob Kate Sam Alice"
          },
          {
            "type": "text",
            "content": "Здесь reduce соединяет все строки в одну."
          },
          {
            "type": "text",
            "content": "\nФункция fold также сводит все элементы потока в один. Но в отличие от reduce в качестве первого параметра принимает начальное значение:"
          },
          {
            "type": "code",
            "content": "fold(initial: R, operation: (acc: R, T) -> R): R"
          },
          {
            "type": "text",
            "content": "Например:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Bob\", \"Kate\", \"Sam\", \"Alice\")\nval foldedValue = people.fold(\"People:\", { a, b -> \"$a $b\" })\nprintln(foldedValue)   // People: Tom Bob Kate Sam Alice"
          },
          {
            "type": "text",
            "content": "В данном случае начальным значением является строка \"People:\", к которой затем добавляются остальные элементы списка."
          }
        ]
      },
      {
        "id": 13,
        "title": "Действия с коллекциями",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Сложение, вычитание и объединение коллекций"
          },
          {
            "type": "text",
            "content": "С помощью функции plus можно складывать коллекции/последовательности с другими элементами или коллекциями/последовательностями.  Данная функция принимает как одиночный элемент, так и коллекцию/последовательность:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    val people = listOf(\"Tom\", \"Bob\", \"Sam\")\n    // добавляем один объект \n    val result1 = people.plus(\"Alice\")\n    println(result1)  // [Tom, Bob, Sam, Alice]\n \n    val employees = listOf(\"Mike\", \"Kate\")\n    // добавляем коллекцию объектов\n    val result2 = people.plus(employees)\n    println(result2)  // [Tom, Bob, Sam, Mike, Kate]\n}"
          },
          {
            "type": "text",
            "content": "Обратите внимание, что начальная коллекция, у которой вызывается функция minus() (в примере выше коллекция people), не изменяется, результатом объединения является новая коллекция."
          },
          {
            "type": "text",
            "content": "Вместо функции plus() можно использовать оператор '+'"
          },
          {
            "type": "code",
            "content": "fun main(){\n    val people = listOf(\"Tom\", \"Bob\", \"Sam\")\n    val result1 = people + \"Alice\"\n    println(result1)  // [Tom, Bob, Sam, Alice]\n \n    val employees = listOf(\"Mike\", \"Kate\")\n    val result2 = people + employees\n    println(result2)  // [Tom, Bob, Sam, Mike, Kate]\n}"
          },
          {
            "type": "text",
            "content": "Аналогичным образом можно использовать функцию minus() для вычитания либо одиночного объекта, либо коллекции/последовательности:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    val people = listOf(\"Tom\", \"Bob\", \"Sam\", \"Kate\")\n    // вычитаем один объект\n    val result1 = people.minus(\"Bob\")\n    println(result1)  // [Tom, Sam, \"Kate\"]\n \n    val employees = listOf(\"Mike\", \"Kate\")\n    // вычитаем коллекцию\n    val result2 = people.minus(employees)\n    println(result2)  // [Tom, Bob, Sam]\n}"
          },
          {
            "type": "text",
            "content": "Начальная коллекция, у которой вызывается функция minus(), также не изменяется, результатом вычитания является новая коллекция."
          },
          {
            "type": "text",
            "content": "Вместо функции minus() можно использовать оператор '-'"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Bob\", \"Sam\", \"Kate\")\nval result1 = people - \"Bob\"\nprintln(result1)  // [Tom, Sam, \"Kate\"]\n \nval employees = listOf(\"Mike\", \"Kate\")\nval result2 = people - employees\nprintln(result2)  // [Tom, Bob, Sam]"
          },
          {
            "type": "subtitle",
            "content": "\nОбъединение"
          },
          {
            "type": "text",
            "content": "Для объединения двух разных коллекций/последовательностей в одну применяется функция zip():"
          },
          {
            "type": "code",
            "content": "zip(other: Iterable<R>/Sequence<R>): List<Pair<T, R>>/Sequence<Pair<T, R>>"
          },
          {
            "type": "text",
            "content": "В качестве параметра она принимает другую коллекцию/последовательность и возвращает набор из объектов типа Pair"
          },
          {
            "type": "text",
            "content": "Например, объединим два списка в один:"
          },
          {
            "type": "code",
            "content": "val english = listOf(\"red\", \"blue\", \"green\")\nval russian = listOf(\"красный\", \"синий\", \"зеленый\")\nval words = english.zip(russian)\n \nfor(word in words)\n    println(\"${word.first}: ${word.second}\")"
          },
          {
            "type": "text",
            "content": "Здесь каждому элементу из списка english сопоставляется элемент на соответствующей позиции из списка russian. \nРезультатом функции будет  список из объектов Pair<String, String>, где свойство first хранит значение из текущей коллекции, а свойство second  - значение из коллекции, переданной в качестве параметра:"
          },
          {
            "type": "code",
            "content": "red: красный\nblue: синий\ngreen: зеленый"
          },
          {
            "type": "text",
            "content": "Если в одной из коллекций меньше элементов, чем в другой, то сопоставляется столько элементов, сколько в наименьшей коллекции."
          },
          {
            "type": "text",
            "content": "Функция zip() имеет еще одну версию, которая в качестве второго параметра получает функцию преобразования,  применяемую к элементам обоих коллекций/последовательностей:"
          },
          {
            "type": "code",
            "content": "zip(other: Iterable<R>,transform: (a: T, b: R) -> V): List<V>\nzip(other: Sequence<R>,transform: (a: T, b: R) -> V): Sequence<V>"
          },
          {
            "type": "text",
            "content": "Пример использования:"
          },
          {
            "type": "code",
            "content": "val english = listOf(\"red\", \"blue\", \"green\")\nval russian = listOf(\"красный\", \"синий\", \"зеленый\")\nval words = english.zip(russian){en, ru -> \"$en - $ru\"}\n \nfor(word in words) println(word)"
          },
          {
            "type": "text",
            "content": "Консольный вывод:"
          },
          {
            "type": "code",
            "content": "red - красный\nblue - синий\ngreen - зеленый"
          },
          {
            "type": "text",
            "content": "Также в Kotlin есть обратная функция -  unzip, которая позволяет обратно получить две коллекции"
          },
          {
            "type": "code",
            "content": "unzip(): Pair<List<T>, List<R>>"
          },
          {
            "type": "text",
            "content": "Пример использования:"
          },
          {
            "type": "code",
            "content": "val dictionary = listOf(\"red\", \"blue\", \"green\")\n        .zip(listOf(\"красный\", \"синий\", \"зеленый\"))\nval words = dictionary.unzip()\nprintln(words.first)    // [red, blue, green]\nprintln(words.second)   // [красный, синий, зеленый]"
          }
        ]
      },
      {
        "id": 14,
        "title": "Получение части элементов",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Получение части элементов"
          },
          {
            "type": "subtitle",
            "content": "\nslice"
          },
          {
            "type": "text",
            "content": "Функция slice() возвращает часть коллекции, элементы которой располагаются на определенных индексах. \nИндексы передаеются в функцию  либо в виде диапазона IntRange, либо коллекции значений Iterable<Int>. \nРезультатом функции является список  List<T>, который содержит элементы по указанным индексам:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Bob\", \"Sam\", \"Kate\", \"Alice\", \"Mike\")\n \nprintln(people.slice(1..3))     // [Bob, Sam, Kate]\nprintln(people.slice(0..5 step 2))  // [Tom, Sam, Alice]\nprintln(people.slice(listOf(1, 3, 5, 1)))   // [Bob, Kate, Mike, Bob]"
          },
          {
            "type": "text",
            "content": "Стоит отметить, что для последовательностей эта функция не доступна."
          },
          {
            "type": "subtitle",
            "content": "\nTake и takeWhile"
          },
          {
            "type": "text",
            "content": "Функция take() извлекает из начала коллекции/последовательности определенное количество элементов"
          },
          {
            "type": "code",
            "content": "take(n: Int): List<T>/Sequence<T>"
          },
          {
            "type": "text",
            "content": "Например, выберем 3 первых элементов:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Bob\", \"Sam\", \"Kate\", \"Alice\", \"Mike\")\nprintln(people.take(3))     // [\"Tom\", \"Bob\", \"Sam\"]"
          },
          {
            "type": "text",
            "content": "Для коллекций также доступна функция takeLast(), которая извлекает определенное количество элементов из конца коллекции"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Bob\", \"Sam\", \"Kate\", \"Alice\", \"Mike\")\n// получаем три последних элемента\nprintln(people.takeLast(3))     // [\"Kate\", \"Alice\", \"Mike\"]"
          },
          {
            "type": "text",
            "content": "Функция takeWhile() отбирает элементы с начала коллекции/последовательности, которые соответвуют условию предиката:"
          },
          {
            "type": "code",
            "content": "takeWhile(predicate: (T) -> Boolean): List<T>       // для коллекций\ntakeWhile(predicate: (T) -> Boolean): Sequence<T>   // для последовательностей"
          },
          {
            "type": "text",
            "content": "функция предиката получает в качестве параметра текущий элемент и возращает true, если элемент соответствует условию:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\", \"Mike\")\nval part = people.takeWhile{it.length == 3}\nprintln(part)     // [\"Tom\", \"Sam\"]"
          },
          {
            "type": "text",
            "content": "В данном случае условие предиката возвращает true, если длина строки равна 3: {it.length == 3},  поэтому функция takeWhile отбирает строки, пока они соответствуют этому условию. \nТак, в данном случае в результирующем списке окажется первые два элемента:  [\"Tom\", \"Sam\"]. Когда функция takeWhile() встретит хоть один элемент, который не соответствует условию, она завершит работу:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\", \"Mike\")\nval part = people.takeWhile{it.length == 4}     // выбираем строки с длиной в 4 символа\nprintln(part)     // [] - пустой список"
          },
          {
            "type": "text",
            "content": "Для коллекций также доступа функция takeLastWhile(), которая работает аналогичным образом, только выбирает элементы с конца списка"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\", \"Mike\")\nval part = people.takeLastWhile{it.length !=3} // длина НЕ равна 3\nprintln(part)     // [\"Alice\", \"Mike\"]"
          },
          {
            "type": "subtitle",
            "content": "\ndrop и dropWhile"
          },
          {
            "type": "text",
            "content": "Функция drop() позволяет пропустить определенное количество элементов в коллекции/последовательности:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\", \"Mike\")\nval part = people.drop(3) // пропускаем первые 3 элемента\nprintln(part)     // [Bob, Alice, Mike]"
          },
          {
            "type": "text",
            "content": "Для коллекций также доступна функция dropLast(), которая проупскает определенное количество элементов из конца коллекции"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\", \"Mike\")\nval part = people.dropLast(2) // пропускаем последние 2 элемента\nprintln(part)     // [Tom, Sam, Kate, Bob]"
          },
          {
            "type": "text",
            "content": "Функция dropWhile() пропускает элементы с начала коллекции/последовательности, которые соответвуют условию предиката:"
          },
          {
            "type": "code",
            "content": "dropWhile(predicate: (T) -> Boolean): List<T>       // для коллекций\ndropWhile(predicate: (T) -> Boolean): Sequence<T>   // для последовательностей"
          },
          {
            "type": "text",
            "content": "функция предиката получает в качестве параметра текущий элемент и возращает true, если элемент соответствует условию:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\", \"Mike\")\nval part = people.dropWhile{it.length == 3}\nprintln(part)     // [Kate, Bob, Alice, Mike]"
          },
          {
            "type": "text",
            "content": "В данном случае условие предиката возвращает true, если длина строки равна 3: {it.length == 3},  поэтому функция dropWhile() пропускает строки, пока они соответствуют этому условию. Так, в данном случае в результирующем списке окажется первые два элемента:  [Kate, Bob, Alice, Mike]. Когда функция dropWhile() встретит хоть один элемент, который не соответствует условию, она завершит работу."
          },
          {
            "type": "text",
            "content": "Для коллекций также доступа функция dropLastWhile(), которая работает аналогичным образом, только пропускает элементы с конца списка"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\", \"Mike\")\nval part = people.dropLastWhile{it.length !=3} // длина НЕ равна 3\nprintln(part)     // [\"Tom\", \"Sam\", \"Kate\", \"Bob\"]"
          },
          {
            "type": "subtitle",
            "content": "\nРазделение на части"
          },
          {
            "type": "text",
            "content": "Функция chuncked() позволяет разбить коллекцию/последовательность на списки определенной длины:"
          },
          {
            "type": "code",
            "content": "chunked(size: Int): List<List<T>>       // для коллекций\nchunked(size: Int): Sequence<List<T>>  // для последовательностей"
          },
          {
            "type": "text",
            "content": "В качестве параметра в функцию передается размер списков, в которые будут помещаться элементы:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\", \"Mike\")\nval parts = people.chunked(3)\nprintln(parts)     // [[Tom, Sam, Kate], [Bob, Alice, Mike]]"
          },
          {
            "type": "text",
            "content": "В данном случае разбиваем коллекцию на списки по 3 элемента, соответственно результирующая коллекция будет содержать два списка по три элемента."
          },
          {
            "type": "text",
            "content": "Дополнительная версия функции в качестве второго параметра принимает функцию преобразования элементов:"
          },
          {
            "type": "code",
            "content": "chunked(size: Int, transform: (List<T>) -> R): List<R>      // для коллекций\nchunked(size: Int,transform: (List<T>) -> R): Sequence<R> // для последовательностей"
          },
          {
            "type": "text",
            "content": "То есть сначала коллекция/последовательность разбивается на несколько списков длиной size, затем каждый список передается в функцию преобразования,  где на его основе можно сгенерировать новое значение. Например:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\", \"Mike\")\nval parts = people.chunked(3){it.first()}\nprintln(parts)     // [Tom, Bob]"
          },
          {
            "type": "text",
            "content": "В данном случае коллекция разделяется на два списка длиной по 3 элемента. В функции преобразования из каждого списка выбирается и возвращается  первый элемент каждого списка. Соответственно результатом функции будет список из двух первых элементов."
          }
        ]
      },
      {
        "id": 15,
        "title": "Получение отдельных элементов",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Получение отдельных элементов"
          },
          {
            "type": "subtitle",
            "content": "\nПолучение элемента по индексу"
          },
          {
            "type": "text",
            "content": "Для получения элемента по индексу применяется функция elementAt(), в которую передается индекс элемента:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")\n// получаем элемент по индексу 1\nprintln(people.elementAt(1))     // Sam"
          },
          {
            "type": "text",
            "content": "Однако если переданный индекс выходит за границы коллекции/последовательности, то приложение сгенерирует ошибку. В этом случае мы можем использовать  функцию elementAtOrNull(), которая возвращает null, если индекс вне границ:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")\nprintln(people.elementAtOrNull(1))     // Sam\nprintln(people.elementAtOrNull(6))     // null"
          },
          {
            "type": "text",
            "content": "Также в этом случае можно использовать функцию elementAtOrElse():"
          },
          {
            "type": "code",
            "content": "elementAtOrElse(index: Int, defaultValue: (Int) -> T): T"
          },
          {
            "type": "text",
            "content": "Первый параметр функции - индекс элемента, а второй - функция, которая получает индекс и возвращает значение по умолчанию, если индекс находится вне границ  коллекции/последовательности."
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")\n \nprintln(people.elementAtOrElse(1){\"Undefined\"})     // Sam\nprintln(people.elementAtOrElse(6){\"Undefined\"})     // Undefined\nprintln(people.elementAtOrElse(8){\"Index $it out of bounds\"})  // Index 8 out of bounds"
          },
          {
            "type": "subtitle",
            "content": "\nПолучение по условию"
          },
          {
            "type": "text",
            "content": "Если надо получить первый или последний элементы коллекции/последовательности, то можно использовать соответственно функции first()  и last():"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")\nprintln(people.first())     // Tom\nprintln(people.last())     // Alice"
          },
          {
            "type": "text",
            "content": "В качестве параметра эти функции могут принимать функцию предиката"
          },
          {
            "type": "code",
            "content": "first(predicate: (T) -> Boolean): T\nlast(predicate: (T) -> Boolean): T"
          },
          {
            "type": "text",
            "content": "Эти функции возвращают первый и последний элементы, которые соответствуют условию предиката:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")\n// первый элемент с длиной в 4 символа\nprintln(people.first{it.length==4})     // Kate\n// последний элемент с длиной в 3 символа\nprintln(people.last{it.length==3})     // Bob"
          },
          {
            "type": "text",
            "content": "Однако если коллеккция пуста, или в коллекции/последовательности нет элементов, которые соответствуют условию, то программа генерирует ошибку. \nВ этом случае  можно применять функции firstOrNull() и lastOrNull(), которые возвращают null, если коллекция пуста или  в ней нет элементов, соответствующих условию:"
          },
          {
            "type": "code",
            "content": "firstOrNull(): T?\nfirstOrNull(predicate: (T) -> Boolean): T?\n \nlastOrNull(): T?\nlastOrNull(predicate: (T) -> Boolean): T?"
          },
          {
            "type": "text",
            "content": "Пример применения:"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")\n \nprintln(people.firstOrNull{it.length==3})     // Tom\nprintln(people.firstOrNull{it.length==33})     // null\n \nprintln(people.lastOrNull{it.length==3})     // Bob\nprintln(people.lastOrNull{it.length==33})     // null"
          },
          {
            "type": "subtitle",
            "content": "\nВыбор случайного элемента"
          },
          {
            "type": "text",
            "content": "Для извлечения случайного элемента применяется функция random()"
          },
          {
            "type": "code",
            "content": "val people = listOf(\"Tom\", \"Sam\", \"Kate\", \"Bob\", \"Alice\")\nprintln(people.random())"
          },
          {
            "type": "text",
            "content": "Однако если коллекция/последовательность пуста, то эта функция генерирует ошибку. В этом случае можно использовать функцию randomOrNull(),  которая в этом случае возвращает null:"
          },
          {
            "type": "code",
            "content": "val people = listOf<String>()\nprintln(people.randomOrNull())     // null"
          }
        ]
      }
    ]
  },
  {
    "chapterId": 8,
    "chapterTitle": "Корутины",
    "articles": [
      {
        "id": 1,
        "title": "Введение в корутины",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Введение в корутины"
          },
          {
            "type": "text",
            "content": "В последнее время поддержка асинхронности и параллельных вычислений стала неотъемлимой чертой многих языков программирования. И Kotlin не является исключением. \n\nЗачем нужны асинхронность и параллельные вычисления? \nПараллельные вычисления позволяют выполнять несколько задач одновременно, а асинхронность позволяет не блокировать основной ход приложения во время выполнения задачи, которая занимает продолжительное время."
          },
          {
            "type": "text",
            "content": "В языке Kotlin поддержка асинхронности и параллельных вычислений воплощена в виде корутин (coroutine). \nПо сути корутина представляет блок кода, который может выполняться параллельно с остальным кодом. А базовая функциональность, связанная с корутинами, сосредоточена в библиотеке kotlinx.coroutines."
          },
          {
            "type": "subtitle",
            "content": "\nДобавление kotlinx.coroutines"
          },
          {
            "type": "text",
            "content": "Функциональность корутин (библиотека kotlinx.coroutines) по умолчанию не включена в проект. И нам ее надо добавить. \n\nЕсли мы создаем проект консольного приложения в IntelliJ IDEA, то мы можем добавить соответствующую библиотеку в проект. Для этого в меню File перейдем к пункту Project Structure.."
          },
          {
            "type": "image",
            "content": "ch8ar1_1"
          },
          {
            "type": "text",
            "content": "Далее на вкладке \"Project Settings\" перейдем к пункту Libraries. В центральном поле отобразятся библиотеки, добавленные в проект."
          },
          {
            "type": "image",
            "content": "ch8ar1_2"
          },
          {
            "type": "text",
            "content": "И для добавления новой библиотеки нажмем на знак плюса и в контекстном меню выберем пункт From Maven...\n\nПосле этого нам откроется окно для добавления библиотеки через Maven. В этом окне в поле ввода введем название нужной нам библиотеки - kotlinx-coroutines-core-jvm и нажмем на кнопку поиска. Если соответствующая библиотека найдена, то нам отобразится выпадающий список с результатами"
          },
          {
            "type": "image",
            "content": "ch8ar1_3"
          },
          {
            "type": "text",
            "content": "Выберем из него последнюю версию, которая называется наподобие org.jetbrains.kotlinx:kotlinx-coroutines-core-jvm:1.10.2 - в данном случае используется версия 1.10.2, но конкретный номер версии может отличаться.\n\nОтметим все необходимые флажки и нажмем на кнопку OK"
          },
          {
            "type": "image",
            "content": "ch8ar1_4"
          },
          {
            "type": "text",
            "content": "После установки библиотеки мы сможем найти ее файл в списке библиотек. Нажимаем \"Apply\", а затем \"OK\""
          },
          {
            "type": "subtitle",
            "content": "\nОпределение suspend-функции"
          },
          {
            "type": "text",
            "content": "Сначала рассмотрим пример, который не использует корутины:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main(){\n    for(i in 0..5){\n        delay(400L)\n        println(i)\n    }\n \n    println(\"Hello Coroutines\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь в функции main перебираем последовательность от 0 до 5 и выводит текущий элемент последовательности на консоль. \nДля имитации продолжительной работы внутри цикла вызываем специальную функцию delay() из пакета kotlinx.coroutines. В эту функцию передается количество миллисекунд, на которое выполняется задержка. Передаваемое значение должно иметь тип Long. \nТо есть здесь функция будет выполнять задержку в 400 миллисекунд перед выводом на консоль текущего элемента последовательности.\n\nПосле выполнения работы цикла выводим на консоль строку \"Hello Coroutines\".\n\nИ чтобы использовать внутри функции main функцию delay(), функция main предваряется модификатром suspend. \nМодификатор suspend определяет функцию, которая может приостановить свое выполнение и возобновить его через некоторый период времени.\n\nСама функция delay() тоже является подобной функцией, которая определена с модификатором suspend. А любая функция с модификатором suspend может вызываться либо из другой функции, которая тоже имеет модификатор suspend, либо из корутины.\n\nЕсли мы запустим приложение, то мы увидим следующий консольный вывод:"
          },
          {
            "type": "code",
            "content": "0\n1\n2\n3\n4\n5\nHello Coroutines"
          },
          {
            "type": "subtitle",
            "content": "\nОпределение корутины"
          },
          {
            "type": "text",
            "content": "Теперь вынесем продолжительную работу - то есть цикл в корутину:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n    launch{\n            for(i in 0..5){\n            delay(400L)\n            println(i)\n        }\n    }\n \n    println(\"Hello Coroutines\")\n}"
          },
          {
            "type": "text",
            "content": "Прежде всего для определения и выполнения корутины нам надо определить для нее контекст, так как корутина может вызываться только в контексте корутины (coroutine scope). \nДля этого применяется функция coroutineScope() - создает контекст корутины. Кроме того, эта функция ожидает выполнения всех определенных внутри нее корутин. \nСтоит отметить, что coroutineScope() может применяться только в функции с модификатором suspend, коей является функция main.\n\nСама корутина определяется и запускается с помощью построителя корутин - функции launch. Она создает корутину в виде блока кода - в данном случае это:"
          },
          {
            "type": "code",
            "content": "{\n    for(i in 0..5){\n        delay(400L)\n        println(i)\n    }\n}"
          },
          {
            "type": "text",
            "content": "и запускает эту корутину параллельно с остальным кодом. То есть данная корутина выполняется независимо от прочего кода, определенного в функции main.\n\nВ итоге при выполнении программы мы увидим несколько другой консольный вывод:"
          },
          {
            "type": "code",
            "content": "Hello Coroutines\n0\n1\n2\n3\n4\n5"
          },
          {
            "type": "text",
            "content": "Теперь строка \"Hello Coroutines\" не ожидает, пока завершится цикл, а выполняется параллельно с ним."
          },
          {
            "type": "subtitle",
            "content": "\nВынесение кода корутин в отдельную функцию"
          },
          {
            "type": "text",
            "content": "Выше код корутины располагался непосредственно в функции main. Но также можно определить его в виде отдельной функции и вызывать в корутине эту функцию:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main()= coroutineScope{\n    launch{ doWork() }\n \n    println(\"Hello Coroutines\")\n}\nsuspend fun doWork(){\n    for(i in 0..5){\n        println(i)\n        delay(400L)\n    }\n}"
          },
          {
            "type": "subtitle",
            "content": "\nКорутины и потоки"
          },
          {
            "type": "text",
            "content": "В ряде языков программирования есть такие структуры, которые позволяют использовать потоки. \nОднако между корутинами и потоками нет прямого соответствия. Корутина не привязана к конкретному потоку. Она может быть приостановить выполнение в одном потоке, а возобновить выполнение в другом.\n\nКогда корутина приостанавливает свое выполнение, например, как в случае выше при вызове задержки с помощью функции delay(), эта корутина освобождает поток, в котором она выполнялась, и сохраняется в памяти. \nОсвобожденный поток может быть зайдествован для других задач. А когда завершается запущенная задача (например, выполнение функции delay()), корутина возобновляет свою работу в одном из свободных потоков."
          }
        ]
      },
      {
        "id": 2,
        "title": "Область корутины",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Область корутины"
          },
          {
            "type": "text",
            "content": "Корутина может выполняться только в определенной области корутины (coroutine scope). \nОбласть корутин представляет пространство, в рамках которого  действуют корутины, она имеет определенный жизненный цикл и сама управляет жизненным циклом создаваемых внутри нее корутин."
          },
          {
            "type": "text",
            "content": "И для создания области корутин в Kotlin может использоваться ряд функций, которые создают объект интерфейса CoroutineScope.  Одной из функций является coroutineScope. Она может применяться к любой функции, например:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main(){\n \n    doWork()\n \n    println(\"Hello Coroutines\")\n}\nsuspend fun doWork()= coroutineScope{\n    launch{\n        for(i in 0..5){\n            println(i)\n            delay(400L)\n        }\n    }\n}"
          },
          {
            "type": "subtitle",
            "content": "\nЗапуск нескольких корутин"
          },
          {
            "type": "text",
            "content": "Подобным образом можно запускать в одной функции сразу несколько корутин. И они будут выполняться одновременно. Например:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main()= coroutineScope{\n \n    launch{\n        for(i in 0..5){\n            delay(400L)\n            println(i)\n        }\n    }\n    launch{\n        for(i in 6..10){\n            delay(400L)\n            println(i)\n        }\n    }\n \n    println(\"Hello Coroutines\")\n}"
          },
          {
            "type": "text",
            "content": "Функция coroutineScope(), которая создает область корутин, будет ожидать завершения всех определенных в этой области корутин. \nТо есть функция main завршит выполнение, когда будут завершены обе корутины."
          },
          {
            "type": "text",
            "content": "И в моем случае я получу следующий консольный вывод (данный вывод строго не детерминирован):"
          },
          {
            "type": "code",
            "content": "Hello Coroutines\n6\n0\n7\n1\n8\n2\n9\n3\n10\n4\n5"
          },
          {
            "type": "subtitle",
            "content": "\nrunBlocking"
          },
          {
            "type": "text",
            "content": "Кроме функции coroutineScope для создания контекста корутины может применяться функция runBlocking."
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nfun main() = runBlocking{\n    launch{\n        for(i in 0..5){\n            delay(400L)\n            println(i)\n        }\n    }\n \n    println(\"Hello Coroutines\")\n}"
          },
          {
            "type": "text",
            "content": "Функция runBlocking блокирует вызывающий поток, пока все корутины внутри вызова runBlocking { ... } не завершат свое выполнение.  \nВ этом собственно основное отличие runBlocking от coroutineScope: coroutineScope не блокирует вызывающий поток, а просто приостанавливает выполнение, освобождания  поток для использования другими ресурсами."
          },
          {
            "type": "subtitle",
            "content": "\nВложенные корутины"
          },
          {
            "type": "text",
            "content": "Одна корутина может содержать другие корутины. Например:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n \n    launch{\n        println(\"Outer coroutine\")\n        launch{\n            println(\"Inner coroutine\")\n            delay(400L)\n        }\n    }\n \n    println(\"End of Main\")\n}"
          },
          {
            "type": "text",
            "content": "И подобным образом внешние корутины определяют область для вложенных корутин и управляют их жизненным циклом."
          }

        ]
      },
      {
        "id": 3,
        "title": "Launch и Job",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Launch и Job"
          },
          {
            "type": "text",
            "content": "Для создания корутины нужен построитель корутин. И одним из построителей корутин в пакете kotlinx.coroutines является функция  launch. \nВ принципе в прошлых темах уже было рассмотрено, как с помощью launch создавать корутины. Сейчас же рассмотрем некоторые аспекты подробнее."
          },
          {
            "type": "text",
            "content": "Прежде всего, launch(), как правило, применяется, когда нам не надо возвращать результат из корутины и когда нам ее надо выполнять одновременно  с другим кодом."
          },
          {
            "type": "subtitle",
            "content": "\nJob"
          },
          {
            "type": "text",
            "content": "Построитель корутин launch возвращает объект Job, с помощью которого можно управлять запущеной корутиной:"
          },
          {
            "type": "code",
            "content": "val job: Job = launch{\n    println(\"Some coroutin\")\n    delay(400L)\n}"
          },
          {
            "type": "text",
            "content": "Например, его метод join() позволяет ожидать, пока корутина не завершится. Например:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n \n    launch{\n        for(i in 1..5){\n            println(i)\n            delay(400L)\n        }\n    }\n \n    println(\"Start\")\n    println(\"End\")\n}"
          },
          {
            "type": "text",
            "content": "В данном случае мы получим следующий консольный вывод:"
          },
          {
            "type": "code",
            "content": "Start\nEnd\n1\n2\n3\n4\n5"
          },
          {
            "type": "text",
            "content": "Теперь явным образом применим интерфейс Job:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n \n    val job = launch{\n        for(i in 1..5){\n            println(i)\n            delay(400L)\n        }\n    }\n \n    println(\"Start\")\n    job.join() // ожидаем завершения корутины\n    println(\"End\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь корутина также запускается с помощью launch, однако благодаря методу join() полученного объекта Job  функция main остановит выполнение и будет ожидать завершения корутины и только после ее завершения продолжит работу. Соответственно в данном случае консольный вывод будет  иным:"
          },
          {
            "type": "code",
            "content": "Start\n1\n2\n3\n4\n5\nEnd"
          },
          {
            "type": "subtitle",
            "content": "\nОтложенное выполнение"
          },
          {
            "type": "text",
            "content": "По умолчанию построитель корутин launch создает и сразу же запускает корутину. \nОднако Kotlin также позволяет применять технику отложенного запуска  корутины (lazy-запуск), при котором корутина запускается при вызове метода start() объекта Job."
          },
          {
            "type": "text",
            "content": "Для установки отложенного запуска в функцию launch() передается значение start = CoroutineStart.LAZY"
          },
          {
            "type": "text",
            "content": "Чтобы увидеть разницу, сначала возьмем корутину со стандартным выполнением:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n \n    // корутина создана и запущена\n    launch( ) {\n        delay(200L)\n        println(\"Coroutine has started\")\n    }\n \n    delay(1000L)\n    println(\"Other actions in main method\")\n}"
          },
          {
            "type": "text",
            "content": "Чтобы позволить корутины выполниться до остальных действий в методе main, после определения корутины установлена задержка в 1 секунду. В итоге здесь получим следующий консольный вывод:"
          },
          {
            "type": "code",
            "content": "Coroutine has started\nOther actions in main method"
          },
          {
            "type": "text",
            "content": "Теперь применим отложенное выполнение:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n \n    // корутина создана, но не запущена\n    val job = launch(start = CoroutineStart.LAZY) {\n        delay(200L)\n        println(\"Coroutine has started\")\n    }\n \n    delay(1000L)\n    job.start() // запускаем корутину\n    println(\"Other actions in main method\")\n}"
          },
          {
            "type": "text",
            "content": "Теперь корутина только создается с помощью функции launch, но непосредственно она запускается только при вызове метода job.start(), соответственно мы получим другой результат  программы:"
          },
          {
            "type": "code",
            "content": "Other actions in main method\nCoroutine has started\n"
          }
        ]
      },
      {
        "id": 4,
        "title": "Async, Await и Deferred",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Async, Await и Deferred"
          },
          {
            "type": "text",
            "content": "Наряду с launch в пакете kotlinx.coroutines есть еще один построитель корутин - функция async.  Эта функция применяется, когда надо получить из корутины некоторый результат."
          },
          {
            "type": "text",
            "content": "async запускает отдельную корутину, которая выполняется параллельно с остальными корутинами. Например:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n \n    async{ printHello()}\n    println(\"Program has finished\")\n}\nsuspend fun printHello(){\n    delay(500L)  // имитация продолжительной работы\n    println(\"Hello work!\")\n}"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Program has finished\nHello work!"
          },
          {
            "type": "text",
            "content": "Кроме того, async-корутина возвращает объект  Deferred, который ожидает получения результата корутины. (Интерфейс Deferred унаследован от интерфейса  Job, поэтому для также доступны весь функционал, определенный для интефейса Job)"
          },
          {
            "type": "text",
            "content": "Для получения результата из объекта Deferred применяется функция await(). Рассмотрим на примере:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n \n    val message: Deferred<String> = async{ getMessage()}\n    println(\"message: ${message.await()}\")\n    println(\"Program has finished\")\n}\nsuspend fun getMessage() : String{\n    delay(500L)  // имитация продолжительной работы\n    return \"Hello\"\n}"
          },
          {
            "type": "text",
            "content": "В данном случае для имитации продолжительной работы определена функция getMessage(), которая возвращает строку."
          },
          {
            "type": "text",
            "content": "С помощью функции async запускаем корутину, которая выполняет эту функцию."
          },
          {
            "type": "code",
            "content": "async{ getMessage()}"
          },
          {
            "type": "text",
            "content": "Поскольку функция getMessage() возвращает объект типа String, то возвращаемый корутиной объект представляет тип  Deferred<String> (объект Deferred типизиуется возвращаемым типом функции, то есть в данном случае типом String)."
          },
          {
            "type": "code",
            "content": "val message: Deferred<String> = async{ getMessage()}"
          },
          {
            "type": "text",
            "content": "Далее у объекта Deferred для получения результата функции getMessage() вызываем метод await(). Он ожидает, пока не будет  получен результат. Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "message: Hello\nProgram has finished"
          },
          {
            "type": "text",
            "content": "Поскольку функция getMessage() возвращает объект типа String, то метод await() в данном случае также будет возвращать строку,  которую мы могли бы, например, присвоить переменной:"
          },
          {
            "type": "code",
            "content": "val text: String = message.await()"
          },
          {
            "type": "text",
            "content": "При этом мы можем с помощью async запустить несколько корутин, которые будут выполняться параллельно:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n \n    val numDeferred1 = async{ sum(1, 2)}\n    val numDeferred2 = async{ sum(3, 4)}\n    val numDeferred3 = async{ sum(5, 6)}\n    val num1 = numDeferred1.await()\n    val num2 = numDeferred2.await()\n    val num3 = numDeferred3.await()\n \n    println(\"number1: $num1  number2: $num2  number3: $num3\")\n}\nsuspend fun sum(a: Int, b: Int) : Int{\n    delay(500L) // имитация продолжительной работы\n    return a + b\n}"
          },
          {
            "type": "text",
            "content": "Здесь запускается три корутины, каждая из которых выполняет функцию sum(). Эта функция складывает два числа и возвращает их сумму в виде объекта Int.  Поэтому корутины возвращают объект Deferred<Int>. Соответственно вызов метода await() у этого объекта возвратит объект Int, то есть  сумму двух чисел. При этом все три корутины будет запущены одновременно."
          },
          {
            "type": "subtitle",
            "content": "\nОтложенный запуск"
          },
          {
            "type": "text",
            "content": "По умолчанию построитель корутин async создает и сразу же запускает корутину. \nНо как и при создании корутины с помощью  launch для async-корутин можно применять технику отложенного запуска. Только в данном случае корутина запускается не только  при вызове метода start объекта Deferred (который усналедован от интерфейса Job), но также и с помощью  метода await() при обращении к результу корутины. \nНапример:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n \n    // корутина создана, но не запущена\n    val sum = async(start = CoroutineStart.LAZY){ sum(1, 2)}\n \n    delay(1000L)\n    println(\"Actions after the coroutine creation\")\n    println(\"sum: ${sum.await()}\")   // запуск и выполнение корутины\n}\nfun sum(a: Int, b: Int) : Int{\n    println(\"Coroutine has started\")\n    return a + b\n}"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Actions after the coroutine creation\nCoroutine has started\nsum: 3"
          },
          {
            "type": "text",
            "content": "Если необходимо, чтобы корутина еще до метода await() начала выполняться, то можно вызвать метод start():"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n \n    // корутина создана, но не запущена\n    val sum = async(start = CoroutineStart.LAZY){ sum(1, 2)}\n \n    delay(1000L)\n    println(\"Actions after the coroutine creation\")\n    sum.start()                      // запуск корутины\n    println(\"sum: ${sum.await()}\")   // получаем результат\n}\nfun sum(a: Int, b: Int) : Int{\n    println(\"Coroutine has started\")\n    return a + b\n}"
          }
        ]
      },
      {
        "id": 5,
        "title": "Диспетчер корутины",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Диспетчер корутины"
          },
          {
            "type": "text",
            "content": "Контекст корутины включает себя такой элемент как диспетчер корутины.  \nДиспетчер корутины определяет какой поток или какие потоки будут использоваться для выполнения корутины."
          },
          {
            "type": "text",
            "content": "Все построители корутины, в частности, функции launch и async в качестве необязательного параметра принимают  объект типа CoroutineContext, который может использоваться для определения диспетчера создаваемой корутины."
          },
          {
            "type": "text",
            "content": "Когда функция launch вызывается без параметров, она перенимает контекст, в котором она создается и запускается. \nНапример, используем  метод Thread.currentThread(), который предоставляет JDK, чтобы получить данные потока корутины:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n \n    launch {\n        println(\"Корутина выполняется на потоке: ${Thread.currentThread().name}\")\n    }\n    println(\"Функция main выполняется на потоке: ${Thread.currentThread().name}\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь с помощью переменной Thread.currentThread().name мы можем получить имя потока. И в данном случае мы получим консольный вывод наподобие следующего:"
          },
          {
            "type": "code",
            "content": "Функция main выполняется на потоке: main\nКорутина выполняется на потоке: DefaultDispatcher-worker-1"
          },
          {
            "type": "text",
            "content": "Мы видим, что функция main выполняется на потоке под названием \"main\" (который собственно и отведен для выполнения этой функции), а  корутина выполняется на другом потоке с названием DefaultDispatcher-worker-1. \nЕсли мы обратимся к отладчику корутин, то мы сможем увидеть применяемый корутиной диспетчер:"
          },
          {
            "type": "image",
            "content": "ch8ar5_1"
          },
          {
            "type": "text",
            "content": "Здесь мы видим, что корутина, которая выполняется в потоке \"DefaultDispatcher-worker-1\", применяет диспетчер Dispatcher.Default."
          },
          {
            "type": "text",
            "content": "Рассмотрим доступные типы диспетчеров:"
          },
          {
            "type": "text",
            "content": "\t• Dispatchers.Default: применяется по умолчанию, если тип диспетчера не указан явным образом.  Этот тип использует общий пул разделяемых фоновых потоков и подходит для вычислений, которые не работают с операциями ввода-вывода (операциями с файлами, базами данных, сетью) и  которые требуют интенсивного потребления ресурсов центрального процессора."
          },
          {
            "type": "text",
            "content": "\t• Dispatchers.IO: использует общий пул потоков, создаваемых по мере необходимости,  и предназначен для выполнения операций ввода-вывода (например, операции с файлами или сетевыми запросами)."
          },
          {
            "type": "text",
            "content": "\t• Dispatchers.Main: применяется в графических приложениях, например, в приложениях Android или JavaFX."
          },
          {
            "type": "text",
            "content": "\t• Dispatchers.Unconfined: корутина не закреплена четко за определенным потоком или пулом потоков. Она запускается в текущем  потоке до первой приостановки. После возобновления работы корутина продолжает работу в одном из потоков, который сторого не фиксирован.  Разработчики языка Kotlin в обычной ситуации не рекомендуют использовать данный тип."
          },
          {
            "type": "text",
            "content": "\t• newSingleThreadContext и newFixedThreadPoolContext: позволяют вручную задать поток/пул для выполнения корутины"
          },
          {
            "type": "text",
            "content": "И мы можем сами задать для корутины диспетчер, передав в функцию launch (а также async) соответствующее значение:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n \n    launch(Dispatchers.Default) {   // явным образом определяем диспетчер Dispatcher.Default\n        println(\"Корутина выполняется на потоке: ${Thread.currentThread().name}\")\n    }\n    println(\"Функция main выполняется на потоке: ${Thread.currentThread().name}\")\n}"
          },
          {
            "type": "subtitle",
            "content": "\nDispatchers.Unconfined"
          },
          {
            "type": "text",
            "content": "Тип Dispatchers.Unconfined запускает корутину в текущем вызывающем потоке до первой приостановки. После возобновления корутина продолжает работу в  одном из потоков, который строго не фиксирован. \nПодобный тип подходит для корутин, которым не требуется интенсивно потреблять время CPU или работать с общими данными,  наподобие объектов пользовательского интерфейса. \nПрименим данный тип:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n \n    launch(Dispatchers.Unconfined) {\n        println(\"Поток корутины (до остановки): ${Thread.currentThread().name}\")\n        delay(500L)\n        println(\"Поток корутины (после остановки): ${Thread.currentThread().name}\")\n    }\n \n    println(\"Поток функции main: ${Thread.currentThread().name}\")\n}"
          },
          {
            "type": "text",
            "content": "Консольный вывод:"
          },
          {
            "type": "code",
            "content": "Поток корутины (до остановки): main\nПоток функции main: main\nПоток корутины (после остановки): kotlinx.coroutines.DefaultExecutor"
          },
          {
            "type": "subtitle",
            "content": "\nnewSingleThreadContext"
          },
          {
            "type": "text",
            "content": "newSingleThreadContext вручную запускает поток с указанным именем:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n \n    launch(newSingleThreadContext(\"Custom Thread\")) {\n        println(\"Поток корутины: ${Thread.currentThread().name}\")\n    }\n \n    println(\"Поток функции main: ${Thread.currentThread().name}\")\n}"
          },
          {
            "type": "text",
            "content": "В данном случае для выполнения корутины будет запускаться поток с именем \"Custom Thread\". Консольный вывод:"
          },
          {
            "type": "code",
            "content": "Поток функции main: main\nПоток корутины: Custom Thread"
          },
          {
            "type": "text",
            "content": "В то же время выделенный поток является довольно затратным ресурсом.  И в реальном приложении подобый поток следует либо  освобождать с помощью функции close(), если он больше не нужен, либо  хранить в глобальной переменной и использовать его повторно для подобных задач  на протяжении работы приложения."
          }
        ]
      },
      {
        "id": 6,
        "title": "Отмена выполнения корутин",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Отмена выполнения корутин"
          },
          {
            "type": "text",
            "content": "При работе приложения может сложиться необходимость отменить выполнение корутины. \nНапример, в мобильном приложении запущена корутина для загрузки данных с  некоторого интернет-ресуса, но пользователь решил перейти к другой странице приложения, и ему больше не нужны эти данные. \nВ этом случае чтобы зря не тратить ресурсу  системы, мы можем предусмотреть отмену выполнения корутины."
          },
          {
            "type": "text",
            "content": "Для отмены выполнения корутины у объекта Job может применяться метод cancel():"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n \n    val downloader: Job = launch{\n        println(\"Начинаем загрузку файлов\")\n        for(i in 1..5){\n            println(\"Загружен файл $i\")\n            delay(500L)\n        }\n    }\n    delay(800L)     // установим задержку, чтобы несколько файлов загрузились\n    println(\"Надоело ждать, пока все файлы загрузятся. Прерву-ка я загрузку...\")\n    downloader.cancel()    // отменяем корутину\n    downloader.join()      // ожидаем завершения корутины\n    println(\"Работа программы завершена\")\n}"
          },
          {
            "type": "text",
            "content": "В данном случае определена корутина, которая имитирует загрузку файлов. В цикле пробегаемся от 1 до 5 и условно загружаем пять файлов."
          },
          {
            "type": "text",
            "content": "Далее вызов метода downloader.cancel() сигнализирует корутине, что надо прервать выполнение. \nЗатем с помощью метода join() ожидаем завершения  корутина, которая прервана. \nВ итоге получим консольный вывод наподобие следующего:"
          },
          {
            "type": "code",
            "content": "Начинаем загрузку файлов\nЗагружен файл 1\nЗагружен файл 2\nНадоело ждать, пока все файлы загрузятся. Прерву-ка я загрузку...\nРабота программы завершена"
          },
          {
            "type": "text",
            "content": "Также вместо двух методов cancel() и join() можно использовать один сборный метод cancelAndJoin():"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n \n    val downloader: Job = launch{\n        println(\"Начинаем загрузку файлов\")\n        for(i in 1..5){\n            println(\"Загружен файл $i\")\n            delay(500L)\n        }\n    }\n    delay(800L)\n    println(\"Надоело ждать, пока все файлы загрузятся. Прерву-ка я загрузку...\")\n    downloader.cancelAndJoin()    // отменяем корутину и ожидаем ее завершения\n    println(\"Работа программы завершена\")\n}"
          },
          {
            "type": "subtitle",
            "content": "\nОбработка исключения CancellationException"
          },
          {
            "type": "text",
            "content": "Все suspend-функции в пакете kotlinx.coroutines являются прерываемыми (cancellable). \nЭто значит, что они проверяют, прервана ли корутина.  И если ее выполнение прервано, они генерируют исключение типа CancellationException. И в самой корутине мы можем перехватить это исключение,  чтобы обработать отмену корутины. \nНапример:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n \n    val downloader: Job = launch{\n        try {\n            println(\"Начинаем загрузку файлов\")\n            for(i in 1..5){\n                println(\"Загружен файл $i\")\n                delay(500L)\n            }\n        }\n        catch (e: CancellationException ){\n            println(\"Загрузка файлов прервана\")\n        }\n        finally{\n            println(\"Загрузка завершена\")\n        }\n    }\n    delay(800L)\n    println(\"Надоело ждать. Прерву-ка я загрузку...\")\n    downloader.cancelAndJoin()    // отменяем корутину и ожидаем ее завершения\n    println(\"Работа программы завершена\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь код выполнения корутины обернут в конструкцию try. Если корутина будет прервана извне, то с помощью блока catch и  перехвата исключения CancellationException мы сможем обработать отмену корутины."
          },
          {
            "type": "text",
            "content": "И если нам надо выполнить некоторые завершающие действия, например, освободить используемые в корутине ресурсы - закрыть файлы, различные подключения к внешним ресурсам,  то это можно сделать в блоке finally. \nНо в данном случае в этом блоке просто выводим диагностическое сообщение."
          },
          {
            "type": "text",
            "content": "В итоге при вызове метода downloader.cancel() производейт отмена корутины. Будет сгенерировано исключение, и в корутине в блоке catch мы сможем ее  обработать. \nВ итоге получим следующий консольный вывод:"
          },
          {
            "type": "code",
            "content": "Начинаем загрузку файлов\nЗагружен файл 1\nЗагружен файл 2\nНадоело ждать. Прерву-ка я загрузку...\nЗагрузка файлов прервана\nЗагрузка завершена\nРабота программы завершена"
          },
          {
            "type": "subtitle",
            "content": "\nОтмена выполнения async-корутины"
          },
          {
            "type": "text",
            "content": "Подобным образом можно отменять выполнение и корутин, создаваемых с помощью функции async(). В этом случае обычно вызов метода await()  помещается в блок try:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope{\n \n    // создаем и запускаем корутину\n    val message = async {\n        getMessage()\n    }\n    // отмена корутины\n    message.cancelAndJoin()\n     \n    try {\n        // ожидаем получение результата\n        println(\"message: ${message.await()}\")\n    }\n    catch (e:CancellationException){\n        println(\"Coroutine has been canceled\")\n    }\n    println(\"Program has finished\")\n}\n \nsuspend fun getMessage() : String{\n    delay(500L)\n    return \"Hello\"\n}"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Coroutine has been canceled\nProgram has finished"
          }
        ]
      },
      {
        "id": 7,
        "title": "Каналы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Каналы"
          },
          {
            "type": "text",
            "content": "Каналы позволяют передавать потоки данных. В Kotlin каналы представлены интерфейсом Channel, у которого следует выделить два основных метода:"
          },
          {
            "type": "text",
            "content": "\t• abstract suspend fun send(element: E): Unit"
          },
          {
            "type": "text",
            "content": "\t  Отправляет объект element в канал"
          },
          {
            "type": "text",
            "content": "\t• abstract suspend fun receive(): E"
          },
          {
            "type": "text",
            "content": "\t  Получает данные из канала"
          },
          {
            "type": "text",
            "content": "Определим простейший канал, через который будем передавать числа типа Int:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.Channel\n \nsuspend fun main() = coroutineScope{\n \n    val channel = Channel<Int>()\n    launch {\n        for (n in 1..5) {\n            // отправляем данные через канал\n            channel.send(n)\n        }\n    }\n     \n    // получаем данные из канала\n    repeat(5) {\n        val number = channel.receive()\n        println(number)\n    }\n    println(\"End\")\n}"
          },
          {
            "type": "text",
            "content": "Основная функциональность каналов сосредочена в пакете kotlinx.coroutines.channels, соответственно импортируем из него тип Channel:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.channels.Channel"
          },
          {
            "type": "text",
            "content": "В программе определяем переменную, которая будет представлять канал:"
          },
          {
            "type": "code",
            "content": "val channel = Channel<Int>()"
          },
          {
            "type": "text",
            "content": "Поскольку через канал будут передаваться значения типа Int, то соответственно объект Channel типизирован типом Int."
          },
          {
            "type": "text",
            "content": "Затем с помощью функции launch создаем корутину, в которой в цикле передаем в канал числа от 1 до 5:"
          },
          {
            "type": "code",
            "content": "launch {\n    for (n in 1..5) {\n        // отправляем данные через канал\n        channel.send(n)\n    }\n}"
          },
          {
            "type": "text",
            "content": "В метод send() собственно передается то значение, которое мы хотим отправить через канал. Особенностью этого метода является то, что мы  можем его запустить только в корутине."
          },
          {
            "type": "text",
            "content": "Для получения данных из канала с помощью функции repeat() определяем функцию, которая будет выполнятся 5 раз - так как мы передаем в канал пять чисел:"
          },
          {
            "type": "code",
            "content": "repeat(5) {\n    val number = channel.receive()  // получаем значения из канала\n    println(number)\n}"
          },
          {
            "type": "text",
            "content": "Метод receive() возвращает извлекаемый из канала объект."
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "1\n2\n3\n4\n5\nEnd"
          },
          {
            "type": "text",
            "content": "\nДругой пример - отправка через канал строк:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.Channel\n \nsuspend fun main() = coroutineScope{\n \n    val channel = Channel<String>()\n    launch {\n        val users = listOf(\"Tom\", \"Bob\", \"Sam\")\n        for (user in users) {\n            println(\"Sending $user\")\n            channel.send(user)\n        }\n    }\n \n    repeat(3) {\n        val user = channel.receive()\n        println(\"Received: $user\")\n    }\n    println(\"End\")\n}"
          },
          {
            "type": "text",
            "content": "В даном случае в канал передаем три строки, соответственно функция repeat() три раза запускает получение данных из канала. Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Sending Tom\nReceived: Tom\nSending Bob\nReceived: Bob\nSending Sam\nReceived: Sam\nEnd"
          },
          {
            "type": "subtitle",
            "content": "\nЗакрытие канала"
          },
          {
            "type": "text",
            "content": "Чтобы указать, что в канале больше нет данных, его можно закрыть с помощью метода close().  Если для получения данных из канала применяется цикл for, то, получив сигнал о закрытии канала,  данный цикл получит все ранее посланные объекты до закрытия и завершит выполнение:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.Channel\n \nsuspend fun main() = coroutineScope{\n \n    val channel = Channel<String>()\n    launch {\n        val users = listOf(\"Tom\", \"Bob\", \"Sam\")\n        for (user in users) {\n            channel.send(user)  // Отправляем данные в канал\n        }\n        channel.close()  // Закрытие канала\n    }\n \n    for(user in channel) {  // Получаем данные из канала\n        println(user)\n    }\n    println(\"End\")\n}"
          },
          {
            "type": "subtitle",
            "content": "\nПаттерн producer-consumer"
          },
          {
            "type": "text",
            "content": "Рассмотренный выше пример по сути является распростаненным способом передачи данных от одной корутины к другой. \nИ чтобы упростить написание подобного кода,  Kotlin предоставляет ряд дополнительных функций.\nТак, функция produce() представляет построитель корутины, который создает корутину, в которой передаются данные в канал.  \nНапример, с помощью функции produce() мы можем определить новую функцию-корутину, которая будет отправлять определенные данные:"
          },
          {
            "type": "code",
            "content": "fun CoroutineScope.getUsers(): ReceiveChannel<String> = produce{\n    val users = listOf(\"Tom\", \"Bob\", \"Sam\")\n    for (user in users) {\n        send(user)\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь определяется функция getUsers(). Причем она определяется как функция интерфейса CoroutineScope. \nФункция должна возвращать  объект ReceiveChannel, типизированный типом передаваемых данных (в данном случае передаем значения типа String)."
          },
          {
            "type": "text",
            "content": "Функция getUsers() представляет корутину, создаваемую построителем корутин produce. \nВ корутине опять же проходим по списку строк и  с помощью функции send передаем в канал данные."
          },
          {
            "type": "text",
            "content": "Для потребления данных из канала может применяться метод consumeEach() объекта ReceiveChannel, который по сути заменяет цикл for. \nОн принимает функцию, в  которую в качестве параметра передается получаемый из канала объект:"
          },
          {
            "type": "code",
            "content": "val users = getUsers()\nusers.consumeEach { user -> println(user) }"
          },
          {
            "type": "text",
            "content": "Полный код программы:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n \nsuspend fun main() = coroutineScope{\n \n    val users = getUsers()\n    users.consumeEach { user -> println(user) }\n    println(\"End\")\n}\n \nfun CoroutineScope.getUsers(): ReceiveChannel<String> = produce{\n    val users = listOf(\"Tom\", \"Bob\", \"Sam\")\n    for (user in users) {\n        send(user)\n    }\n}"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Tom\nBob\nSam\nEnd"
          }
        ]
      }
    ]
  },
  {
    "chapterId": 9,
    "chapterTitle": "Асинхронные потоки",
    "articles": [
      {
        "id": 1,
        "title": "Введение в асинхронные потоки",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Введение в асинхронные потоки"
          },
          {
            "type": "text",
            "content": "Корутины позволяют возвращать одиночные значения. Для этого мы можем, к примеру, создавать корутину с помощью построителя async. \nНо Kotlin также позволяет создавать асинхронные  потоки (Asynchronous Flow), которые возвращают набор объектов."
          },
          {
            "type": "text",
            "content": "В принципе для получения набора объектов мы могли бы в корутине возвращать коллекцию элементов, например, список List, наподобие следующего:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.*\n \nsuspend fun main() = coroutineScope<Unit>{\n    launch {\n        getUsers().forEach { user -> println(user) }\n    }\n}\n \nsuspend fun getUsers(): List<String> {\n    delay(1000L)  // имитация продолжительной работы\n    return listOf(\"Tom\", \"Bob\", \"Sam\")\n}"
          },
          {
            "type": "text",
            "content": "Однако проблема таких коллекций в том, что они одномоментно возвращают все объекты. \nНапример, если в списке ожидается 1000 объектов, то соответственно пока функция getUsers()  не возвратит список из 1000 объектов (например, получая их из базы данных или из внешнего интернет-ресурса), мы не сможем манипулировать объектами из этого списка."
          },
          {
            "type": "text",
            "content": "Эту проблему в Kotlin как раз и позволяют решить асинхронные потоки. Изменим пример выше с применением асинхронных потоков:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.*\n \nsuspend fun main(){\n    getUsers().collect { user -> println(user) }\n}\n \nfun getUsers(): Flow<String> = flow {\n    val database = listOf(\"Tom\", \"Bob\", \"Sam\")  // условная база данных\n    var i = 1;\n    for (item in database){\n        delay(400L) // имитация продолжительной работы\n        println(\"Emit $i item\")\n        emit(item) // емитируем значение\n        i++\n    }\n}"
          },
          {
            "type": "text",
            "content": "Для создания асинхронного потока данных применяется интерфейс Flow. То есть по сути асинхронный поток - это объект Flow. Он типизируется  типом тех данных, которые должны передаваться в потоке. \nВ данном случае передаем строки, поэтому Flow типизируется типом String."
          },
          {
            "type": "code",
            "content": "fun getUsers(): Flow<String>"
          },
          {
            "type": "text",
            "content": "При этом при определении функции-потока (в данном случае функции getUsers) необязательно использовать модификатор suspend."
          },
          {
            "type": "text",
            "content": "Для создания объекта Flow применяется специальная функция flow()"
          },
          {
            "type": "code",
            "content": "fun getUsers(): Flow<String> = flow {\n     \n    // создание асинхронного потока в функции flow\n}"
          },
          {
            "type": "text",
            "content": "В самой функции в данном случае имитируется получение объектов из условной базы данных, коей здесь для простоты служит список List. \nВ цикле пробегаемся по этому  списку и отправляем в поток текущий объект с помощью функции emit():"
          },
          {
            "type": "code",
            "content": "emit(item) // передаем значение в поток"
          },
          {
            "type": "text",
            "content": "Это ключевой момент. Благодаря этому внешний код сможет получит переданное через emit() в поток значение и использовать его."
          },
          {
            "type": "text",
            "content": "Для индикации номера отправляемого объекта я добавил переменную-счетчик i, которая увеличивается при переходе к другому объекту списка.  \nВывод номера отправляемого объекта позволяет увидеть, что получение внешним кодом объектов из списка происходит по мере его передачи в поток с помощью функции emit(), а не когда будут отправлены  все объекты из списка."
          },
          {
            "type": "text",
            "content": "Во внешнем коде в функции main вызываем функцию-поток getUsers(). \nДля управления объектами из потока для интерфейса Flow определен ряд  функций, одной из которых является функция collect(). \nВ качестве параметра она принимает функцию, в которую передает эмитируемый объект из потока. \nТак, в данном случае  это просто функция вывода на консоль:"
          },
          {
            "type": "code",
            "content": "getUsers().collect { user -> println(user) }"
          },
          {
            "type": "text",
            "content": "В итоге мы получим следующий консольный вывод:"
          },
          {
            "type": "code",
            "content": "Emit 1 item\nTom\nEmit 2 item\nBob\nEmit 3 item\nSam"
          },
          {
            "type": "text",
            "content": "Таким образом, программа не ждет, когда функция getUsers возвратит все строки. А получает строки по мере их отправки в поток через функцию emit()."
          },
          {
            "type": "text",
            "content": "Другой пример - создадим и используем асинхронный поток чисел:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n    getNumbers().collect { number -> println(number) }\n}\n \nfun getNumbers(): Flow<Int> = flow{\n    for(item in 1..5){\n        emit(item * item)\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь в принципе все то же самое. Функция getNumbers() представляет асинхронный поток объектов Int. В качестве объектов в поток добавляются  квадраты чисел от 1 до 5. Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "1\n4\n9\n16\n25"
          },
          {
            "type": "subtitle",
            "content": "\nЗапуск Flow"
          },
          {
            "type": "text",
            "content": "Стоит отметить, что асинхронный поток не запускается, пока не будет применена терминальная операция над получаемыми даными, например, функция collect():"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val numberFlow = getNumbers()       // поток создан, но не запущен\n    println(\"numberFlow has created\")\n    println(\"launch collect function\")\n    numberFlow.collect { number -> println(number) }   // запуск потока\n}\n \nfun getNumbers() = flow{\n    println(\"numberFlow has started\")\n    for(item in 1..5){\n        emit(item * item)\n    }\n}"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "numberFlow has created\nlaunch collect function\nnumberFlow has started\n1\n4\n9\n16\n25"
          }
        ]
      },
      {
        "id": 2,
        "title": "Создание асинхронного потока",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Создание асинхронного потока"
          },
          {
            "type": "text",
            "content": "Для создания асинхронного потока можно применять различные способы. Рассмотрим три основных способа."
          },
          {
            "type": "subtitle",
            "content": "\nФункция flow"
          },
          {
            "type": "text",
            "content": "Функция-построитель потока flow() позволяет задать логику передачи объектов в поток. Она может применяться как к отдельной функции, так и сама по себе.  \nНапример, создание потока на базе функции:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val numberFlow = getNumbers()\n    numberFlow.collect{n -> println(n)}\n}\n \nfun getNumbers() = flow{\n    for(item in 1..5){\n        emit(item * item)\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь построитель flow создает поток на базе функции getNumbers(), передавая в поток квадраты значений от 1 до 5"
          },
          {
            "type": "text",
            "content": "Консольный вывод:"
          },
          {
            "type": "code",
            "content": "1\n4\n9\n16\n25"
          },
          {
            "type": "text",
            "content": "Определять поток в виде отдельной функции, как в примере выше, необязательно. Например:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val userFlow = flow {\n        val usersList = listOf(\"Tom\", \"Bob\", \"Sam\")\n        for (item in usersList){\n            emit(item)\n        }\n    }\n    userFlow.collect({user -> println(user)})\n}"
          },
          {
            "type": "text",
            "content": "Здесь определена переменная userFlow, которая имеет тип Flow<String> и которая представляет поток, создаваемый построителем flow. В  данном случае flow передает в поток объекты из списка строк. Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Tom\nBob\nSam"
          },
          {
            "type": "subtitle",
            "content": "\nФункция flowOf"
          },
          {
            "type": "text",
            "content": "Специальная функция-строитель flowOf() создает поток из набора переданных в функцию значений."
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val numberFlow : Flow<Int> = flowOf(1, 2, 3, 5, 8)\n    numberFlow.collect{n -> println(n)}\n}"
          },
          {
            "type": "text",
            "content": "В данном случае в функцию построителя асинхронного потока flowOf() передается 5 значений типа Int, поэтому создаваемый поток будет имет тип  Flow<Int>. \nВсе переданные значения будут автоматически эмитироваться в поток. А получить их можно также как и в общем случае, например, через функцию collect()."
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "1\n2\n3\n5\n8"
          },
          {
            "type": "text",
            "content": "Аналогичный пример со строками:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val userFlow = flowOf(\"Tom\", \"Sam\", \"Bob\")\n    userFlow.collect({user -> println(user)})\n}"
          },
          {
            "type": "subtitle",
            "content": "\nМетод asFlow"
          },
          {
            "type": "text",
            "content": "Стандартные коллекции и последовательности в Kotlin имеют метод расширения asFlow(), который позволяет преобразовать коллекцию или последовательность  в поток:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    // преобразование последовательности в поток\n    val numberFlow : Flow<Int> = (1..5).asFlow()\n    numberFlow.collect{n -> println(n)}\n \n    // преобразование коллекции List<String> в поток\n    val userFlow = listOf(\"Tom\", \"Sam\", \"Bob\").asFlow()\n    userFlow.collect({user -> println(user)})\n}"
          }
        ]
      },
      {
        "id": 3,
        "title": "Операции с потоками",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Операции с потоками"
          },
          {
            "type": "text",
            "content": "Для работы с потоками в Kotlin для интерфейса Flow определено ряд функций. \nВ зависимости от того, возвращают они конкретное значение или  обработанный поток эти функции делятся на два вида: терминальные функции и промежуточные функции. \nРассмотрим основные из них."
          },
          {
            "type": "subtitle",
            "content": "\nТерминальные функции потоков"
          },
          {
            "type": "text",
            "content": "Терминальные функции потоков (terminal operators) представляют suspend-функции, которые позволяют непосредственно получать объекты из потока или возвращают какое-то конечное значение:"
          },
          {
            "type": "text",
            "content": "\t• collect(): получает из потока переданные значения"
          },
          {
            "type": "text",
            "content": "\t• toList(): преобразует поток значений в коллекцию List"
          },
          {
            "type": "text",
            "content": "\t• toSet(): преобразует поток значений в коллекцию Set"
          },
          {
            "type": "text",
            "content": "\t• first() / firstOrNull(): получает первый объект из потока"
          },
          {
            "type": "text",
            "content": "\t• last() / lastOrNull(): получает последний объект из потока"
          },
          {
            "type": "text",
            "content": "\t• single() / singleOrNull(): ожидает получение одного объекта из потока"
          },
          {
            "type": "text",
            "content": "\t• count(): получает количество элементов в потоке"
          },
          {
            "type": "text",
            "content": "\t• reduce(): получает результат определенной операции над элементами потока"
          },
          {
            "type": "text",
            "content": "\t• fold(): получает результат определенной операции над элементами потока, в отличие от функции reduce() принимает начальное значение"
          },
          {
            "type": "subtitle",
            "content": "\nПромежуточные функции"
          },
          {
            "type": "text",
            "content": "Промежуточные функции (Intermediate operator) принимают поток и возвращают обработанный поток."
          },
          {
            "type": "text",
            "content": "\t• combine(): объединяет два потока в один, после применения к их элементам функции преобразования"
          },
          {
            "type": "text",
            "content": "\t• drop(): исключает из начала потока определенное количество значений и возвращает полученный поток"
          },
          {
            "type": "text",
            "content": "\t• filter(): фильтрует поток, оставляя те элементы, которые соответствуют условию"
          },
          {
            "type": "text",
            "content": "\t• filterNot(): фильтрует поток, оставляя те элементы, которые НЕ соответствуют условию"
          },
          {
            "type": "text",
            "content": "\t• filterNotNull(): фильтрует поток, удаляя все элементы, которые равны null"
          },
          {
            "type": "text",
            "content": "\t• map(): применяет к элементам потока фукцию преобразования"
          },
          {
            "type": "text",
            "content": "\t• onEach(): применяет к элементам потока определенную функцию перед тем, как они будут переданы в возвращаемый поток"
          },
          {
            "type": "text",
            "content": "\t• take(): выбирает из потока определенное количество элементов"
          },
          {
            "type": "text",
            "content": "\t• transform(): применяет к элементам потока функцию преобразования"
          },
          {
            "type": "text",
            "content": "\t• zip(): из двух потоков создает один, применяя к их элементам функцию преобразования"
          }
        ]
      },
      {
        "id": 4,
        "title": "count, take и drop",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Функции count, take и drop. Количество элементов в потоке"
          },
          {
            "type": "subtitle",
            "content": "\nФункция count"
          },
          {
            "type": "text",
            "content": "Оператор count получает количество объектов в потоке:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val userFlow = listOf(\"Tom\", \"Bob\", \"Sam\").asFlow()\n    println(\"Count: ${userFlow.count()}\")       // Count: 3\n}"
          },
          {
            "type": "text",
            "content": "Также мы можем передать в функцию count() условие в виде функции, которая возвращает объект Boolean, то есть true или false. \nТогда функция  count() возвратит количество элементов, которые соответствуют этому условию:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val userFlow = listOf(\"Tom\", \"Bob\", \"Kate\", \"Sam\", \"Alice\").asFlow()\n    val count = userFlow.count{ username -> username.length > 3 }\n    println(\"Count: $count\")       // Count: 2\n}"
          },
          {
            "type": "text",
            "content": "В данном случае в качестве условия передается функция username -> username.length > 3 . Ее параметр - это объект потока. Здесь мы говорим учитывать  строку, если ее длина больше 3 символов. \nВ итоге в приведеном списке только два объекта соответствуют этому условию, поэтому переменная count будет равна 2."
          },
          {
            "type": "subtitle",
            "content": "\nФункция take"
          },
          {
            "type": "text",
            "content": "Оператор take ограничивает количество элементов в потоке. В качестве параметра она принимает количество элементов с начала потока,  которые надо оставить в потоке:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val userFlow = listOf(\"Tom\", \"Bob\", \"Kate\", \"Sam\", \"Alice\").asFlow()\n    userFlow.take(3).collect{user -> println(user)}\n}"
          },
          {
            "type": "text",
            "content": "В примере выше оставляем первые три элемента:"
          },
          {
            "type": "code",
            "content": "Tom\nBob\nKate"
          },
          {
            "type": "subtitle",
            "content": "\nФункция drop"
          },
          {
            "type": "text",
            "content": "Оператор drop удаляет из потока определенное количество элементов. В качестве параметра она принимает количество элементов с начала потока,  которые надо убрать из потока:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val userFlow = listOf(\"Tom\", \"Bob\", \"Kate\", \"Sam\", \"Alice\").asFlow()\n    userFlow.drop(3).collect{user -> println(user)}\n}"
          },
          {
            "type": "text",
            "content": "В примере выше убираем первые три элемента, в итоге в потоке останется два последних элемента:"
          },
          {
            "type": "code",
            "content": "Sam\nAlice"
          }
        ]
      },
      {
        "id": 5,
        "title": "first, last, single",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Функции first, last, single"
          },
          {
            "type": "subtitle",
            "content": "\nfirst/firstOrNull"
          },
          {
            "type": "text",
            "content": "Метод first() получает первый объект списка:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val userFlow = listOf(\"Tom\", \"Bob\", \"Kate\", \"Sam\", \"Alice\").asFlow()\n    val firstUser = userFlow.first()\n    println(\"First User: $firstUser\")       // First User: Tom\n}"
          },
          {
            "type": "text",
            "content": "Также метод first() может в качестве параметра принимать функцию-условие, которая возвращает объект Boolean. Тогда first()  возвращает первый элемент потока, который соответствует этому условию:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val userFlow = listOf(\"Tom\", \"Bob\", \"Kate\", \"Sam\", \"Alice\").asFlow()\n    val firstUser = userFlow.first{ name-> name.length > 3}\n    println(\"First User: $firstUser\")       // First User: Kate\n}"
          },
          {
            "type": "text",
            "content": "Здесь мы получаем первый элемент, длина которого больше 3 символов. В потоке это строка \"Kate\"."
          },
          {
            "type": "text",
            "content": "Однако может сложиться ситуация, когда условию не соответствует ни один из элементов потока:"
          },
          {
            "type": "code",
            "content": "val userFlow = listOf(\"Tom\", \"Bob\", \"Sam\").asFlow()\nval firstUser = userFlow.first{ name-> name.length > 3}"
          },
          {
            "type": "text",
            "content": "Или поток банально пуст:"
          },
          {
            "type": "code",
            "content": "val userFlow = listOf<String>().asFlow()\nval firstUser = userFlow.first()"
          },
          {
            "type": "text",
            "content": "В обоих случаях при работе программы вылетит исключение. В этом случае мы, конечно, может обрабатывать исключение с помощью try..catch. \nОднако, в качестве  альтернативы Kotlin предоставляет метод firstOrNull(), который возвращает null, если поток пуст или ни один из его элементов не соответствуют условию:"
          },
          {
            "type": "code",
            "content": "val userFlow = listOf<String>().asFlow()\nval firstUser1 = userFlow.firstOrNull()\nval firstUser2 = userFlow.firstOrNull{ name-> name.length > 3}"
          },
          {
            "type": "text",
            "content": "В этом случае мы можем проверить полученное значение на null:"
          },
          {
            "type": "code",
            "content": "if(firstUser1 == null) \n    println(\"User not found\")\nelse\n    println(\"First User: $firstUser1\")"
          },
          {
            "type": "subtitle",
            "content": "\nlast / lastOrNull"
          },
          {
            "type": "text",
            "content": "Функция last() вытягивает из потока последний элемент, только в отличие от функции first() (по крайней мере для версии Kotlin 1.5.1) она  не принимает условие: также может принимать условие:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val userFlow = listOf(\"Tom\", \"Bob\", \"Alice\", \"Sam\").asFlow()\n    val lastUser = userFlow.last()\n    println(\"Last User: $lastUser\")       // Last User: Sam\n}"
          },
          {
            "type": "text",
            "content": "Если есть вероятность, что поток будет пуст, то можно использовать функцию lastOrNull, которая возвращает null в случае  отсутствия элементов:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val userFlow = listOf(\"Tom\", \"Bob\", \"Alice\", \"Sam\").asFlow()\n    val lastUser = userFlow.lastOrNull()\n    if(lastUser!=null) println(\"Last User: $lastUser\")\n}"
          },
          {
            "type": "subtitle",
            "content": "\nsingle / singleOrNull"
          },
          {
            "type": "text",
            "content": "Функция single() возвращает единственный элемент потока, если поток содержит только один элемент. Если  поток не содержит элементов генерируется исключение NoSuchElementException, а если в потоке больше одного элемента - исключение IllegalStateException."
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val userFlow = listOf(\"Tom\").asFlow()\n    try {\n        val singleUser = userFlow.single()\n        println(\"Single User: $singleUser\")\n    }\n    catch(e:Exception) { println(e.message)  }\n}"
          },
          {
            "type": "text",
            "content": "В качестве альтернативы можно использовать метод singleOrNull(), который возвращает null, если поток пуст или если в потоке больше одного элемента."
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val userFlow = listOf(\"Tom\", \"Bob\").asFlow()\n    val singleUser = userFlow.singleOrNull()\n    if(singleUser!=null)\n        println(\"Single User: $singleUser\")\n    else\n        println(\"Not found\")\n}"
          }
        ]
      },
      {
        "id": 6,
        "title": "map и transform",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Преобразование данных. Функции map и transform"
          },
          {
            "type": "subtitle",
            "content": "\nФункция map"
          },
          {
            "type": "text",
            "content": "Оператор map() преобразует данные потока. В качестве параметра он принимает функцию преобразования. Функция преобразования принимает  в качестве единственного параметра объект из потока и возвращает преобразованные данные."
          },
          {
            "type": "code",
            "content": "inline fun <T, R> Flow<T>.map(\n    crossinline transform: suspend (value: T) -> R\n): Flow<R> (source)"
          },
          {
            "type": "text",
            "content": "Рассмотрим на примере:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val peopleFlow = listOf(\n        Person(\"Tom\", 37),\n        Person(\"Sam\", 41),\n        Person(\"Bob\", 21)\n    ).asFlow()\n \n    peopleFlow.map{ person -> person.name }\n        .collect { personName -> println(personName) }\n}\n \ndata class Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "В данном случае определяем поток данных peopleFlow, который содержит объекты типа Person. Далее к этому потоку применяется функция  map(), в которую передается следующая функция преобразования:"
          },
          {
            "type": "code",
            "content": "person -> person.name"
          },
          {
            "type": "text",
            "content": "То есть функция преобразования принимает в качестве параметра person объект типа Person и возвращает значение его поля name - то есть строку.  Таким образом, функция map() из потока объектов Person создаст поток обектов String."
          },
          {
            "type": "text",
            "content": "Далее к полученному потоку объектов String применяем функцию collect(), в которой получаем каждую строку из потока и выводим ее на консоль:"
          },
          {
            "type": "code",
            "content": "collect { personName -> println(personName) }"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Tom\nSam\nBob"
          },
          {
            "type": "text",
            "content": "Другой пример:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val peopleFlow = listOf(\n        Person(\"Tom\", 37),\n        Person(\"Bill\", 5),\n        Person(\"Sam\", 14),\n        Person(\"Bob\", 21),\n    ).asFlow()\n \n    peopleFlow.map{ person -> object{\n        val name = person.name\n        val isAdult = person.age > 17\n    }}.collect { user -> println(\"name: ${user.name}   adult:  ${user.isAdult} \")}\n}\n \ndata class Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "В данном случае функция map преобразует поток данных типа Person в поток объектов анонимного типа, который определяет два поля: name (имя) и isAdult (больше ли пользователю 17 лет).  \nСоответственно в функции collect мы получаем объекты этого анонимного типа и выводим их данные на консоль. \nКонсольный вывод:"
          },
          {
            "type": "code",
            "content": "name: Tom   adult:  true \nname: Bill   adult:  false \nname: Sam   adult:  false \nname: Bob   adult:  true"
          },
          {
            "type": "subtitle",
            "content": "\nФункция transform"
          },
          {
            "type": "text",
            "content": "Оператор transform также позволяет выполнять преобразование объектов в потоке. В отличие от map она позволяет использовать  функцию emit(), чтобы передавать в поток произвольные объекты."
          },
          {
            "type": "code",
            "content": "inline fun <T, R> Flow<T>.transform(\n    crossinline transform: suspend FlowCollector<R>.(value: T) -> Unit\n): Flow<R> (source)"
          },
          {
            "type": "text",
            "content": "Оператор transform принимает функцию, которая получает в качестве параметра объект потока. Например:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val peopleFlow = listOf(\n        Person(\"Tom\", 37),\n        Person(\"Bill\", 5),\n        Person(\"Sam\", 14),\n        Person(\"Bob\", 21),\n    ).asFlow()\n \n    peopleFlow.transform{ person ->\n        if(person.age > 17){\n            emit(person.name)\n        }\n    }.collect { personName -> println(personName)}\n}\n \ndata class Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "В данном случае получаем в функции transform объект Person из потока. Если поле age этого объекта больше 17, то передаем его в новый поток  через функцию emit(). Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Tom\nBob"
          },
          {
            "type": "text",
            "content": "Причем при обработке одного объекта мы можем несколько раз вызывать функцию emit(), передавая таким образом в потоке несколько объектов:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val numbersFlow = listOf(2, 3, 4).asFlow()\n    numbersFlow.transform{ n ->\n        emit(n)\n        emit(n * n)\n    }.collect { n -> println(n)}\n}"
          },
          {
            "type": "text",
            "content": "Например, здесь преобразуем поток чисел. Причем в выходной поток передается само число и его квадрат. Таким образом, на консоли мы увидим:"
          },
          {
            "type": "code",
            "content": "2\n4\n3\n9\n4\n16"
          }
        ]
      },
      {
        "id": 7,
        "title": "Фильтрация данных",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Фильтрация данных"
          },
          {
            "type": "subtitle",
            "content": "\nФункция filter"
          },
          {
            "type": "text",
            "content": "Оператор filter выполняет фильтрацию объектов в потоке. В качестве параметра он принимает функцию-условие, которая получает объект потока и возвращает true (если объект  подходит фильтрацию) и false (если не проходит):"
          },
          {
            "type": "code",
            "content": "inline fun <T> Flow<T>.filter(\n    crossinline predicate: suspend (T) -> Boolean\n): Flow<T> (source)"
          },
          {
            "type": "text",
            "content": "Рассмотрим на примере:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val peopleFlow = listOf(\n        Person(\"Tom\", 37),\n        Person(\"Bill\", 5),\n        Person(\"Sam\", 14),\n        Person(\"Bob\", 21),\n    ).asFlow()\n \n    peopleFlow.filter{ person -> person.age > 17}\n        .collect { person -> println(\"name: ${person.name}   age:  ${person.age} \")}\n}\n \ndata class Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "Здесь для фильтрации применяется условие person.age > 17. Если возраст пользователя больше 17, то он оказывается в выходном потоке. Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "name: Tom   age:  37 \nname: Bob   age:  21"
          },
          {
            "type": "subtitle",
            "content": "\ntakeWhile"
          },
          {
            "type": "text",
            "content": "Кроме того, Kotlin предоставляет еще ряд операций фильтрации для различных ситуаций. Например, оператор takeWhile выбирает из потока элементы,  пока будет истино некоторое условие:"
          },
          {
            "type": "code",
            "content": "fun <T> Flow<T>.takeWhile(\n    predicate: suspend (T) -> Boolean\n): Flow<T>"
          },
          {
            "type": "text",
            "content": "Рассмотрим на примере:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val peopleFlow = listOf(\n        Person(\"Tom\", 37),\n        Person(\"Alice\", 32),\n        Person(\"Bill\", 5),\n        Person(\"Sam\", 14),\n        Person(\"Bob\", 25),\n    ).asFlow()\n \n    peopleFlow.takeWhile{ person -> person.age > 17}\n        .collect { person -> println(\"name: ${person.name}   age:  ${person.age} \")}\n}\n \ndata class Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "В данном случае оператор takeWhile будет извлекать в возвращаемый поток все объекты Person, у которых значение age больше 17. Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "name: Tom   age:  37 \nname: Alice   age:  32 "
          },
          {
            "type": "text",
            "content": "Из консольного вывода мы видим, что несмотря на то, что в потоке еще есть объекты Person, которые соответствуют условию, но столкнувшись с первым объектом, который не соответствует условию,  takeWhile перестает выбирать объекты в возвращаемый поток."
          },
          {
            "type": "subtitle",
            "content": "\ndropWhile"
          },
          {
            "type": "text",
            "content": "Оператор dropWhile противоположен по своему действию оператору takeWhile. dropWhile  удаляет из потока элементы, пока они не начнут соответствовать некоторому условию:"
          },
          {
            "type": "code",
            "content": "fun <T> Flow<T>.dropWhile(\n    predicate: suspend (T) -> Boolean\n): Flow<T>"
          },
          {
            "type": "text",
            "content": "Так, возьмем предыдущий пример, только вместо takeWhile используем dropWhile:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val peopleFlow = listOf(\n        Person(\"Tom\", 37),\n        Person(\"Alice\", 32),\n        Person(\"Bill\", 5),\n        Person(\"Sam\", 14),\n        Person(\"Bob\", 25),\n    ).asFlow()\n \n    peopleFlow.dropWhile{ person -> person.age > 17}\n        .collect { person -> println(\"name: ${person.name}   age:  ${person.age} \")}\n}\n \ndata class Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "В данном случае оператор dropWhile пропустит первые два объекта Person, которые соответствовуют условию person.age > 17.  Третий элемент потока НЕ соответствовует этому условию, поэтому начиная с третьего элемента все остальные элементы попадут в возвращаемый поток (даже если они опять же соответствуют данному условию). \nКонсольный вывод программы:"
          },
          {
            "type": "code",
            "content": "name: Bill   age:  5 \nname: Sam   age:  14 \nname: Bob   age:  25"
          }
        ]
      },
      {
        "id": 8,
        "title": "Сведение данных. reduce и fold",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Сведение данных. Функции reduce и fold"
          },
          {
            "type": "subtitle",
            "content": "\nФункция reduce"
          },
          {
            "type": "text",
            "content": "Оператор reduce сводит все значения потока к одному значению:"
          },
          {
            "type": "code",
            "content": "suspend fun <S, T : S> Flow<T>.reduce(\n    operation: suspend (accumulator: S, value: T) -> S\n): S (source)"
          },
          {
            "type": "text",
            "content": "reduce принимает функцию, которая имеет два параметра. Первый параметр при первом запуске представляет первый объект потока, а при последующих запусках -  результат функции над предыдущими объектами. А второй параметр функции - следующий объект."
          },
          {
            "type": "text",
            "content": "Например, у нас есть поток чисел, найдем сумму всех чисел в потоке:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val numberFlow = listOf(1, 2, 3, 4, 5).asFlow()\n    val reducedValue = numberFlow.reduce{ a, b -> a + b }\n    println(reducedValue)   // 15\n}"
          },
          {
            "type": "text",
            "content": "Здесь при первом запуске в функции в reduce параметр a равен 1, а параметр b равен 2."
          },
          {
            "type": "text",
            "content": "При втором запуске параметр a содержит результат предыдущего выполнения функции, то если число 1 + 2 = 3, а параметр b равен 3 - следующее число в потоке."
          },
          {
            "type": "text",
            "content": "Или другой пример со строками:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val userFlow = listOf(\"Tom\", \"Bob\", \"Kate\", \"Sam\", \"Alice\").asFlow()\n    val reducedValue = userFlow.reduce{ a, b -> \"$a $b\" }\n    println(reducedValue)   // Tom Bob Kate Sam Alice\n}"
          },
          {
            "type": "text",
            "content": "Здесь reduce соединяет все строки в одну."
          },
          {
            "type": "subtitle",
            "content": "\nФункция fold"
          },
          {
            "type": "text",
            "content": "Функция fold также сводит все элементы потока в один. Но в отличие от оператора reduce оператор fold  в качестве первого параметра принимает начальное значение:"
          },
          {
            "type": "code",
            "content": "inline suspend fun <T, R> Flow<T>.fold(\n    initial: R,\n    crossinline operation: suspend (acc: R, value: T) -> R\n): R (source)"
          },
          {
            "type": "text",
            "content": "Например:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val userFlow = listOf(\"Tom\", \"Bob\", \"Kate\", \"Sam\", \"Alice\").asFlow()\n    val foldedValue = userFlow.fold(\"Users:\", { a, b -> \"$a $b\" })\n    println(foldedValue)   // Users: Tom Bob Kate Sam Alice\n}"
          },
          {
            "type": "text",
            "content": "В данном случае начальным значением является строка \"Users:\", к которой затем добавляются остальные элементы потока данных."
          }
        ]
      },
      {
        "id": 9,
        "title": "Объединение потоков",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Объединение потоков"
          },
          {
            "type": "text",
            "content": "Оператор zip позволяет объединить два потока данных:"
          },
          {
            "type": "code",
            "content": "fun <T1, T2, R> Flow<T1>.zip(\n    other: Flow<T2>,\n    transform: suspend (T1, T2) -> R\n): Flow<R> (source)"
          },
          {
            "type": "text",
            "content": "Оператор zip принимает два параметра. Первый параметр - поток данных, с которым надо выполнить объединение. Второй параметр - собственно функция объединения. \nОна принимает соответствующие элементы обоих потоков в качестве параметров и возвращает результат их объединения."
          },
          {
            "type": "text",
            "content": "Например, соединим два потока:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val english = listOf(\"red\", \"yellow\", \"blue\").asFlow()\n    val russian = listOf(\"красный\", \"желтый\", \"синий\").asFlow()\n    english.zip(russian) { a, b -> \"$a: $b\" }\n        .collect { word -> println(word) }\n}"
          },
          {
            "type": "text",
            "content": "Здесь оператор zip последовательно перебирает элементы из обоих потоков - english и russian. \nЭлемент первого потока, на котором вызывается  оператор zip, передается в параметр a, а элемент второго потока - в параметр b. \nФункция соединения объединяет оба элемента в одну строку.  И каждая такая строка из двух элементов передается в качестве элемента в новый создаваемый поток. \nКонсольный вывод программы:"
          },
          {
            "type": "code",
            "content": "red: красный\nyellow: желтый\nblue: синий"
          },
          {
            "type": "text",
            "content": "Хотя в примере выше оператор zip объединял потоки одного типа - String и возвращал поток того же типа, но в реальности объединяемые потоки  могут представлять разные данные, а возвращаемый поток - еще один тип данных:"
          },
          {
            "type": "code",
            "content": "import kotlinx.coroutines.flow.*\n \nsuspend fun main(){\n \n    val names = listOf(\"Tom\", \"Bob\", \"Sam\").asFlow()\n    val ages = listOf(37, 41, 25).asFlow()\n    names.zip(ages) { name, age -> Person(name, age) }\n        .collect { person -> println(\"Name: ${person.name}   Age: ${person.age}\") } \n}\n \ndata class Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "В данном случае функция zip, которая вызывается на потоке типа String, объединяет его элементы с элементами потока типа Int. Причем результатом  такого объединения становится поток объектов типа Person. \nРезультат работы программы:"
          },
          {
            "type": "code",
            "content": "Name: Tom   Age: 37\nName: Bob   Age: 41\nName: Sam   Age: 25"
          }
        ]
      }
    ]
  },
  {
    "chapterId": 10,
    "chapterTitle": "Прочее",
    "articles": [
      {
        "id": 1,
        "title": "Основной синтаксис (повторение)",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Основной синтаксис"
          },
          {
            "type": "text",
            "content": "Это подборка базового синтаксиса с примерами."
          },
          {
            "type": "subtitle",
            "content": "\nТочка входа в программу"
          },
          {
            "type": "text",
            "content": "В Kotlin точкой входа в программу является функция main."
          },
          {
            "type": "code",
            "content": "fun main(){\n    println(\"Hello world!\")\n}"
          },
          {
            "type": "text",
            "content": "Другая форма main может принимать масссив строк String."
          },
          {
            "type": "subtitle",
            "content": "\nВывод в стандартный поток"
          },
          {
            "type": "text",
            "content": "Функция print() выводит свой аргумент в стандартный поток вывода."
          },
          {
            "type": "code",
            "content": "print(\"Hello \")\nprint(\"world!\")"
          },
          {
            "type": "text",
            "content": "Функция println() выводит свой аргумент и добавляет перевод строки, так что следующее, что вы выведите, появится на следующей строке."
          },
          {
            "type": "code",
            "content": "println(\"Hello world!\")\nprintln(1234)"
          },
          {
            "type": "subtitle",
            "content": "\nФункции"
          },
          {
            "type": "text",
            "content": "В Kotlin функция объявляется с помощью ключевого слова fun. В скобках,после названия указывается список параметров. После скобок, через двоеточие можно указать тип возвращаемого значения. И далее в фигурных скобках идет тело функции."
          },
          {
            "type": "code",
            "content": "fun имя_функции (параметры) : возвращаемый_тип{\n    выполняемые инструкции\n}"
          },
          {
            "type": "text",
            "content": "В качестве тела функции может выступать выражение. Тогда тип возвращаемого значения определяется автоматически."
          },
          {
            "type": "code",
            "content": "fun sum(a: Int, b: Int) = a + b"
          },
          {
            "type": "text",
            "content": "Параметры необязательны, так же как и тип возвращаемого значения, по умолчанию он будет Unit (void в Java)."
          },
          {
            "type": "code",
            "content": "// определение функции hello\nfun hello(){\n    println(\"Hello\")\n\nfun main() {\n \n    hello() // вызов функции hello\n    hello() // вызов функции hello\n    hello() // вызов функции hello\n}}"
          },
          {
            "type": "subtitle",
            "content": "\nПеременные"
          },
          {
            "type": "text",
            "content": "Неизменяемые (только для чтения) локальные переменные определяются с помощью ключевого слова val. Присвоить им значение можно только один раз."
          },
          {
            "type": "code",
            "content": "val a: Int = 1   // Инициализация при объявлении\nval b = 1        // Тип `Int` определен автоматически\nval c: Int       // Указывать тип обязательно, если переменная не инициализирована сразу\nc = 1            // Последующее присвоение"
          },
          {
            "type": "text",
            "content": "Изменяемые переменные объявляются с помощью ключевого слова var."
          },
          {
            "type": "code",
            "content": "var x = 5 // Тип `Int` определен автоматически\nx += 1"
          },
          {
            "type": "text",
            "content": "Вы можете объявлять глобальные переменные."
          },
          {
            "type": "code",
            "content": "val PI = 3.14\nvar x = 0\n\nfun incrementX() { \n    x += 1 \n}"
          },
          {
            "type": "subtitle",
            "content": "\nКомментарии"
          },
          {
            "type": "text",
            "content": "Также, как любой другой популярный современный язык, Kotlin поддерживает однострочные и многострочные (блочные) комментарии."
          },
          {
            "type": "code",
            "content": "// Это однострочный комментарий\n\n/* Это блочный комментарий\n   из нескольких строк. */"
          },
          {
            "type": "text",
            "content": "Блочные комментарии в Kotlin могут быть вложенными."
          },
          {
            "type": "code",
            "content": "/* Этот комментарий начинается здесь\n/* содержит вложенный комментарий */\nи заканчивается здесь. */"
          },
          {
            "type": "subtitle",
            "content": "\nСтроковые шаблоны"
          },
          {
            "type": "code",
            "content": "fun main(args: Array<String>) {\n  if (args.size == 0) return\n\n  print(\"Первый аргумент: ${args[0]}\")\n}"
          },
          {
            "type": "code",
            "content": "var a = 1\n// просто имя переменной в шаблоне:\nval s1 = \"a равно $a\" \n\na = 2\n// произвольное выражение в шаблоне:\nval s2 = \"${s1.replace(\"равно\", \"было равно\")}, но теперь равно $a\"\n\n/*\n  Результат работы программы:\n  a было равно 1, но теперь равно 2\n*/"
          },
          {
            "type": "subtitle",
            "content": "\nУсловные выражения"
          },
          {
            "type": "code",
            "content": "fun maxOf(a: Int, b: Int): Int {\n    if (a > b) {\n        return a\n    } else {\n        return b\n    }\n}"
          },
          {
            "type": "text",
            "content": "В Kotlin if может быть использован как выражение (т. е. if … else возвращает значение):"
          },
          {
            "type": "code",
            "content": "fun maxOf(a: Int, b: Int) = if (a > b) a else b"
          },
          {
            "type": "subtitle",
            "content": "\nЦикл for"
          },
          {
            "type": "text",
            "content": "Цикл for обеспечивает перебор всех значений, поставляемых итератором. Например, выведем все квадраты чисел от 1 до 9, используя цикл for: "
          },
          {
            "type": "code",
            "content": "for(n in 1..9){\n    print(\"${n * n} \")\n}"
          },
          {
            "type": "code",
            "content": "1  4  9  16  25  36  49  64  81 "
          },
          {
            "type": "text",
            "content": "Циклы могут быть вложенными. Например, выведем таблицу умножения:"
          },
          {
            "type": "code",
            "content": "for(i in 1..9){\n    for(j in 1..9){\n        print(\"${i * j}  \")\n    }\n    println()\n}"
          },
          {
            "type": "text",
            "content": "С помощью цикла for можно перебирать элементы коллекции: "
          },
          {
            "type": "code",
            "content": "val items = listOf(\"яблоко\", \"банан\", \"киви\")\nfor (item in items) {\n    println(item)\n}"
          },
          {
            "type": "text",
            "content": "или"
          },
          {
            "type": "code",
            "content": "val items = listOf(\"яблоко\", \"банан\", \"киви\")\nfor (index in items.indices) {\n    println(\"${index} фрукт - это ${items[index]}\")\n}"
          },
          {
            "type": "subtitle",
            "content": "\nЦикл while"
          },
          {
            "type": "code",
            "content": "val items = listOf(\"яблоко\", \"банан\", \"киви\")\nvar index = 0\nwhile (index < items.size) {\n    println(\"${index} фрукт - это ${items[index]}\")\n    index++\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВыражение when"
          },
          {
            "type": "code",
            "content": "fun describe(obj: Any): String =\n    when (obj) {\n        1          -> \"Один\"\n        \"Hello\"    -> \"Приветствие\"\n        is Long    -> \"Long\"\n        !is String -> \"Не строка\"\n        else       -> \"Unknown\"\n    }"
          },
          {
            "type": "subtitle",
            "content": "\nИнтервалы"
          },
          {
            "type": "text",
            "content": "Проверка на вхождение числа в интервал с помощью оператора in."
          },
          {
            "type": "code",
            "content": "val x = 10\nval y = 9\nif (x in 1..y+1) {\n    println(\"принадлежит диапазону\")\n}"
          },
          {
            "type": "text",
            "content": "Проверка значения на выход за пределы интервала."
          },
          {
            "type": "code",
            "content": "val list = listOf(\"a\", \"b\", \"c\")\n\nif (-1 !in 0..list.lastIndex) {\n    println(\"-1 не принадлежит диапазону\")\n}\nif (list.size !in list.indices) {\n    println(\"размер списка также выходит за допустимый диапазон индексов списка\")\n}"
          },
          {
            "type": "text",
            "content": "Перебор значений в заданном интервале."
          },
          {
            "type": "code",
            "content": "for (x in 1..5) {\n    print(x)\n}"
          },
          {
            "type": "text",
            "content": "Или по арифметической прогрессии."
          },
          {
            "type": "code",
            "content": "for (x in 1..10 step 2) {\n    print(x)\n}\nprintln()\nfor (x in 9 downTo 0 step 3) {\n    print(x)\n}"
          },
          {
            "type": "subtitle",
            "content": "\nКоллекции"
          },
          {
            "type": "text",
            "content": "Итерация по коллекции."
          },
          {
            "type": "code",
            "content": "for (item in items) {\n    println(item)\n}"
          },
          {
            "type": "text",
            "content": "Проверка, содержит ли коллекция данный объект, с помощью оператора in."
          },
          {
            "type": "code",
            "content": "val items = setOf(\"яблоко\", \"банан\", \"киви\")\nwhen {\n    \"апельсин\" in items -> println(\"сочно\")\n    \"яблоко\" in items -> println(\"яблоко тоже подойдет\")\n}"
          },
          {
            "type": "text",
            "content": "Использование лямбда-выражения для фильтрации и модификации коллекции."
          },
          {
            "type": "code",
            "content": "fun main() {\n    val fruits = listOf(\"банан\", \"авокадо\", \"апельсин\", \"яблоко\", \"киви\")\n    fruits\n        .filter { it.startsWith(\"а\") }\n        .sortedBy { it }\n        .map { it.uppercase() }\n        .forEach { println(it) }\n}"
          },
          {
            "type": "code",
            "content": "АВОКАДО\nАПЕЛЬСИН"
          },
          {
            "type": "subtitle",
            "content": "\nСоздание классов и экземпляров"
          },
          {
            "type": "text",
            "content": "Для создания класса используйте ключевое слово class."
          },
          {
            "type": "code",
            "content": "class Matrix"
          },
          {
            "type": "text",
            "content": "Свойства класса могут быть перечислены при его объявлении или в его теле."
          },
          {
            "type": "code",
            "content": "class Rectangle(var height: Double, var length: Double) {\n    var perimeter = (height + length) * 2 \n}"
          },
          {
            "type": "text",
            "content": "Конструктор по умолчанию с параметрами, перечисленными при объявлении класса, доступен автоматически."
          },
          {
            "type": "code",
            "content": "val rectangle = Rectangle(5.0, 2.0)\nprintln(\"Периметр равен ${rectangle.perimeter}\")"
          },
          {
            "type": "text",
            "content": "Чтобы объявить наследование между классами используйте двоеточие (:). По умолчанию классы являются финальными, поэтому, чтобы сделать класс наследуемым, используйте open."
          },
          {
            "type": "code",
            "content": "open class Shape\n\nclass Rectangle(var height: Double, var length: Double): Shape() {\n    var perimeter = (height + length) * 2 \n}"
          },
          {
            "type": "subtitle",
            "content": "\nNullable-значения и проверка на null"
          },
          {
            "type": "text",
            "content": "Ссылка должна быть явно объявлена как nullable (символ ? в конце имени), когда она может принимать значение null."
          },
          {
            "type": "text",
            "content": "Возвращает null, если str не содержит числа."
          },
          {
            "type": "code",
            "content": "fun readInt(str: String): Int? {\n  // ...\n}"
          },
          {
            "type": "text",
            "content": "Использование функции, возвращающей null:"
          },
          {
            "type": "code",
            "content": "fun printProduct(arg1: String, arg2: String) {\n    val x = parseInt(arg1)\n    val y = parseInt(arg2)\n    \n    // Использование `x * y` приведет к ошибке, потому что они могут содержать null\n    if (x != null && y != null) {\n        // x и y автоматически приведены к не-nullable после проверки на null\n    print(x * y)\n    }\n    else {\n        println(\"'$arg1' или '$arg2' не число\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "или"
          },
          {
            "type": "code",
            "content": "// ...\nif (x == null) {\n    print(\"Неверный формат числа arg1: '$arg1'\")\n    return\n}\nif (y == null) {\n    print(\"Неверный формат числа arg2: '$arg2'\")\n    return\n}\n\n// x и y автоматически приведены к не-nullable после проверки на null\n  print(x * y)"
          },
          {
            "type": "subtitle",
            "content": "\nПроверка типа и автоматическое приведение типов"
          },
          {
            "type": "text",
            "content": "Оператор is проверяет, является ли выражение экземпляром заданного типа. Если неизменяемая локальная переменная или свойство уже проверены на определенный тип, то в дальнейшем нет необходимости явно приводить к этому типу:"
          },
          {
            "type": "code",
            "content": "fun getStringLength(obj: Any): Int? {\n    if (obj is String) {\n        // в этом блоке `obj` автоматически преобразован в `String`\n        return obj.length\n    }\n\n    // `obj` имеет тип `Any` вне блока проверки типа\n    return null\n}"
          },
          {
            "type": "text",
            "content": "или"
          },
          {
            "type": "code",
            "content": "fun getStringLength(obj: Any): Int? {\n    if (obj !is String) return null\n\n    // в этом блоке `obj` автоматически преобразован в `String`\n    return obj.length\n}"
          },
          {
            "type": "text",
            "content": "или даже"
          },
          {
            "type": "code",
            "content": "fun getStringLength(obj: Any): Int? {\n    // `obj` автоматически преобразован в `String` справа от оператора `&&`\n    if (obj is String && obj.length > 0) {\n        return obj.length\n    }\n\n    return null\n}"
          }
        ]
      },
      {
        "id": 2,
        "title": "Идиомы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Идиомы"
          },
          {
            "type": "text",
            "content": "Набор различных часто используемых идиом в языке Kotlin."
          },
          {
            "type": "subtitle",
            "content": "\nЗначения по умолчанию для параметров функций"
          },
          {
            "type": "code",
            "content": "fun foo(a: Int = 0, b: String = \"\") { ... }"
          },
          {
            "type": "subtitle",
            "content": "\nФильтрация списка"
          },
          {
            "type": "code",
            "content": "val positives = list.filter { x -> x > 0 }"
          },
          {
            "type": "text",
            "content": "Или короче: "
          },
          {
            "type": "code",
            "content": "val positives = list.filter { it > 0 }"
          },
          {
            "type": "subtitle",
            "content": "\nПроверка наличия элемента в коллекции"
          },
          {
            "type": "code",
            "content": "if (\"john@example.com\" in emailsList) { ... }\n\nif (\"jane@example.com\" !in emailsList) { ... }"
          },
          {
            "type": "subtitle",
            "content": "\nФорматирование строк"
          },
          {
            "type": "code",
            "content": "println(\"Name $name\")"
          },
          {
            "type": "subtitle",
            "content": "\nПроверка объекта на принадлежность к определённому классу "
          },
          {
            "type": "code",
            "content": "when (x) {\n    is Foo -> ...\n    is Bar -> ...\n    else   -> ...\n}"
          },
          {
            "type": "subtitle",
            "content": "\nRead-only список"
          },
          {
            "type": "code",
            "content": "val list = listOf(\"a\", \"b\", \"c\")"
          },
          {
            "type": "subtitle",
            "content": "\nRead-only ассоциативный список (map)"
          },
          {
            "type": "code",
            "content": "val map = mapOf(\"a\" to 1, \"b\" to 2, \"c\" to 3)"
          },
          {
            "type": "subtitle",
            "content": "\nОбращение к ассоциативному списку"
          },
          {
            "type": "code",
            "content": "println(map[\"key\"])\nmap[\"key\"] = value"
          },
          {
            "type": "subtitle",
            "content": "\nИтерация по ассоциативному списку или списку пар"
          },
          {
            "type": "code",
            "content": "for ((key, value) in map) {\n    println(\"$key -> $value\")\n}"
          },
          {
            "type": "subtitle",
            "content": "\nИтерация по диапазону"
          },
          {
            "type": "code",
            "content": "for (i in 1..100) { ... }  // закрытый диапазон: включает 100\nfor (i in 1 until 100) { ... } // полуоткрытый диапазон: не включает 100\nfor (x in 2..10 step 2) { ... }\nfor (x in 10 downTo 1) { ... }\n(1..10).forEach { ... }"
          },
          {
          "type": "subtitle",
          "content": "\nЛенивые свойства"
          },
          {
            "type": "code",
            "content": "val p: String by lazy { ... }"
          },
          {
            "type": "text",
            "content": "Это означает, что значение p будет вычислено только при первом обращении к нему."
          },
          {
            "type": "subtitle",
            "content": "\nФункции-расширения"
          },
          {
            "type": "code",
            "content": "fun String.spaceToCamelCase() { ... }\n\n\"Convert this to camelcase\".spaceToCamelCase()"
          },
          {
            "type": "subtitle",
            "content": "\nСоздание синглтона (единичный объект)"
          },
          {
            "type": "code",
            "content": "object Resource {\n    val name = \"Name\"\n}"
          },
          {
            "type": "subtitle",
            "content": "\nСоздание экземпляра абстрактного класса"
          },
          {
            "type": "code",
            "content": "abstract class MyAbstractClass {\n    abstract fun doSomething()\n    abstract fun sleep()\n}\n\nfun main() {\n    val myObject = object : MyAbstractClass() {\n        override fun doSomething() {\n            // ...\n        }\n\n        override fun sleep() { // ...\n        }\n    }\n    myObject.doSomething()\n}"
          },
          {
            "type": "subtitle",
            "content": "\nСокращение для \"Если не null\""
          },
          {
            "type": "code",
            "content": "val files = File(\"Test\").listFiles()\n\nprintln(files?.size) // размер выводится, если размер файлов не равен null"
          },
          {
            "type": "subtitle",
            "content": "\nСокращение для \"Если не null, иначе\"  (Оператор Элвиса)"
          },
          {
            "type": "code",
            "content": "val files = File(\"Test\").listFiles()\n\nprintln(files?.size ?: \"empty\") // если файл равен null, выводится \"empty\"\n"
          },
          {
            "type": "subtitle",
            "content": "\nВыброс исключения при равенстве null"
          },
          {
            "type": "code",
            "content": "val values = ...\nval email = values[\"email\"] ?: throw IllegalStateException(\"Email is missing!\")"
          },
          {
            "type": "subtitle",
            "content": "\nПолучение первого элемента, возможно, пустой коллекции"
          },
          {
            "type": "code",
            "content": "val emails = ... // может быть пустой\nval mainEmail = emails.firstOrNull() ?: \"\""
          },
          {
            "type": "subtitle",
            "content": "\nВыполнение при неравенстве nul"
          },
          {
            "type": "code",
            "content": "val value = ...\n\nvalue?.let {\n    ... // этот блок выполняется, если value не равен null\n}"
          },
          {
            "type": "subtitle",
            "content": "\nReturn с оператором when"
          },
          {
            "type": "code",
            "content": "fun transform(color: String): Int {\n    return when (color) {\n        \"Red\" -> 0\n        \"Green\" -> 1\n        \"Blue\" -> 2\n        else -> throw IllegalArgumentException(\"Invalid color param value\")\n    }\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВыражение try-catch"
          },
          {
            "type": "code",
            "content": "fun test() {\n    val result = try {\n        count()\n    } catch (e: ArithmeticException) {\n        throw IllegalStateException(e)\n    }\n\n    // Working with result\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВыражение if"
          },
          {
            "type": "code",
            "content": "val y = if (x == 1) {\n    \"one\"\n} else if (x == 2) {\n    \"two\"\n} else {\n    \"other\"\n}"
          },
          {
            "type": "subtitle",
            "content": "\nФункции, состоящие из одного выражения"
          },
          {
            "type": "code",
            "content": "fun theAnswer() = 42"
          },
          {
            "type": "text",
            "content": "Что равносильно этому:"
          },
          {
            "type": "code",
            "content": "fun theAnswer(): Int {\n    return 42\n}"
          },
          {
            "type": "text",
            "content": "Для сокращения кода их можно эффективно совмещать с другими идиомами. Например, с when:"
          },
          {
            "type": "code",
            "content": "fun transform(color: String): Int = when (color) {\n    \"Red\" -> 0\n    \"Green\" -> 1\n    \"Blue\" -> 2\n    else -> throw IllegalArgumentException(\"Invalid color param value\")\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВызов нескольких методов объекта (with)"
          },
          {
            "type": "code",
            "content": "class Turtle {\n    fun penDown()\n    fun penUp()\n    fun turn(degrees: Double)\n    fun forward(pixels: Double)\n}\n\nval myTurtle = Turtle()\nwith(myTurtle) { // нарисует квадрат размером 100 pix\n    penDown()\n    for (i in 1..4) {\n        forward(100.0)\n        turn(90.0)\n    }\n    penUp()\n}"
          },
          {
            "type": "subtitle",
            "content": "\nNullable Boolean"
          },
          {
            "type": "code",
            "content": "val b: Boolean? = ...\nif (b == true) {\n    ...\n} else {\n    // `b` is false or null\n}"
          },
          {
            "type": "subtitle",
            "content": "\nОбмен значений переменных"
          },
          {
            "type": "code",
            "content": "var a = 1\nvar b = 2\na = b.also { b = a }"
          },
          {
            "type": "subtitle",
            "content": "\nОбозначение кода как незаконченного (TODO)"
          },
          {
            "type": "text",
            "content": "В стандартной библиотеке Kotlin есть функция TODO(), которая всегда выдает ошибку NotImplementedError. Её возвращаемый тип - Nothing, поэтому её можно использовать независимо от ожидаемого типа."
          },
          {
            "type": "code",
            "content": "fun calcTaxes(): BigDecimal = TODO(\"Waiting for feedback from accounting\")"
          }
        ]
      },
      {
        "id": 3,
        "title": "Стилистика кода",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Соглашение о стилистике кода"
          },
          {
            "type": "text",
            "content": "Общеизвестные и простые в использовании соглашения о стилистике кода жизненно важны для любого языка программирования. \nЗдесь предоставлены рекомендации по стилю кода и его организации для проектов, использующих Kotlin."
          },
          {
            "type": "subtitle",
            "content": "\nНастройка стиля в IDE"
          },
          {
            "type": "text",
            "content": "Две самые популярные IDE для Kotlin - IntelliJ IDEA и Android Studio обеспечивают широкую поддержку стиля кода."
          },
          {
            "type": "url",
            "content": "https://www.jetbrains.com/idea/"
          },
          {
            "type": "url",
            "content": "http://developer.android.com/studio"
          },
          {
            "type": "text",
            "content": "Вы можете настроить их для автоматического форматирования вашего кода в соответствии с заданным стилем."
          },
          {
            "type": "subtitle",
            "content": "\nСтруктура каталогов"
          },
          {
            "type": "text",
            "content": "В проектах, в которых используется только Kotlin, рекомендуемая структура каталогов соответствует структуре пакетов, при этом общий корневой пакет опущен. \nНапример, если весь код в проекте находится в пакете org.example.kotlin и его подпакетах, файлы с пакетом org.example.kotlin должны размещаться непосредственно в корневом каталоге, а файлы в org.example.kotlin.network.socket должны находиться в подкаталоге корневого каталога network/socket."
          },
          {
            "type": "subtitle",
            "content": "\nИмена файлов"
          },
          {
            "type": "text",
            "content": "Если Kotlin файл содержит один класс (возможно со связанными объявлениями верхнего уровня), то его имя должно совпадать с именем этого класса с добавлением расширения .kt. \nЕсли файл содержит несколько классов или только объявления верхнего уровня, выберите имя, описывающее содержимое файла, и назовите файл соответствующим образом. \nИспользуйте UpperCamelCase (так же известный как Pascal case), начиная с заглавной буквы, например, ProcessDeclarations.kt.\n\nИмена файлов должны описывать, что в них делает код. Поэтому при наименовании файла вам следует избегать слов, не несущих смысла."
          },
          {
            "type": "subtitle",
            "content": "\nОрганизация файла"
          },
          {
            "type": "text",
            "content": "Размещение нескольких объявлений (классов, функций верхнего уровня или свойств) в одном исходном файле Kotlin рекомендуется до тех пор, пока эти объявления тесно связаны друг с другом семантически, а размер файла остается разумным (не более нескольких сотен строк).\n\nВ частности, при определении функций-расширения для класса, которые актуальны для всех клиентов этого класса, поместите их в один файл с самим классом. \nПри определении функций-расширения, которые имеют смысл только для конкретного клиента, поместите их рядом с кодом этого клиента. \nИзбегайте создания файлов только для хранения всех расширений какого-либо класса."
          },
          {
            "type": "subtitle",
            "content": "\nСхема классов"
          },
          {
            "type": "text",
            "content": "Содержимое класса должно располагаться в следующем порядке:\n\n\t1. Объявления свойств и блоки инициализации\n\t2. Дополнительные конструкторы\n\t3. Объявления методов\n\t4. Вспомогательный объект\n\nНе сортируйте объявления методов по алфавиту или по видимости и не отделяйте обычные методы от методов-расширения. \nВместо этого соберите связанный код вместе, чтобы тот, кто читает класс сверху вниз, мог следовать логике происходящего. \nВыберите порядок (либо сначала материал более высокого уровня, либо наоборот) и придерживайтесь его.\n\nПоместите вложенные классы рядом с кодом, который их использует. \nЕсли эти классы предназначены для внешнего использования и на них нет ссылок внутри класса, поместите их в конце, после сопутствующего объекта."
          },
          {
            "type": "subtitle",
            "content": "\nПравила наименований"
          },
          {
            "type": "text",
            "content": "Правила наименования пакетов и классов в Kotlin довольно просты:\n\n\t• Имена пакетов всегда написаны в нижнем регистре и не содержат нижних подчеркиваний. Использование имен, состоящих из нескольких слов, обычно не рекомендуется, но, если вы не можете их не использовать, либо просто объедините их вместе, либо используйте при этом lowerCamelCase (org.example.myProject).\n\n\t• Имена классов и объектов начинаются с заглавной буквы и используют UpperCamelCase."
          },
          {
            "type": "code",
            "content": "open class DeclarationProcessor { /*...*/ }\n\nobject EmptyDeclarationProcessor : DeclarationProcessor() { /*...*/ }"
          },
          {
            "type": "subtitle",
            "content": "\nИмена функций"
          },
          {
            "type": "text",
            "content": "Имена функций, свойств и локальных переменных начинаются со строчной буквы и используют lowerCamelCase без нижнего подчеркивания."
          },
          {
            "type": "code",
            "content": "fun processDeclarations() { /*...*/ }\nvar declarationCount = 1"
          },
          {
            "type": "subtitle",
            "content": "\nИмена тестовых методов"
          },
          {
            "type": "text",
            "content": "В тестах (и только в тестах) вы можете использовать имена методов с пробелами, заключенными в обратный апостроф. \nОбратите внимание, что такие имена методов в настоящее время не поддерживаются средой Android. Подчеркивания в именах методов также разрешены в тестовом коде."
          },
          {
            "type": "code",
            "content": "class MyTestCase {\n     @Test fun `ensure everything works`() { /*...*/ }\n     \n     @Test fun ensureEverythingWorks_onAndroid() { /*...*/ }\n}"
          },
          {
            "type": "subtitle",
            "content": "\nИмена свойств"
          },
          {
            "type": "text",
            "content": "Имена констант (свойства, помеченные const, свойства верхнего уровня или объект val без функции get) должны использовать имена, разделенные подчеркиванием и написанные в верхнем регистре (SCREAMING_SNAKE_CASE)."
          },
          {
            "type": "code",
            "content": "const val MAX_COUNT = 8\nval USER_NAME_FIELD = \"UserName\""
          },
          {
            "type": "text",
            "content": "Имена свойств верхнего уровня или объектов, которые содержат объекты с поведением или изменяемыми данными, должны использовать имена lowerCamelCase."
          },
          {
            "type": "code",
            "content": "val mutableCollection: MutableSet<String> = HashSet()"
          },
          {
            "type": "subtitle",
            "content": "\nИмена для вспомогательных свойств"
          },
          {
            "type": "text",
            "content": "Если класс имеет два свойства, которые концептуально одинаковы, но одно из них является частью общедоступного API, а другое - деталью реализации, используйте символ нижнего подчеркивания в начале имени частного свойства:"
          },
          {
            "type": "code",
            "content": "class C {\n    private val _elementList = mutableListOf<Element>()\n    \n    val elementList: List<Element>\n         get() = _elementList\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВыбирайте хорошие имена"
          },
          {
            "type": "text",
            "content": "Имя класса обычно представляет собой существительное или словосочетание, объясняющее, что это за класс: List, PersonReader.\n\nИмя метода обычно представляет собой глагол или фразу с глаголом, объясняющую, что делает этот метод: close, readPersons. Имя также должно указывать, изменяет ли метод объект или возвращает новый. \nТак, sort сортирует коллекцию, а sorted возвращает отсортированную копию коллекции.\n\nИмена должны прояснять, какова цель того или иного элемента, поэтому лучше избегать использования бессмысленных слов (Manager, Wrapper) в именах.\n\nПри использовании аббревиатуры в качестве части имени объявления, пишите её в верхнем регистре, если она состоит из двух букв (IOStream); если аббревиатура длиннее, заглавной следует оставить только первую букву (XmlFormatter, HttpInputStream)."
          },
          {
            "type": "subtitle",
            "content": "\nФорматирование"
          },
          {
            "type": "subtitle",
            "content": "\nОтступы"
          },
          {
            "type": "text",
            "content": "Используйте четыре пробела для отступа. Не используйте табуляцию.\n\nОткрывающую фигурную скобку поместите в конец строки, где начинается конструкция, а закрывающую скобку на отдельной строке, выровненной по горизонтали с открывающей конструкцией."
          },
          {
            "type": "code",
            "content": "if (elements != null) {\n    for (element in elements) {\n        // ...\n    }\n}"
          },
          {
            "type": "subtitle",
            "content": "\nПробелы"
          },
          {
            "type": "text",
            "content": "\t• Используйте пробелы вокруг двоичных операторов (a + b). Исключение: не ставьте пробелы вокруг оператора “диапазон до” (0..i).\n\n\t• Не ставьте пробелы вокруг унарных операторов (a++).\n\n\t• Ставьте пробелы между ключевыми словами (if, when, for, and while) и соответствующей открывающей скобкой.\n\n\t• Не ставьте пробел перед открывающей скобкой в объявлении основного конструктора, объявлении метода или вызове метода."
          },
          {
            "type": "code",
            "content": "class A(val x: Int)\n\nfun foo(x: Int) { ... }\n\nfun bar() {\n    foo(1)\n}"
          },
          {
            "type": "text",
            "content": "\t•Никогда не ставьте пробел после (, [ или перед ], ).\n\n\t• Никогда не ставьте пробелы вокруг . или ?.\n\n\t• Ставьте пробел после //\n\n\t• Не ставьте пробелы вокруг угловых скобок, используемых для указания параметров типа\n\n\t• Не ставьте пробел вокруг ::\n\n\t• Не ставьте пробел перед вопросительным знаком ?, который используется для обозначения типа, допускающего обнуление: String?."
          },
          {
            "type": "text",
            "content": "Основное правило: избегайте любого горизонтального выравнивания. Переименование идентификатора в имя с другой длиной не должно влиять на форматирование."
          },
          {
            "type": "subtitle",
            "content": "\nЗаголовки классов"
          },
          {
            "type": "text",
            "content": "Классы с небольшим количеством параметрами конструктора можно писать на одной строчке."
          },
          {
            "type": "code",
            "content": "class Person(id: Int, name: String)"
          },
          {
            "type": "text",
            "content": "Классы с более длинными сигнатурами должны быть отформатированы так, чтобы каждый параметр находится в отдельной строке с отступом. \nКроме того, закрывающая скобка должна быть в новой строке. \nНаследование, вызов конструктора суперкласса или список реализованных интерфейсов должны располагаться в той же строке, что и скобка."
          },
          {
            "type": "code",
            "content": "class Person(\n    id: Int, \n    name: String,\n    surname: String\n) : Human(id, name) {\n    // ...\n}"
          },
          {
            "type": "subtitle",
            "content": "\nПорядок модификаторов"
          },
          {
            "type": "text",
            "content": "Если объявление содержит несколько модификаторов, всегда располагайте их в следующем порядке."
          },
          {
            "type": "code",
            "content": "public / protected / private / internal\nexpect / actual\nfinal / open / abstract / sealed / const\nexternal\noverride\nlateinit\ntailrec\nvararg\nsuspend\ninner\nenum / annotation / fun // модификатор в `fun interface` \ncompanion\ninline / value\ninfix\noperator\ndata"
          },
          {
            "type": "subtitle",
            "content": "\nАннотации"
          },
          {
            "type": "text",
            "content": "Если сигнатура функции не помещается в одной строке, используйте следующий синтаксис."
          },
          {
            "type": "code",
            "content": "fun longMethodName(\n    argument: ArgumentType = defaultValue,\n    argument2: AnotherArgumentType,\n): ReturnType {\n    // body\n}"
          },
          {
            "type": "text",
            "content": "Используйте обычный отступ (четыре пробела) для параметров функции. Это помогает обеспечить согласованность с параметрами конструктора.\n\nДля функции, состоящей из одного выражения, предпочтительно использовать выражение в качестве тела функции."
          },
          {
            "type": "code",
            "content": "fun foo(): Int {     // плохо\n    return 1 \n}\n\nfun foo() = 1        // хорошо"
          },
          {
            "type": "subtitle",
            "content": "\nСвойства"
          },
          {
            "type": "text",
            "content": "Для очень простых свойств, доступных только для чтения, используйте форматирование в одну строку."
          },
          {
            "type": "code",
            "content": "val isEmpty: Boolean get() = size == 0"
          },
          {
            "type": "text",
            "content": "Для более сложных свойств всегда помещайте ключевые слова get и set в отдельные строки."
          },
          {
            "type": "subtitle",
            "content": "\nОператоры управления потоком"
          },
          {
            "type": "text",
            "content": "Если условие операторов if или when многострочное, всегда используйте фигурные скобки вокруг тела оператора. \nДелайте отступ в каждой последующей строке условия в четыре пробела. Поместите закрывающую скобку условия вместе с открывающей фигурной скобкой в отдельной строке."
          },
          {
            "type": "code",
            "content": "if (!component.isSyncing &&\n    !hasAnyKotlinRuntimeInScope(module)\n) {\n    return createKotlinNotConfiguredPanel(module)\n}"
          },
          {
            "type": "text",
            "content": "Это поможет выровнять тела условия и инструкции.\n\nПоместите ключевые слова else, catch, finally, а также ключевое слово while цикла do-while, на ту же строку, что и предыдущая фигурная скобка."
          },
          {
            "type": "code",
            "content": "if (condition) {\n    // body\n} else {\n    // else part\n}\n\ntry {\n    // body\n} finally {\n    // cleanup\n}"
          },
          {
            "type": "text",
            "content": "Если ветвь оператора when состоит более чем из одной строки, рассмотрите возможность отделения её от остальных ветвей пустой строкой."
          },
          {
            "type": "code",
            "content": "private fun parsePropertyValue(propName: String, token: Token) {\n    when (token) {\n        is Token.ValueToken ->\n            callback.visitValue(propName, token.value)\n\n        Token.LBRACE -> { // ...\n        }\n    }\n}"
          },
          {
            "type": "text",
            "content": "Поместите короткие ветви на ту же линию, что и условие, без скобок."
          },
          {
            "type": "code",
            "content": "when (foo) {\n    true -> bar() // хорошо\n    false -> { baz() } // плохо\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВызовы методов"
          },
          {
            "type": "text",
            "content": "В длинных списках аргументов после открывающей скобки переходите на следующую строку. \nОтступы аргументов в четыре пробела. \nСгруппируйте несколько тесно связанных аргументов в одной строке."
          },
          {
            "type": "code",
            "content": "drawSquare(\n    x = 10, y = 10,\n    width = 100, height = 100,\n    fill = true\n)"
          },
          {
            "type": "subtitle",
            "content": "\nГруппировка цепочки вызовов"
          },
          {
            "type": "text",
            "content": "При группировке цепочки вызовов, расположите символ . или оператор ?. на следующей строке с обычным отступом."
          },
          {
            "type": "code",
            "content": "val anchor = owner\n    ?.firstChild!!\n    .siblings(forward = true)\n    .dropWhile { it is PsiComment || it is PsiWhiteSpace }"
          },
          {
            "type": "subtitle",
            "content": "\nЛямбда-выражения"
          },
          {
            "type": "text",
            "content": "В лямбда-выражениях фигурные скобки и стрелка, которая отделяет параметры от тела, отделяются пробелами. \nЕсли вызов включает только одну лямбду, желательно передавать её за пределами скобок."
          },
          {
            "type": "code",
            "content": "list.filter { it > 10 }"
          },
          {
            "type": "text",
            "content": "При объявлении имен параметров в многострочной лямбде поместите имена в первую строку, за которой следует стрелка и новая строка."
          },
          {
            "type": "code",
            "content": "appendCommaSeparated(properties) { prop ->\n    val propertyValue = prop.get(obj)  // ...\n}"
          },
          {
            "type": "text",
            "content": "Если список параметров слишком длинный, чтобы поместиться в строку, поместите стрелку в отдельную строку:"
          },
          {
            "type": "code",
            "content": "foo {\n   context: Context,\n   environment: Env\n   ->\n   context.configureEnv(environment)\n}"
          },
          {
            "type": "subtitle",
            "content": "\nДокументация комментариями"
          },
          {
            "type": "code",
            "content": "/**\n * Это документационный комментарий\n * на нескольких строках.\n */"
          },
          {
            "type": "code",
            "content": "/** Это короткий документационный комментарий. */"
          },
          {
            "type": "text",
            "content": "Следует избегать использования тегов @param и @return. \nВместо этого включите описание параметров и возвращаемых значений непосредственно в документационный комментарий и добавьте ссылки на параметры везде, где они упоминаются. \nИспользуйте @param и @return только тогда, когда требуется длинное описание, которое не вписывается в основной текст."
          },
          {
            "type": "code",
            "content": "// Не делайте так:\n\n/**\n * Возвращает абсолютное значение заданного числа.\n * @param number Число, для которого будет найдено абсолютное значение.\n * @return Абсолютное значение.\n */\nfun abs(number: Int): Int { /*...*/ }\n\n// Делайте так:\n\n/**\n * Возвращает абсолютное значение заданного [number].\n */\nfun abs(number: Int): Int { /*...*/ }"
          },
          {
            "type": "subtitle",
            "content": "\nИдиоматическое использование функций языка\n\nНеизменность"
          },
          {
            "type": "text",
            "content": "Предпочтительнее использовать неизменяемые данные. \nВсегда объявляйте локальные переменные и свойства как val, а не var, если они не будут изменены после инициализации.\n\nВсегда используйте неизменяемые коллекции интерфейсов (Collection, List, Set, Map) для объявления коллекций, которые не изменяются. \nПри использовании фабричных функций для создания экземпляров коллекции всегда используйте функции, возвращающие неизменяемые типы коллекций, когда это возможно."
          },
          {
            "type": "code",
            "content": "// Плохо: использование изменяемого типа коллекции для значения, которое не будет изменено\nfun validateValue(actualValue: String, allowedValues: HashSet<String>) { ... }\n\n// Хорошо: использование неизменяемого типа коллекции\nfun validateValue(actualValue: String, allowedValues: Set<String>) { ... }\n\n// Плохо: arrayListOf() возвращает ArrayList<T>, который является изменяемым типом\nval allowedValues = arrayListOf(\"a\", \"b\", \"c\")\n\n// Хорошо: listOf() возвращает List<T>\nval allowedValues = listOf(\"a\", \"b\", \"c\")"
          },
          {
            "type": "subtitle",
            "content": "\nУсловные операторы"
          },
          {
            "type": "text",
            "content": "Предпочтительно использовать эту форму выражения try, if и when."
          },
          {
            "type": "code",
            "content": "return if (x) foo() else bar()"
          },
          {
            "type": "code",
            "content": "return when(x) {\n    0 -> \"zero\"\n    else -> \"nonzero\"\n}"
          },
          {
            "type": "text",
            "content": "Выше изложенное предпочтительнее, чем:"
          },
          {
            "type": "code",
            "content": "if (x)\n    return foo()\nelse\n    return bar()"
          },
          {
            "type": "code",
            "content": "when(x) {\n    0 -> return \"zero\"\n    else -> return \"nonzero\"\n} "
          },
          {
            "type": "subtitle",
            "content": "\nif vs when"
          },
          {
            "type": "text",
            "content": "Для двоичных условий лучше использовать if. Например, используйте этот синтаксис с if:"
          },
          {
            "type": "code",
            "content": "if (x == null) ... else ..."
          },
          {
            "type": "text",
            "content": "вместо этого с when:"
          },
          {
            "type": "code",
            "content": "when (x) {\n    null -> // ...\n    else -> // ...\n}"
          },
          {
            "type": "text",
            "content": "Предпочтительнее использовать when, если есть три и более варианта."
          },
          {
            "type": "subtitle",
            "content": "\nЦиклы"
          },
          {
            "type": "text",
            "content": "Предпочтительнее использовать функции более высокого порядка (filter, map и т.д.), чем циклы. \nИсключение: forEach (лучше использовать обычный цикл for) используется только, если получатель forEach не может быть обнулен или forEach используется как часть более длинной цепочки вызовов.\n\nДелая выбор между циклом и сложным выражением, использующим несколько функций более высокого порядка, учитывайте стоимость операций, выполняемых в каждом конкретном случае, исходите из соображений производительности."
          },
          {
            "type": "subtitle",
            "content": "\nЦиклы для диапазонов"
          },
          {
            "type": "text",
            "content": "Используйте функцию until, чтобы использовать открытый диапазон в цикле."
          },
          {
            "type": "code",
            "content": "for (i in 0..n - 1) { /*...*/ }  // плохо\nfor (i in 0 until n) { /*...*/ }  // хорошо"
          },
          {
            "type": "subtitle",
            "content": "\nСтроки"
          },
          {
            "type": "text",
            "content": "Используйте строковые шаблоны вместо конкатенации строк.\n\nЧтобы сохранить отступ в многострочных строках, используйте trimIndent, когда результирующая строка не требует внутреннего отступа, и trimMargin, когда требуется внутренний отступ."
          },
          {
            "type": "code",
            "content": "println(\"\"\"\n    Not\n    trimmed\n    text\n    \"\"\"\n       )\n\nprintln(\"\"\"\n    Trimmed\n    text\n    \"\"\".trimIndent()\n       )\n\nprintln()\n\nval a = \"\"\"Trimmed to margin text:\n          |if(a > 1) {\n          |    return a\n          |}\"\"\".trimMargin()\n\nprintln(a)"
          }
        ]
      }
    ]
  }
]