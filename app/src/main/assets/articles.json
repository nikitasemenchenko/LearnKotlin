[
  {
    "chapterId": 1,
    "chapterTitle": "Введение в Kotlin",
    "articles": [
      {
        "id": 1,
        "title": "Установка необходимого",
        "blocks": [
          {
            "type": "text",
            "content": "Перед началом работы с Kotlin следует отметить, что нам потребуется JDK (Java Development Kit). Перейдем на страницу:"
          },
          {
            "type": "url",
            "content": "https://www.oracle.com/java/technologies/downloads/"
          },
          {
            "type": "image",
            "content": "ch1ar1_1"
          },
          {
            "type": "image",
            "content": "ch1ar1_2"
          },
          {
            "type": "text",
            "content": "Нажмем на кнопку Next. На следующем экране необходимо указать, в какую папку будет производиться установка:"
          },
          {
            "type": "image",
            "content": "ch1ar1_3"
          },
          {
            "type": "text",
            "content": "Оставим выбор папки по умолчанию и нажмем на Next для выполнения установки.\n\nПосле завершения установки JDK мы увидим вот такое окно:"
          },
          {
            "type": "image",
            "content": "ch1ar1_4"
          },
          {
            "type": "text",
            "content": "Готово! Теперь, благодаря JDK, Kotlin сможет использовать библиотеки, написанные на Java"
          },
          {
            "type": "subtitle",
            "content": "Установка самого языка"
          },
          {
            "type": "text",
            "content": "Часто, при разработке, используют программу - среду разработки Intellij IDEA, которая во многом облегчает написание приложений на Kotlin. Скачать ее можно по ссылке:"
          },
          {
            "type": "url",
            "content": "https://www.jetbrains.com/idea/download/"
          },
          {
            "type": "text",
            "content": "Загрузить компилятор непосредственно для самого языка Kotlin можно в самом низу страницы, по адресу:"
          },
          {
            "type": "url",
            "content": "https://github.com/JetBrains/kotlin/releases/latest/."
          },
          {
            "type": "image",
            "content": "ch1ar1_5"
          },
          {
            "type": "text",
            "content": "Загрузим и распакуем из архива папку kotlinc. В распакованном архиве в папке bin мы можем найти утилиту kotlinc - этои есть компилятор Kotlin."
          },
          {
            "type": "image",
            "content": "ch1ar1_6"
          },
          {
            "type": "text",
            "content": "Теперь нам нужно добавить эту директорию в переменную окружения PATH. Пишем в поиске \"переменные окружения\" (или \"system environment variables\" если язык системы - английский) и следуем инструкции:"
          },
          {
            "type": "image",
            "content": "ch1ar1_7"
          },
          {
            "type": "image",
            "content": "ch1ar1_8"
          },
          {
            "type": "image",
            "content": "ch1ar1_9"
          },
          {
            "type": "text",
            "content": "Здесь нам нужно указать путь к распакованной папке с компилятором (желательно чтобы эта папка была в корне диска С)."
          },
          {
            "type": "image",
            "content": "ch1ar1_10"
          },
          {
            "type": "text",
            "content": "Готово! Теперь у вас установлен язык программирования Kotlin."
          }
        ]
      },
      {
        "id": 2,
        "title": "Первая программа",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Первая программа на Kotlin в IntelliJ IDEA"
          },
          {
            "type": "text",
            "content": "Зайдем в IntelliJ IDEA и создадим новый пустой проект."
          },
          {
            "type": "image",
            "content": "ch1ar1_11"
          },
          {
            "type": "text",
            "content": "После этого откроется окно создания нового проекта:"
          },
          {
            "type": "image",
            "content": "ch1ar1_12"
          },
          {
            "type": "text",
            "content": "В левой части мы можем увидеть структуру проекта. Все файлы с исходным кодом помещаются в папку src. По умолчанию она пуста, и никаких файлов кода у нас в проекте пока нет. Поэтому добавим файл с исходным кодом."
          },
          {
            "type": "image",
            "content": "ch1ar1_13"
          },
          {
            "type": "text",
            "content": "После этого нам откроется небольшое окошко, в которое надо ввести имя файла. Пусть файл будет называться app:"
          },
          {
            "type": "image",
            "content": "ch1ar1_14"
          },
          {
            "type": "text",
            "content": "После нажатия на клавишу Enter в папку src будет добавлен новый файл с кодом Kotlin (в нашем случае - файл app.kt). А в центральной части откроется его содержимое - собственно исходный код. По умолчанию он пуст. Поэтому добавим в него пакой-нибудь примитивный код:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    println(\"Hello from Learn Kotlin!\")\n}"
          },
          {
            "type": "text",
            "content": "Запустим эту примитивную программу на выполнение. Для этого нажмем на значок Kotlin рядом с первой строкой кода или на название файла и выберем в появившемся меню пункт Run 'AppKt':"
          },
          {
            "type": "image",
            "content": "ch1ar1_15"
          },
          {
            "type": "text",
            "content": "После этого будет выполнено построение проекта, и скомпилированная программа будет запущена в консоли в IntelliJ IDEA:"
          },
          {
            "type": "image",
            "content": "ch1ar1_16"
          },
          {
            "type": "text",
            "content": "Поздравляю с Вашей первой программой на Kotlin!"
          }
        ]
      }
      ]
  },
  {
    "chapterId": 2,
    "chapterTitle": "Основы языка",
    "articles": [
      {
        "id": 1,
        "title": "Структура программы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Структура программы\n"
          },
          {
            "type": "subtitle",
            "content": "Функция main"
          },
          {
            "type": "text",
            "content": "Точкой входа в программу на языке Kotlin является функция main. Именно с этой функции начинается выполнение программы на Kotlin, поэтому эта функция должна быть в любой программе."
          },
          {
            "type": "text",
            "content": "Так, в прошлой теме была определена следующая функция main:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    println(\"Hello from LearnKotlin!\")\n}"
          },
          {
            "type": "text",
            "content": "Определение функции main() (в принципе как и других функций в Kotlin) начинается с ключевого слова fun. После fun указывается имя функции."
          },
          {
            "type": "text",
            "content": "После имени функции в скобках идет список параметров функции. Здесь функция main не принимает никаких параметров."
          },
          {
            "type": "text",
            "content": "Все действия, которые выполняет функция, заключаются в фигурные скобки. В данном случае единственное, что делает функция main, - вывод на консоль некоторого сообщения с помощью другой встроенной функции println()."
          },
          {
            "type": "subtitle",
            "content": "Инструкции и блоки кода"
          },
          {
            "type": "text",
            "content": "Основным строительным блоком программы на языке Kotlin являются инструкции (statement). Каждая инструкция выполняет некоторое действие, например, вызовы функций, объявление переменных и присвоение им значений. Например:"
          },
          {
            "type": "code",
            "content": "println(\"Hello from LearnKotlin!\")"
          },
          {
            "type": "text",
            "content": "Данная строка представляет встроенную функцию println(), которая выводит на консоль, некоторое сообщение"
          },
          {
            "type": "text",
            "content": "Стоит отметить, что в отличие от других похожих языков программирования, например, Java, в Kotlin не обязательно ставить после инструкции точку запятой. Каждая инструкция просто размещается на новой строке:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    println(\"Kotlin from LearnKotlin\")\n    println(\"Hello world!\")\n    println(\"Kotlin is a fun\")\n}"
          },
          {
            "type": "text",
            "content": "Тем не менее, если инструкции располагаются на одной строке, то чтобы их отделить друг от друга, надо указывать после инструкции точку с запятой:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    println(\"Kotlin from LearnKotlin\");println(\"Hello world!\");println(\"Kotlin is a fun\")\n}"
          },
          {
            "type": "subtitle",
            "content": "Комментарии"
          },
          {
            "type": "text",
            "content": "Код программы может содержать комментарии. Комментарии позволяют понять смысл программы, что делают те или иные ее части. При компиляции комментарии игнорируются."
          },
          {
            "type": "text",
            "content": "В Kotlin есть два типа комментариев: однострочный и многострочный. Однострочный комментарий размещается на одной строке после двойного слеша //. А многострочный комментарий заключается между символами /* текст комментария */. Например:"
          },
          {
            "type": "code",
            "content": "/*\n    многострочный комментарий\n    Функция main -\n    точка входа в программу\n*/\nfun main(){         // начало функции main\n \n    println(\"Hello METANIT.COM\") // вывод строки на консоль\n}                   // конец функции main"
          }
        ]
      },
      {
        "id": 2,
        "title": "Переменные",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Переменные"
          },
          {
            "type": "text",
            "content": "Переменная представляет именованный участок памяти, который хранит некоторое значение."
          },
          {
            "type": "text",
            "content": "Каждая переменная характеризуется определенным именем, типом данных и значением. Для определения переменной можно использовать либо ключевое слово val, либо ключевое слово var."
          },
          {
            "type": "text",
            "content": "Формальное определение переменной:"
          },
          {
            "type": "code",
            "content": "val|var имя_переменной: тип_переменной"
          },
          {
            "type": "text",
            "content": "Вначале идет слово val или var, затем имя переменной и через двоеточие тип переменной."
          },
          {
            "type": "text",
            "content": "Например, определим переменную age:"
          },
          {
            "type": "code",
            "content": "var age: Int"
          },
          {
            "type": "text",
            "content": "То есть в данном случае объявлена переменная age, которая имеет тип Int. Тип Int говорит о том, что переменная будет содержать целочисленные значения."
          },
          {
            "type": "text",
            "content": "После определения переменной ей можно присвоить значение (инициализировать):"
          },
          {
            "type": "code",
            "content": "fun main() {\n    var age: Int = 23\n    println(age)\n}"
          },
          {
            "type": "text",
            "content": "Обязательно нужно присваивать переменным некоторое значение до ее использования:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    var age: Int\n    println(age)// Ошибка, переменная не инициализирована\n}"
          },
          {
            "type": "subtitle",
            "content": "Изменяемые и неизменяемые переменные"
          },
          {
            "type": "text",
            "content": "Выше было сказано, что переменные могут объявляться как с помощью слова val, так и с помощью слова var.\nВ чем же разница?"
          },
          {
            "type": "text",
            "content": "С помощью ключевого слова val определяется неизменяемая переменная (immutable variable) или переменная только для чтения (read-only). То есть мы можем присвоить значение такой переменной только один раз, но изменить его после первого присвоения мы уже не сможем. Например, в следующем случае мы получим ошибку:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val age: Int\n    age = 23        // здесь норм - первое присвоение\n    age = 56        // здесь ошибка - переопределить значение переменной нельзя\n    println(age)\n}"
          },
          {
            "type": "text",
            "content": "А у переменной, которая определена с помощью ключевого слова var мы можем многократно менять значения (mutable variable):"
          },
          {
            "type": "code",
            "content": "fun main() {\n    var age: Int\n    age = 23\n    println(age)\n    age = 56\n    println(age)\n}"
          },
          {
            "type": "text",
            "content": "Поэтому если не планируется изменять значение переменной в программе, то лучше определять ее с ключевым словом val.\n"
          },
          {
            "type": "subtitle",
            "content": "Определение констант"
          },
          {
            "type": "text",
            "content": "Также Kotlin поддерживает константы времени компиляции. Для их определения применяются ключевые слова const val:"
          },
          {
            "type": "code",
            "content": "const val maxAge = 120  // константа\nfun main() {\n    println(maxAge)\n}"
          },
          {
            "type": "text",
            "content": "В данном случае maxAge является константой."
          },
          {
            "type": "text",
            "content": "Отличительной особенностью констант является то, что они на стадии компиляции должны иметь некоторое значение, и это значение изменить нельзя. Это накладывает на использование констант ряд ограничений:"
          },
          {
            "type": "text",
            "content": "1) Естественно нельзя изменить значение константы:"
          },
          {
            "type": "code",
            "content": "const val maxAge = 120  // константа\nfun main() {\n    maxAge = 1500   // ошибка \n    println(maxAge)\n}"
          },
          {
            "type": "text",
            "content": "Здесь при попытке присвоения константе maxAge нового значения в функции main мы столкнемся с ошибкой на стадии компиляции. Если мы работаем в среде Intellij IDEA или Android Studio, то уже при написании кода на подобные ошибки укажет сама среда разработки."
          },
          {
            "type": "text",
            "content": "2) Константа должна объявляться на самом верхнем уровне (вне класса/функции):"
          },
          {
            "type": "code",
            "content": "fun main() {\n    const val maxAge = 120   // ошибка \n    println(maxAge)\n}"
          },
          {
            "type": "text",
            "content": "3) Тип данных константы должен соответствовать одному из примитивных (например, Int) или типу String\n"
          },
          {
            "type": "text",
            "content": "Также стоит отметит отличие val-переменных от констант (const val):\nЗначение val-переменных устанавливается во время выполнения, а значение констант - во время компиляции. Значение val-переменной также нельзя изменить после установки. Константе необходимо присвоить значение сразу при определении."
          }
        ]
      },
      {
        "id": 3,
        "title": "Основные типы данных",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Основные типы"
          },
          {
            "type": "text",
            "content": "В данном разделе описываются основные типы: числа, логические переменные, символы, строки и массивы."
          },
          {
            "type": "subtitle",
            "content": "Числа\nЦелочисленные типы"
          },
          {
            "type": "text",
            "content": "\t• Byte: хранит целое число от -128 до 127 и занимает 1 байт\n\n\t• Short: хранит целое число от -32 768 до 32 767 и занимает 2 байта\n\n\t• Int: хранит целое число от -2 147 483 648 до 2 147 483 647  и занимает 4 байта\n\n\t• Long: хранит целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт"
          },
          {
            "type": "code",
            "content": "val one = 1 // Int\nval threeBillion = 3000000000 // Long\nval oneLong = 1L // Long\nval oneByte: Byte = 1"
          },
          {
            "type": "text",
            "content": "Кроме чисел в десятичной системе мы можем определять числа в двоичной и шестнадцатеричной системах.\n\nШестнадцатеричная запись числа начинается с 0x, затем идет набор символов от 0 до F, которые представляют число:"
          },
          {
            "type": "code",
            "content": "val num: Int = 0x0A1\nprintln(num) // 161"
          },
          {
            "type": "text",
            "content": "Двоичная запись числа предваряется символами 0b, после которых идет последовательность из нулей и единиц:"
          },
          {
            "type": "subtitle",
            "content": "Числа с плавающей точкой"
          },
          {
            "type": "text",
            "content": "Для действительных чисел в Kotlin есть типы с плавающей точкой Float и Double. Согласно стандарту IEEE 754, типы с плавающей точкой различаются своим десятичным разрядом, то есть количеством десятичных цифр, которые они могут хранить. С точки зрения IEEE 754 Float является одинарно точным, а Double обеспечивает двойную точность."
          },
          {
            "type": "text",
            "content": "В качестве разделителя целой и дробной части применяется точка:"
          },
          {
            "type": "code",
            "content": "val pi = 3.14 // Double\n// val one: Double = 1 // Ошибка: несоответствие типов\nval oneDouble = 1.0 // Double"
          },
          {
            "type": "text",
            "content": "Чтобы явно указать тип Float, добавьте после значения f или F. Если такое значение содержит более 6-7 разрядов, оно будет округлено."
          },
          {
            "type": "code",
            "content": "val e = 2.7182818284 // Double\nval eFloat = 2.7182818284f // Float, фактическое значение 2.7182817"
          },
          {
            "type": "text",
            "content": "Также тип Double поддерживает экспоненциальную запись:"
          },
          {
            "type": "code",
            "content": "val d: Double = 23e3\nprintln(d)      // 23 000\n \nval g: Double = 23e-3\nprintln(g)      // 0.023"
          },
          {
            "type": "subtitle",
            "content": "Логический тип Boolean"
          },
          {
            "type": "text",
            "content": "Тип Boolean может хранить одно из двух значений: true (истина) или false (ложь)."
          },
          {
            "type": "code",
            "content": "val a: Boolean = true\nval b: Boolean = false"
          },
          {
            "type": "subtitle",
            "content": "Символы"
          },
          {
            "type": "text",
            "content": "Символьные данные представлены типом Char. Он представляет отдельный символ, который заключается в одинарные кавычки."
          },
          {
            "type": "code",
            "content": "val a: Char = 'A'\nval b: Char = 'B'\nval c: Char = 'C'"
          },
          {
            "type": "subtitle",
            "content": "Строки"
          },
          {
            "type": "text",
            "content": "Строки представлены типом String. Строка представляет последовательность символов, заключенную в двойные кавычки, либо в тройные двойные кавычки."
          },
          {
            "type": "code",
            "content": "fun main() {\n     \n    val name: String = \"Eugene\"\n \n    println(name)\n}"
          },
          {
            "type": "text",
            "content": "Для большего удобства при создании многострочного текста можно использовать тройные двойные кавычки:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val text: String = \"\"\"\n                        SALT II was a series of talks between United States\n                        and Soviet negotiators from 1972 to 1979.\n                        It was a continuation of the SALT I talks.\n                    \"\"\"\n    println(text)\n}"
          },
          {
            "type": "subtitle",
            "content": "Шаблоны строк"
          },
          {
            "type": "text",
            "content": "Шаблоны строк (string templates) представляют удобный способ вставки в строку различных значений, в частности, значений переменных. Так, с помощью знака доллара $ мы можем вводить в строку значения различных переменных:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val firstName = \"Tom\"\n    val lastName = \"Smith\"\n    val welcome = \"Hello, $firstName $lastName\"\n    println(welcome)    // Hello, Tom Smith\n}"
          },
          {
            "type": "text",
            "content": "В данном случае вместо $firstName и $lastName будут вставляться значения этих переменных. При этом переменные необязательно должны представлять строковый тип:"
          },
          {
            "type": "code",
            "content": "val name = \"Tom\"\nval age = 22\nval userInfo = \"Your name: $name  Your age: $age\""
          },
          {
            "type": "subtitle",
            "content": "Выведение типа"
          },
          {
            "type": "text",
            "content": "Kotlin позволяет выводить тип переменной на основании данных, которыми переменная инициализируется. Поэтому при инициализации переменной тип можно опустить:"
          },
          {
            "type": "code",
            "content": "val age = 5"
          },
          {
            "type": "text",
            "content": "В данном случае компилятор увидит, что переменной присваивается значение типа Int, поэтому переменная age будет представлять тип Int.\n\nСоответственно если мы присваиваем переменной строку, то такая переменная будет иметь тип String."
          },
          {
            "type": "code",
            "content": "val name = \"Tom\""
          },
          {
            "type": "text",
            "content": "Любые целые числа, воспринимаются как данные типа Int.\n\nЕсли же мы хотим явно указать, что число представляет значение типа Long, то следует использовать суффикс L:"
          },
          {
            "type": "code",
            "content": "val sum = 45L"
          },
          {
            "type": "text",
            "content": "Если надо указать, что объект представляет беззнаковый тип, то применяется суффикс u или U:"
          },
          {
            "type": "code",
            "content": "val sum = 45U"
          },
          {
            "type": "text",
            "content": "Аналогично все числа с плавающей точкой (которые содержат точку в качестве разделителя целой и дробной части) рассматриваются как числа типа Double:"
          },
          {
            "type": "code",
            "content": "val height = 1.78"
          },
          {
            "type": "text",
            "content": "Если мы хотим указать, что данные будут представлять тип Float, то необходимо использовать суффикс f или F:"
          },
          {
            "type": "code",
            "content": "val height = 1.78F"
          },
          {
            "type": "text",
            "content": "Однако нельзя сначала объявить переменную без указания типа, а потом где-то в программе присвоить ей какое-то значение:"
          },
          {
            "type": "code",
            "content": "val age     // Ошибка, переменная не инициализирована\nage = 5 "
          },
          {
            "type": "subtitle",
            "content": "Статическая типизация"
          },
          {
            "type": "text",
            "content": "Тип данных ограничивает набор значений, которые мы можем присвоить переменной. Например, мы не можем присвоить переменной типа Double строку:"
          },
          {
            "type": "code",
            "content": "val height: Double = \"1.78\"   //Ошибка"
          },
          {
            "type": "text",
            "content": "И после того, как тип переменной установлен, он не может быть изменен:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    var height: String = \"1.78\"\n    height = 1.81       // !Ошибка - переменная height хранит только строки\n    println(height)\n}"
          },
          {
            "type": "text",
            "content": "Кроме того, мы не можем переменной одного типа напрямую присвоить значение переменной другого типа. Например:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    var longN: Long = 2\n    var intN: Int = 4\n    longN = intN   // ! Ошибка\n    println(longN)\n}"
          },
          {
            "type": "text",
            "content": "Мы можем решить эту проблему: Kotlin предоставляет нам ряд встроенных функций для преобразования данных к определенному типу:"
          },
          {
            "type": "text",
            "content": "\t• toByte()\n\n\t• toShort()\n\n\t• toInt()\n\n\t• toLong()\n\n\t• toFloat()\n\n\t• toDouble()\n\n\t• toChar()"
          },
          {
            "type": "text",
            "content": "Так, мы можем изменить пример выше, применив функцию toLong:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    var longN: Long = 2\n    var intN: Int = 4\n    longN = intN.toLong()   // Ошибки нет\n    println(longN)\n}"
          },
          {
            "type": "subtitle",
            "content": "Тип Any"
          },
          {
            "type": "text",
            "content": "В Kotlin также есть тип Any, который позволяет присвоить переменной данного типа любое значение:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    var name: Any = \"Tom\"\n    println(name)   // Tom\n    name = 6758\n    println(name)   // 6758\n}"
          }
        ]
      },
      {
        "id": 4,
        "title": "Консольный ввод и вывод",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Вывод на консоль"
          },
          {
            "type": "text",
            "content": "Для вывода информации на консоль в Kotlin есть две встроенные функции:"
          },
          {
            "type": "code",
            "content": "print()\nprintln()"
          },
          {
            "type": "text",
            "content": "Обе эти функции принимают некоторый объект, который надо вывести на консоль, обычно это строка. Различие между ними состоит в том, что функция println() при выводе на консоль добавляет перевод на новую строку:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    print(\"Hello \")\n    print(\"Kotlin \")\n    println()\n    println(\"Kotlin is a fun\")\n}"
          },
          {
            "type": "text",
            "content": "Причем функция println() необязательно должна принимать некоторое значения. Так, здесь применяется пустой вызов функции, который просто перевод консольный вывод на новую строку:"
          },
          {
            "type": "code",
            "content": "println()"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Hello Kotlin\nKotlin is a fun"
          },
          {
            "type": "subtitle",
            "content": "Ввод с консоли"
          },
          {
            "type": "text",
            "content": "Для ввода с консоли применяется встроенная функция readLine() (в новых версиях языка - readln()). Она возвращает введенную строку. Стоит отметить, что результат этой функции всегда представляет объект типа String. Соответственно введеную строку мы можем передать в переменную типа String:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    print(\"Введите имя: \")\n    val name = readLine()\n \n    println(\"Ваше имя: $name\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь сначала выводится приглашение к вводу данных. Далее введенное значение передается в переменную name. Результат работы программы:"
          },
          {
            "type": "code",
            "content": "Введите имя: Евгений\nВаше имя: Евгений"
          },
          {
            "type": "text",
            "content": "Подобным образом можно вводить разные данные:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    print(\"Введите имя: \")\n    val name = readLine()\n    print(\"Введите email: \")\n    val email = readLine()\n    print(\"Введите адрес: \")\n    val address = readLine()\n \n    println(\"Ваше имя: $name\")\n    println(\"Ваш email: $email\")\n    println(\"Ваш адрес: $address\")\n}"
          },
          {
            "type": "text",
            "content": "Пример работы программы:"
          },
          {
            "type": "code",
            "content": "Введите имя: Евгений\nВведите email: qwerty123@mail.ru\nВведите адрес: ул. Кленов, д.31, кв. 20\nВаше имя: Евгений\nВаш email: qwerty123@mail.ru\nВаш адрес: ул. Кленов, д.31, кв. 20"
          }
        ]
      },
      {
        "id": 5,
        "title": "Операции с числами",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Арифметические операции"
          },
          {
            "type": "text",
            "content": "Kotlin поддерживает базовые арифметические операции:"
          },
          {
            "type": "text",
            "content": "\t• '+' (сложение): возвращает сумму двух чисел."
          },
          {
            "type": "code",
            "content": "val x = 5\nval y = 6\nval z = x + y\nprintln(z)      // z = 11"
          },
          {
            "type": "text",
            "content": "\t• '-' (вычитание): возвращает разность двух чисел."
          },
          {
            "type": "code",
            "content": "val x = 5\nval y = 6\nval z = x - y  // z = -1"
          },
          {
            "type": "text",
            "content": "\t• '*' (умножение): возвращает произведение двух чисел."
          },
          {
            "type": "code",
            "content": "val x = 5\nval y = 6\nval z = x * y  // z = 30"
          },
          {
            "type": "text",
            "content": "\t• '/' (деление): возвращает частное двух чисел."
          },
          {
            "type": "code",
            "content": "val x = 60\nval y = 10\nval z = x / y  // z = 6"
          },
          {
            "type": "text",
            "content": "При этом если в операции деления оба операнда представляют целые числа, то результатом тоже будет целое число, а если в процессе деления образовалась дробная часть, то она отбрасывается:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val x = 11\n    val y = 5\n    val z = x / y  // z =2\n    println(z)// 2\n}"
          },
          {
            "type": "text",
            "content": "Так в данном случае, хотя если согласно стандартной математике разделить 11 на 5, то получится 2.2. Однако поскольку оба операнда представляют целочисленный тип, а именно тип Int, то дробная часть - 0.2 отрабрасывается, поэтому результатом будет число 2, а переменная z будет представлять тип Int.\n\nЧтобы результатом было дробное число, один из операндов должен представлять число с плавающей точкой:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val x = 11\n    val y = 5.0\n    val z = x / y   // z =2.2\n    println(z)      // 2.2\n}"
          },
          {
            "type": "text",
            "content": "В данном случае переменная y представляет тип Double, поэтому результатом деления будет число 2.2, а переменная z также будет представлять тип Double"
          },
          {
            "type": "text",
            "content": "\t• '%': возвращает остаток от целочисленного деления двух чисел."
          },
          {
            "type": "code",
            "content": "val x = 65\nval y = 10\nval z = x % y  // z = 5"
          },
          {
            "type": "text",
            "content": "\t• '++' (инкремент): увеличивает значение на единицу."
          },
          {
            "type": "text",
            "content": "\t  Префиксный инкремент возвращает увеличенное значение:"
          },
          {
            "type": "code",
            "content": "var x = 5\nval y = ++x\nprintln(x)      // x = 6\nprintln(y)      // y = 6"
          },
          {
            "type": "text",
            "content": "\t  Постфиксный инкремент возвращает значение до увеличения на единицу:"
          },
          {
            "type": "code",
            "content": "var x = 5\nval y = x++\nprintln(x)      // x = 6\nprintln(y)      // y = 5"
          },
          {
            "type": "text",
            "content": "\t• '--' (декремент): уменьшает значение на единицу."
          },
          {
            "type": "text",
            "content": "\t  Префиксный декремент возвращает уменьшенное значение:"
          },
          {
            "type": "code",
            "content": "var x = 5\nval y = --x\nprintln(x)      // x = 4\nprintln(y)      // y = 4"
          },
          {
            "type": "text",
            "content": "\t  Постфиксный декремент возвращает значение до уменьшения на единицу:"
          },
          {
            "type": "code",
            "content": "var x = 5\nval y = x--\nprintln(x)      // x = 4\nprintln(y)      // y = 5"
          },
          {
            "type": "text",
            "content": "Также есть ряд операций присвоения, которые сочетают арифметические операции и присвоение:"
          },
          {
            "type": "text",
            "content": "\t• '+=': присваивание после сложения. Присваивает левому операнду сумму левого и правого операндов: A += B эквивалентно A = A + B"
          },
          {
            "type": "text",
            "content": "\t• '-=': присваивание после вычитания. Присваивает левому операнду разность левого и правого операндов: A -= B эквивалентно A = A - B"
          },
          {
            "type": "text",
            "content": "\t• '*=': присваивание после умножения. Присваивает левому операнду произведение левого и правого операндов: A *= B эквивалентно A = A * B"
          },
          {
            "type": "text",
            "content": "\t• '/=': присваивание после деления. Присваивает левому операнду частное левого и правого операндов: A /= B эквивалентно A = A / B"
          },
          {
            "type": "text",
            "content": "\t• '%=': присваивание после деления по модулю. Присваивает левому операнду остаток от целочисленного деления левого операнда на правый: A %= B эквивалентно A = A % B"
          },
          {
            "type": "subtitle",
            "content": "\nПоразрядные операции"
          },
          {
            "type": "text",
            "content": "Ряд операций выполняется над двоичными разрядами числа. Здесь важно понимать, как выглядит двоичное представление тех или иных чисел. В частности, число 4 в двоичном виде - 100, а число 15 - 1111.\n\nЕсть следующие поразрядные операторы (они применяются только к данным типов Int и Long):"
          },
          {
            "type": "text",
            "content": "\t• 'shl': сдвиг битов числа со знаком влево"
          },
          {
            "type": "code",
            "content": "val z = 3 shl 2     // z = 11 << 2 = 1100 \nprintln(z)          // z = 12\nval d = 0b11 shl 2\nprintln(d)          // d = 12"
          },
          {
            "type": "text",
            "content": "В данном случае число сдвигается на два разряда влево, поэтому справа число в двоичном виде дополняется двумя нулями. То есть в двоичном виде 3 представляет 11. Сдвигаем на два разряда влево (дополняем справа двумя нулями) и получаем 1100, то есть в десятичной системе число 12."
          },
          {
            "type": "text",
            "content": "\t• 'shr': сдвиг битов числа со знаком вправо"
          },
          {
            "type": "code",
            "content": "val z = 12 shr 2     // z = 1100 >> 2 = 11\nprintln(z)          // z = 3\nval d = 0b1100 shr 2\nprintln(d)          // d = 3"
          },
          {
            "type": "text",
            "content": "Число 12 сдвигается на два разряда вправо, то есть два числа справа факически отбрасываем и получаем число 11, то есть 3 в десятичой системе."
          },
          {
            "type": "text",
            "content": "\t• 'ushr': сдвиг битов беззнакового числа вправо"
          },
          {
            "type": "code",
            "content": "val z = 12 ushr 2     // z = 1100 >> 2 = 11\nprintln(z)          // z = 3"
          },
          {
            "type": "text",
            "content": "\t• 'and': побитовая операция AND (логическое умножение или конъюнкция). Эта операция сравнивает соответствующие разряды двух чисел и возвращает единицу, если эти разряды обоих чисел равны 1. Иначе возвращает 0."
          },
          {
            "type": "code",
            "content": "val x = 5   // 101\nval y = 6   // 110\nval z = x and y     // z = 101 & 110 = 100\nprintln(z)          // z = 4\n \nval d = 0b101 and 0b110\nprintln(d)          // d = 4"
          },
          {
            "type": "text",
            "content": "\t• 'or': побитовая операция OR (логическое сложение или дизъюнкция). Эта операция сравнивают два соответствуюших разряда обоих чисел и возвращает 1, если хотя бы один разряд равен 1. Если оба разряда равны 0, то возвращается 0."
          },
          {
            "type": "code",
            "content": "val x = 5   // 101\nval y = 6   // 110\nval z = x or y     // z = 101 | 110 = 111\nprintln(z)         // z = 7\n \nval d = 0b101 or 0b110\nprintln(d)          // d = 7"
          },
          {
            "type": "text",
            "content": "\t• 'xor': побитовая операция XOR. Сравнивает два разряда и возвращает 1, если один из разрядов равен 1, а другой равен 0. Если оба разряда равны, то возвращается 0."
          },
          {
            "type": "code",
            "content": "val x = 5   // 101\nval y = 6   // 110\nval z = x xor y     // z = 101 ^ 110 = 011\nprintln(z)         // z = 3\n \nval d = 0b101 xor 0b110\nprintln(d)          // d = 3"
          },
          {
            "type": "text",
            "content": "\t• 'inv': логическое отрицание или инверсия - инвертирует биты числа"
          },
          {
            "type": "code",
            "content": "val b = 11  // 1011\nval c = b.inv()\nprintln(c)      // -12"
          }
        ]
      },
      {
        "id": 6,
        "title": "Условные выражения",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Условные выражения"
          },
          {
            "type": "text",
            "content": "Условные выражения представляют некоторое условие, которое возвращает значение типа Boolean: либо true (если условие истинно), либо false (если условие ложно)."
          },
          {
            "type": "subtitle",
            "content": "Операции отношения"
          },
          {
            "type": "text",
            "content": "\t• '>' (больше чем): возвращает true, если первый операнд больше второго. Иначе возвращает false"
          },
          {
            "type": "code",
            "content": "val a = 11\nval b = 12\nval c : Boolean =  a > b\nprintln(c)      // false - a меньше чем b\n \nval d = 35 > 12\nprintln(d)      // true - 35 больше чем 12"
          },
          {
            "type": "text",
            "content": "\t• '<' (меньше чем): возвращает true, если первый операнд меньше второго. Иначе возвращает false"
          },
          {
            "type": "code",
            "content": "val a = 11\nval b = 12\nval c =  a < b   // true\n \nval d = 35 < 12  // false"
          },
          {
            "type": "text",
            "content": "\t• '>=' (больше чем или равно): возвращает true, если первый операнд больше или равен второму"
          },
          {
            "type": "code",
            "content": "val a = 11\nval b = 12\nval c = a >= b      // false\nval d = 11 >= a     // true"
          },
          {
            "type": "text",
            "content": "\t• '<=' (меньше чем или равно): возвращает true, если первый операнд меньше или равен второму."
          },
          {
            "type": "code",
            "content": "val a = 11\nval b = 12\nval c = a <= b      // true\nval d = 15 <= a     // false"
          },
          {
            "type": "text",
            "content": "\t• '==' (равно): возвращает true, если оба операнда равны. Иначе возвращает false"
          },
          {
            "type": "code",
            "content": "val a = 11\nval b = 12\nval c = a == b      // false\nval d = b == 12     // true"
          },
          {
            "type": "text",
            "content": "\t• '!=' (не равно): возвращает true, если оба операнда НЕ равны"
          },
          {
            "type": "code",
            "content": "val a = 11\nval b = 12\nval c = a != b      // true\nval d = b != 12     // false"
          },
          {
            "type": "subtitle",
            "content": "\nЛогические операции"
          },
          {
            "type": "text",
            "content": "Операндами в логических операциях являются два значения типа Boolean. Нередко логические операции объединяют несколько операций отношения:"
          },
          {
            "type": "text",
            "content": "\t• 'and' возвращает true, если оба операнда равны true."
          },
          {
            "type": "code",
            "content": "val a = true\nval b = false\nval c = a and b                         // false\nval d = (11 >= 5) and (9 < 10)     // true"
          },
          {
            "type": "text",
            "content": "\t• 'or' возвращает true, если хотя бы один из операндов равен true."
          },
          {
            "type": "code",
            "content": "val a = true\nval b = false\nval c = a or b                          // true\nval d = (11 < 5) or (9 > 10)     // false"
          },
          {
            "type": "text",
            "content": "\t• 'xor' возвращает true, если только один из операндов равен true. Если операнды равны, возвращается false"
          },
          {
            "type": "code",
            "content": "val a = true\nval b = false\nval c = a xor b                 // true\nval d = a xor (90 > 10)      // false"
          },
          {
            "type": "text",
            "content": "\t• '!' возвращает true, если операнд равен false. И, наоборот, если операнд равен true, возвращается false"
          },
          {
            "type": "code",
            "content": "val a = true\nval b = !a  // false\nval c = !b  // true"
          },
          {
            "type": "text",
            "content": "В качестве альтернативы оператору ! можно использовать метод not():"
          },
          {
            "type": "code",
            "content": "val a = true\nval b = a.not()  // false\nval c = b.not()  // true"
          },
          {
            "type": "text",
            "content": "\t• 'in' возвращает true, если операнд имеется в некоторой последовательности."
          },
          {
            "type": "code",
            "content": "val a = 5\nval b = a in 1..6       // true - число 5 входит в последовательность от 1 до 6\n \nval c = 4\nval d = c in 11..15     // false - число 4 НЕ входит в последовательность от 11 до 15"
          },
          {
            "type": "text",
            "content": "Если нам, наоборот, хочется возвращать true, если числа нет в указанной последовательности, то можно применить комбинацию операторов !in:"
          },
          {
            "type": "code",
            "content": "val a = 8\nval b = a !in 1..6      // true - число 8 не входит в последовательность от 1 до 6"
          }
        ]
      },
      {
        "id": 7,
        "title": "Условные конструкции",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Условные конструкции"
          },
          {
            "type": "text",
            "content": "Условные конструкции позволяют направить выполнение программы по одному из путей в зависимости от условия.\n\nКонструкция if принимает условие, и если это условие истинно, то выполняется последующий блок инструкций."
          },
          {
            "type": "code",
            "content": "val a = 10\nif(a == 10) {\n \n    println(\"a равно 10\")\n}"
          },
          {
            "type": "text",
            "content": "Если необходимо задать альтернативный вариант, то можно добавить блок else (иначе):"
          },
          {
            "type": "code",
            "content": "val a = 10\nif(a == 10) {\n    println(\"a равно 10\")\n}\nelse{\n    println(\"a НЕ равно 10\")\n}"
          },
          {
            "type": "text",
            "content": "Таким образом, если условное выражение после оператора if истинно, то выполняется блок после if, если ложно - выполняется блок после else.\n\nЕсли блок кода состоит из одного выражения, то в принципе фигурные скобки можно опустить:"
          },
          {
            "type": "code",
            "content": "val a = 10\nif(a == 10)\n    println(\"a равно 10\")\nelse\n    println(\"a НЕ равно 10\")"
          },
          {
            "type": "text",
            "content": "Если необходимо проверить несколько альтернативных вариантов, то можно добавить выражения else if:"
          },
          {
            "type": "code",
            "content": "val a = 10\nif(a == 10) {\n    println(\"a равно 10\")\n}\nelse if(a == 9){\n    println(\"a равно 9\")\n}\nelse if(a == 8){\n    println(\"a равно 8\")\n}\nelse{\n    println(\"a имеет неопределенное значение\")\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВозвращение значения из if"
          },
          {
            "type": "text",
            "content": "Конструкция if может возвращать значение. Например, найдем максимальное из двух чисел:"
          },
          {
            "type": "code",
            "content": "val a = 10\nval b = 20\nval c = if (a > b) a else b\n \nprintln(c)  // 20"
          },
          {
            "type": "text",
            "content": "Аналогично можно использовать else if:"
          },
          {
            "type": "code",
            "content": "val a = 20\nval b = 20\nval c = if (a > b) 1 else if (a < b) -1 else 0\n \nprintln(c)  // 0"
          },
          {
            "type": "text",
            "content": "Если при определении возвращаемого значения надо выполнить еще какие-нибудь действия, то можно заключить эти действия в блоки кода:"
          },
          {
            "type": "code",
            "content": "val a = 10\nval b = 20\nval c = if (a > b){\n    println(\"a = $a\")\n    a\n} else {\n    println(\"b = $b\")\n    b\n}"
          },
          {
            "type": "text",
            "content": "В конце каждого блока указывается возвращаемое значение."
          },
          {
            "type": "subtitle",
            "content": "\nКонструкция when"
          },
          {
            "type": "text",
            "content": "Конструкция when проверяет значение некоторого объекта и в зависимости от его значения выполняет тот или иной код. Конструкция when аналогична конструкции switch в других языках. "
          },
          {
            "type": "code",
            "content": "when(объект){\n     \n    значение1 -> действия1\n    значение2 -> действия2\n     \n    значениеN -> действияN\n}"
          },
          {
            "type": "text",
            "content": "Если значение объекта равно одному из значений в блоке кода when, то выполняются соответствующие действия, которые идут после оператора -> после соответствующего значения."
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val isEnabled = true\n    when(isEnabled){\n        false -> println(\"isEnabled off\")\n        true -> println(\"isEnabled on\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь в конструкцию when передается переменная isEnabled. Далее ее значение по сравнивается со значениями в false и true. В данном случае переменная isEnabled равна true, поэтому будет выполняться код"
          },
          {
            "type": "code",
            "content": "println(\"isEnabled on\")"
          },
          {
            "type": "text",
            "content": "В примере выше переменная isEnabled имела только два возможных варианта: true и false. Однако чаще бывают случаи, когда значения в блоке when не покрывают все возможные значения объекта. Дополнительное выражение else позволяет задать действия, которые выполняются, если объект не соответствует ни одному из значений. Например:"
          },
          {
            "type": "code",
            "content": "val a = 30\nwhen(a){\n    10 -> println(\"a = 10\")\n    20 -> println(\"a = 20\")\n    else -> println(\"неопределенное значение\")\n}"
          },
          {
            "type": "subtitle",
            "content": "\nСравнение с набором значений"
          },
          {
            "type": "text",
            "content": "Можно определить одни и те же действия сразу для нескольких значений. В этом случае значения перечисляются через запятую:"
          },
          {
            "type": "code",
            "content": "val a = 10\nwhen(a){\n    10, 20 -> println(\"a = 10 или a = 20\")\n    else -> println(\"неопределенное значение\")\n}"
          },
          {
            "type": "text",
            "content": "Также можно сравнивать с целым диапазоном значений с помощью оператора in:"
          },
          {
            "type": "code",
            "content": "val a = 10\nwhen(a){\n    in 10..19 -> println(\"a в диапазоне от 10 до 19\")\n    in 20..29 -> println(\"a в диапазоне от 20 до 29\")\n    !in 10..20 -> println(\"a вне диапазона от 10 до 20\")\n    else -> println(\"неопределенное значение\")\n}"
          },
          {
            "type": "subtitle",
            "content": "\nWhen как альтернатива для if..else"
          },
          {
            "type": "text",
            "content": "Нам необязатльно сравнивать значение какого-либо объекта. Конструкция when аналогично конструкции if..else просто может поверять набор условий и если одно из условий возвращает true, то выполнять соответствующий набор действий:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val a = 15\n    val b = 6\n    when{\n        (b > 10) -> println(\"b больше 10\")\n        (a > 10) -> println(\"a больше 10\")\n        else -> println(\"и a, и b меньше или равны 10\")\n    }\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВозвращение значения"
          },
          {
            "type": "text",
            "content": "Как и if, конструкция when может возвращать значение. Возвращаемое значение указывается после оператора ->:"
          },
          {
            "type": "code",
            "content": "fun main(){\n    val day = 2\n    var dayOfweek = when (day) {\n            1 -> \"Monday\"\n            2 -> \"Tuesday\"\n            3 -> \"Wednesday\"\n            4 -> \"Thursday\"\n            else -> \"Unknown\"\n    }\n    println(dayOfweek)      // Tuesday\n}"
          },
          {
            "type": "text",
            "content": "Здесь в зависимости от значения переменной day в другой переменной - dayOfweek окажется та или иная строка.\n\nДругой пример:"
          },
          {
            "type": "code",
            "content": "val sum = 1000\n \nval rate = when(sum){\n    in 100..999 -> 10\n    in 1000..9999 -> 15\n    else -> 20\n}\nprintln(rate)       // 15"
          },
          {
            "type": "text",
            "content": "Таким образом, если значение переменной sum располагается в определенном диапазоне, то возвращается то значение, которое идет после стрелки.\n"
          }
        ]
      },
      {
        "id": 8,
        "title": "Циклы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Циклы"
          },
            {
              "type": "text",
              "content": "Циклы представляют вид управляющих конструкций, которые позволяют в зависимости от определенных условий выполнять некоторое действие множество раз."
            },
            {
              "type": "subtitle",
              "content": "for"
            },
            {
              "type": "text",
              "content": "Цикл for пробегается по всем элементам коллекции. Его формальная форма выглядит следующим образом:"
            },
            {
              "type": "code",
              "content": "for(переменная in последовательность){\n    выполняемые инструкции\n}"
            },
            {
              "type": "text",
              "content": "Например, выведем все квадраты чисел от 1 до 9, используя цикл for:"
            },
            {
              "type": "code",
              "content": "for(n in 1..9){\n    print(\"${n * n} \\t\")\n}"
            },
            {
              "type": "text",
              "content": "В данном случае перебирается последовательность чисел от 1 до 9. При каждом проходе цикла (итерации цикла) из этой последовательности будет извлекаться элемент и помещаться в переменную n. И через переменную n можно манипулировать значением элемента. То есть в данном случае мы получим следующий консольный вывод:"
            },
            {
              "type": "code",
              "content": "1  4  9  16  25  36  49  64  81 "
            },
            {
              "type": "text",
              "content": "Циклы могут быть вложенными. Например, выведем таблицу умножения:"
            },
            {
              "type": "code",
              "content": "for(i in 1..9){\n    for(j in 1..9){\n        print(\"${i * j} \\t\")\n    }\n    println()\n}"
            },
            {
              "type": "subtitle",
              "content": "Цикл while"
            },
            {
              "type": "text",
              "content": "Цикл while повторяет определенные действия пока истинно некоторое условие:"
            },
            {
              "type": "code",
              "content": "var i = 10\nwhile(i > 0){\n    println(i*i)\n    i--;\n}"
            },
            {
              "type": "text",
              "content": "Здесь пока переменная i больше 0, будет выполняться цикл, в котором на консоль будет выводиться квадрат значения i."
            },
            {
              "type": "text",
              "content": "В данном случае вначале проверяется условие (i > 0) и если оно истинно (то есть возвращает true), то выполняется цикл. И вполне может быть ситуация, когда к началу выполнения цикла условие не будет выполняться. Например, переменная i изначально меньше 0, тогда цикл вообще не будет выполняться.\n"
            },
            {
              "type": "subtitle",
              "content": "do..while"
            },
            {
              "type": "text",
              "content": "Есть и другая форма цикла while - do..while:"
            },
            {
              "type": "code",
              "content": "var i = -1\ndo{\n    println(i*i)\n    i--;\n}\nwhile(i > 0)"
            },
            {
              "type": "text",
              "content": "В данном случае вначале выполняется блок кода после ключевого слова do, а потом оценивается условие после while. Если условие истинно, то повторяется выполнение блока после do. То есть несмотря на то, что в данном случае переменная i меньше 0 и она не соответствует условию, тем не менее блок do выполнится хотя бы один раз."
            },
            {
              "type": "subtitle",
              "content": "Операторы continue и break"
            },
            {
              "type": "text",
              "content": "Иногда при использовании цикла возникает необходимость при некоторых условиях не дожидаться выполнения всех инструкций в цикле, перейти к новой итерации. Для этого можно использовать оператор continue:"
            },
            {
              "type": "code",
              "content": "for(n in 1..8){\n    if(n == 5) continue;\n    println(n * n)\n}"
            },
            {
              "type": "text",
              "content": "В данном случае когда n будет равно 5, сработает оператор continue. И последующая инструкция, которая выводит на консоль квадрат числа, не будет выполняться. Цикл перейдет к обработке следующего элемента в массиве"
            },
            {
              "type": "text",
              "content": "Бывает, что при некоторых условиях нам вовсе надо выйти из цикла, прекратить его выполнение. В этом случае применяется оператор break:"
            },
            {
              "type": "code",
              "content": "for(n in 1..5){\n    if(n == 5) break;\n    println(n * n)\n}"
            },
            {
              "type": "text",
              "content": "В данном случае когда n окажется равен 5, то с помощью оператора break будет выполнен выход из цикла. Цикл полностью завершится."
            },
            {
              "type": "text",
              "content": "Однако следует помнить, что оператор break выводит только из текущего цикла, где он вызывается. Например, возьмем следующую конструкцию с внешним и внутренним циклами:"
            },
            {
              "type": "code",
              "content": "fun main() {\n     \n    for(i in 1..3){\n        for(j in 1..3){\n            if(j == 3) break;\n            println(\"Hello\")\n        }\n    }\n}"
            },
            {
              "type": "text",
              "content": "Сколько раз здесь будет выведена строка \"Hello\"? Очевидно 6 раз."
            },
            {
              "type": "code",
              "content": "Hello\nHello\nHello\nHello\nHello\nHello"
            },
            {
              "type": "text",
              "content": "Каждый раз во внутреннем цикле j окажется равна 3, произойдет переход к новой итерации внешнего цикла по i. Но что если нам надо вообще выйти из всех циклов, в том числе и из внешнего? Наиболее простым в данном случае способом будет использование меток:"
            },
            {
              "type": "code",
              "content": "fun main() {\n     \n    outerloop@ for(i in 1..3){\n        for(j in 1..3){\n            if(j == 3) break@outerloop;\n            println(\"Hello\")\n        }\n    }\n}"
            },
            {
              "type": "text",
              "content": "В данном случае внешний цикл маркирован меткой outerloop. Название метки произвольное, единственное, что заврешается символом @. И кода во внутреннем цикле будет выполняться условие j == 3 оператор break выйдет из цикла, предваряемого меткой outerloop"
            },
            {
              "type": "code",
              "content": "if(j == 3) break@outerloop;"
            }
          ]
      },
      {
        "id": 9,
        "title": "Диапазоны",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Диапазоны"
          },
          {
            "type": "text",
            "content": "Диапазон представляет набор значений или неокторый интервал. Для создания диапазона применяется оператор..:"
          },
          {
            "type": "code",
            "content": "val range = 1..5    // диапазон [1, 2, 3, 4, 5]"
          },
          {
            "type": "text",
            "content": "Этот оператор принимает два значения - границы диапазона, и все элементы между этими значениями (включая их самих) составляют диапазон."
          },
          {
            "type": "text",
            "content": "Диапазон необязательно должна представлять числовые данные. Например, это могут быть строки:"
          },
          {
            "type": "code",
            "content": "val range =  \"a\"..\"d\""
          },
          {
            "type": "text",
            "content": "Оператор..позволяет создать диапазон по нарастающей, где каждый следующий элемент будет больше предыдущего. С помощью специальной функции downTo можно построить диапазон в обратном порядке:"
          },
          {
            "type": "code",
            "content": "val range1 =  1..5      // 1 2 3 4 5\nval range2 =  5 downTo 1    // 5 4 3 2 1"
          },
          {
            "type": "text",
            "content": "Еще одна специальная функция step позволяет задать шаг, на который будут изменяться последующие элементы:"
          },
          {
            "type": "code",
            "content": "val range1 = 1..10 step 2           // 1 3 5 7 9\nval range2 = 10 downTo 1 step 3     // 10 7 4 1"
          },
          {
            "type": "text",
            "content": "Еще одна функция until позволяет не включать верхнюю границу в диапазон:"
          },
          {
            "type": "code",
            "content": "val range1 = 1 until 9          // 1 2 3 4 5 6 7 8\nval range2 = 1 until 9 step 2   // 1 3 5 7"
          },
          {
            "type": "text",
            "content": "С помощью специальных операторов можно проверить наличие или отсутствие элементов в диапазоне:"
          },
          {
            "type": "text",
            "content": "\t• in: возвращает true, если объект имеется в диапазоне"
          },
          {
            "type": "text",
            "content": "\t• !in: возвращает true, если объект отсутствует в диапазоне"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val range = 1..5\n \n    var isInRange = 5 in range\n    println(isInRange)      // true\n \n    isInRange = 86 in range\n    println(isInRange)      // false\n \n    var isNotInRange = 6 !in range\n    println(isNotInRange)   // true\n \n    isNotInRange = 3 !in range\n    println(isNotInRange)   // false\n}"
          },
          {
            "type": "subtitle",
            "content": "\nПеребор диапазона"
          },
          {
            "type": "text",
            "content": "С помощью цикла for можно перебирать диапазон:"
          },
          {
            "type": "code",
            "content": "val range1 = 5 downTo 1 \nfor(c in range1) print(c)   // 54321\nprintln()\n \nval range2 = 'a'..'d'\nfor(c in range2) print(c)   // abcd\nprintln()\n \nfor(c in 1..9) print(c)     // 123456789\nprintln()\n \nfor(c in 1 until 9) print(c)    // 12345678\nprintln()\n \nfor(c in 1..9 step 2) print(c)  // 13579"
          }
        ]
      },
      {
        "id": 10,
        "title": "Массивы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Массивы"
          },
          {
            "type": "text",
            "content": "Для хранения набора значений в Kotlin, как и в других языках программирования, можно использоватьмассивы. При этом массив может хранить данные только одного  того же типа. В Kotlin массивы представлены типом Array."
          },
          {
            "type": "text",
            "content": "При определении массива после типа Array в угловых скобках необходимо указать, объекты какого типа могут храниться в массиве. Например, определим массив целых чисел:"
          },
          {
            "type": "code",
            "content": "val numbers: Array<Int>"
          },
          {
          "type": "text",
          "content": "С помощью встроенной функции arrayOf() можно передать набор значений, которые будут составлять массив:"
          },
          {
            "type": "code",
            "content": "val numbers: Array<Int> = arrayOf(1, 2, 3, 4, 5)"
          },
          {
            "type": "text",
            "content": "То есть в данном случае в массиве 5 чисел от 1 до 5."
          },
          {
            "type": "text",
            "content": "Также можно использовать неявную типизацию и сразу передать набор значений массива:"
          },
          {
            "type": "code",
            "content": "val numbers = arrayOf(1, 2, 3, 4, 5)"
          },
          {
            "type": "text",
            "content": "В этом случае тип элементов массива будет выводиться из типа значений из функции arrayOf()"
          },
          {
            "type": "text",
            "content": "Но что, если мы хотим создать массив, элементы которого будут не установлены? В этом случае мы можем использовать встроенную функцию arrayOfNulls(). Она создает массив из элементов, каждый из который имеет значение null- то есть фактически не установленное значение. В эту функцию передается количество элементов:"
          },
          {
            "type": "code",
            "content": "val numbers = arrayOfNulls<Int>(3)  // [null, null, null]"
          },
          {
            "type": "text",
            "content": "После названия функции в угловых скобках указывается тип элементов массива. Так, в примере выше это тип Int. В данном случае создается массив из трех элементов, каждый из которых равен по умолчанию null, то есть не имеет никакого значения."
          },
          {
            "type": "text",
            "content": "Также имеются один способо создать массив и инициализировать его значениями:"
          },
          {
            "type": "code",
            "content": "val numbers = Array(3, {5}) // [5, 5, 5]"
          },
          {
            "type": "text",
            "content": "Здесь применяется конструктор класса Array. В этот конструктор передаются два значения. Первое значение - число 3 - указывает, сколько элементов будет в массиве. Второе значение - число 5 представляет выражение, которое генерирует элементы массива. Оно заключается в фигурные скобки. То есть все элементы массива будут представлять число 5. Таким образом, массив будет состоять из трех пятерок."
          },
          {
            "type": "text",
            "content": "Но выражение, которое создает элементы массива, может быть и более сложным. Например:"
          },
          {
            "type": "code",
            "content": "var i = 1;\nval numbers = Array(3, { i++ * 2}) // [2, 4, 6]"
          },
          {
            "type": "text",
            "content": "В данном случае элемент массива является результатом умножения переменной i на 2. При этом при каждом обращении к переменой i ее значение увеличивается на единицу."
          },
          {
            "type": "subtitle",
            "content": "Обращение к элементам массива"
          },
          {
            "type": "text",
            "content": "С помощью индексов мы можем обратиться к определенному элементу в массиве. Индексация начинается с нуля, то есть первый элемент будет иметь индекс 0. Индекс указывается в квадратных скобках:"
          },
          {
            "type": "code",
            "content": "val numbers = arrayOf(1, 2, 3, 4, 5)\nval n = numbers[1]  // получаем второй элемент  n=2\nprintln(n)\nnumbers[2] = 7      // переустанавливаем третий элемент\nprintln(\"numbers[2] = ${numbers[2]}\") // numbers[2] = 7"
          },
          {
            "type": "subtitle",
            "content": "Размер массива"
          },
          {
            "type": "text",
            "content": "Каждый массив имеет свойство size, которое хранит количество элементов массива:"
          },
          {
            "type": "code",
            "content": "fun main(){\n \n    val numbers  = arrayOf(1, 2, 3, 4, 5);\n    println(numbers.size)   // 5\n \n    val people = arrayOf(\"Tom\", \"Bob\", \"Sam\")\n    println(people.size)   // 3\n}"
          },
          {
            "type": "subtitle",
            "content": "Перебор массивов"
          },
          {
            "type": "text",
            "content": "Для перебора массивов можно применять цикл for:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val numbers = arrayOf(1, 2, 3, 4, 5)\n    for(number in numbers){\n        print(\"$number \\t\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае переменная numbers представляет массив чисел. При переборе этого массива в цикле каждый его элемент оказывается в переменной number, значение которой, к примеру, можно вывести на консоль. Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "1  2  3  4  5"
          },
          {
            "type": "text",
            "content": "Подобным образом можно перебирать массивы и других типов:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val people = arrayOf(\"Tom\", \"Sam\", \"Bob\")\n    for(person in people){\n        print(\"$person \\t\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Tom   Sam   Bob"
          },
          {
            "type": "subtitle",
            "content": "Проверка наличия элемента в массиве"
          },
          {
            "type": "text",
            "content": "Как и в случае с последовательностью мы можем проверить наличие или отсутствие элементов в массиве с помощью операторов in и !in:"
          },
          {
            "type": "code",
            "content": "val numbers = arrayOf(1, 2, 3, 4, 5)\n \nprintln(4 in numbers)       // true\nprintln(2 !in numbers)      // false"
          },
          {
            "type": "subtitle",
            "content": "Массивы для базовых типов"
          },
          {
            "type": "text",
            "content": "Для упрощения создания массива в Kotlin определены дополнительные типы BooleanArray, ByteArray, ShortArray, IntArray, LongArray, CharArray, FloatArray и DoubleArray, которые позволяют создавать массивы для определенных типов. Например, тип IntArray позволяет определить массив объектов Int, а DoubleArray - массив объектов Double:"
          },
          {
            "type": "code",
            "content": "val numbers: IntArray = intArrayOf(1, 2, 3, 4, 5)\nval doubles: DoubleArray = doubleArrayOf(2.4, 4.5, 1.2)"
          },
          {
            "type": "text",
            "content": "Для определения данных для этих массивов можно применять функции, которые начинаются на название типа в нижнем регистре, например, int, и затем идет ArrayOf."
          },
          {
            "type": "text",
            "content": "Аналогично для инициализации подобных массивов также можно применять конструктор соответствуюшего класса:"
          },
          {
            "type": "code",
            "content": "val numbers = IntArray(3, {5})\nval doubles = DoubleArray(3, {1.5})"
          }
        ]
      }
    ]
  },
  {
    "chapterId": 3,
    "chapterTitle": "Функциональное программирование",
    "articles": [
      {
        "id": 1,
        "title": "Функции и их параметры",
        "blocks": [

          {
            "type": "subtitle",
            "content": "Функции"
          },
          {
            "type": "text",
            "content": "Одним из строительных блоков программы являются функции. Функция определяет некоторое действие. В Kotlin функция объявляется с помощью ключевого слова fun, после которого идет название функции. Затем после названия в скобках указывается список параметров. Если функция возвращает какое-либо значение, то после списка параметров через двоеточие можно указать тип возвращаемого значения. И далее в фигурных скобках идет тело функции."
          },
          {
            "type": "code",
            "content": "fun имя_функции (параметры) : возвращаемый_тип{\n    выполняемые инструкции\n}"
          },
          {
            "type": "text",
            "content": "Параметры необязательны. Возвращаемый тип можно не указывать, так как Kotlin обычно сам может его вывести на основании тела функции."
          },
          {
            "type": "text",
            "content": "Например, определим и вызовем функцию, которая просто выводит некоторую строку на консоль:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    hello() // вызов функции hello\n    hello() // вызов функции hello\n    hello() // вызов функции hello\n}\n// определение функции hello\nfun hello(){\n    println(\"Hello\")\n}"
          },
          {
            "type": "subtitle",
            "content": "\nПредача параметров"
          },
          {
            "type": "text",
            "content": "Через параметры функция может получать некоторые значения извне. Параметры указываются после имени функции в скобках через запятую в формате имя_параметра : тип_параметра. Например, определим функцию, которая просто выводит сообшение на консоль:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    showMessage(\"Hello Kotlin\")\n    showMessage(\"Привет Kotlin\")\n    showMessage(\"Salut Kotlin\")\n}\n \nfun showMessage(message: String){\n    println(message)\n}"
          },
          {
            "type": "text",
            "content": "Функция showMessage() принимает один параметр типа String. Поэтому при вызове функции в скобках необходимо передать значение для этого параметра: showMessage(\"Hello Kotlin\"). Причем это значение должно представлять тип String, то есть строку. Значения, которые передаются параметрам функции, еще назвают аргументами."
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Hello Kotlin\nПривет Kotlin\nSalut Kotlin"
          },
          {
            "type": "text",
            "content": "Другой пример - функция, которая выводит данные о пользователе на консоль:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    displayUser(\"Tom\", 23)\n    displayUser(\"Alice\", 19)\n    displayUser(\"Kate\", 25)\n}\nfun displayUser(name: String, age: Int){\n    println(\"Name: $name   Age: $age\")\n}"
          },
          {
            "type": "text",
            "content": "Функция displayUser() принимает два параметра - name и age. При вызове функции в скобках ей передаются значения для этих параметров. При этом значения передаются параметрам по позиции и должны соответствовать параметрам по типу. Так как вначале идет параметр типа String, а потом параметр типа Int, то при вызове функции в скобках вначале передается строка, а потом число."
          },
          {
            "type": "subtitle",
            "content": "\nНеобязательные параметры"
          },
          {
            "type": "text",
            "content": "В примере выше при вызове функций showMessage и displayUser мы обязательно должны предоставить для каждого их параметра какое-то определенное значение, которое соответствует типу параметра. Мы не можем, к примеру, вызвать функцию displayUser, не передав ей аргументы для параметров, это будет ошибка."
          },
          {
            "type": "text",
            "content": "Однако мы можем определить какие-то параметры функции как необязательные и установить для них значения по умолчанию:"
          },
          {
            "type": "code",
            "content": "fun displayUser(name: String, age: Int = 18, position: String=\"unemployed\"){\n    println(\"Name: $name   Age: $age  Position: $position\")\n}\n \nfun main() {\n \n    displayUser(\"Tom\", 23, \"Manager\")\n    displayUser(\"Alice\", 21)\n    displayUser(\"Kate\")\n}"
          },
          {
            "type": "text",
            "content": "В данном случае функция displayUser имеет три параметра для передачи имени, возраста и должности.  Два  age и position передача аргументов является необязательной, так как для них установлено значение по умолчанию. Если для этих параметров не передаются значения, тогда параметры используют значения по умолчанию."
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Name: Tom   Age: 23  Position: Manager\nName: Alice   Age: 21  Position: unemployed\nName: Kate   Age: 18  Position: unemployed"
          },
          {
            "type": "subtitle",
            "content": "\nИменованные аргументы"
          },
          {
            "type": "text",
            "content": "По умолчанию значения передаются параметрам по позиции: первое значение - первому параметру, второе значение - второму параметру и так далее. Однако, используя именованные аргументы, мы можем переопределить порядок их передачи параметрам:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    displayUser(\"Tom\", position=\"Manager\", age=28)\n    displayUser(age=21, name=\"Alice\")\n    displayUser(\"Kate\", position=\"Middle Developer\")\n}"
          },
          {
            "type": "text",
            "content": "При вызове функции в скобках мы можем указать название параметра и с помощью знака равно передать ему нужное значение."
          }
        ]
      },
      {
        "id": 2,
        "title": "Переменное количество параметров. Vararg",
        "blocks": [

          {
            "type": "subtitle",
            "content": "Переменное количество параметров. Vararg"
          },
          {
            "type": "text",
            "content": "Функция может принимать переменное количество параметров одного типа. Для определения таких параметров применяется ключевое слово vararg. Например, нам необходимо передать в функцию несколько строк, но сколько именно строк, мы точно не знаем. Их может быть пять, шесть, семь и т.д.:"
          },
          {
            "type": "code",
            "content": "fun printStrings(vararg strings: String){\n    for(str in strings)\n        println(str)\n}\nfun main() {\n \n    printStrings(\"Tom\", \"Bob\", \"Sam\")\n    printStrings(\"Kotlin\", \"JavaScript\", \"Java\", \"C#\", \"C++\")\n}"
          },
          {
            "type": "text",
            "content": "Функция printStrings принимает неопределенное количество строк. В самой функции мы можем работать с параметром как с последовательностью строк, например, перебирать элементы последовательности в цикле и производить с ними некоторые действия."
          },
          {
            "type": "text",
            "content": "При вызове функции мы можем ей передать любое количество строк."
          },
          {
            "type": "text",
            "content": "Другой пример - подсчет суммы неопределенного количества чисел:"
          },
          {
            "type": "code",
            "content": "fun sum(vararg numbers: Int){\n    var result=0\n    for(n in numbers)\n        result += n\n    println(\"Сумма чисел равна $result\")\n}\nfun main() {\n \n    sum(1, 2, 3, 4, 5)\n    sum(1, 2, 3, 4, 5, 6, 7, 8, 9)\n}"
          },
          {
            "type": "text",
            "content": "Если функция принимает несколько параметров, то обычноvararg-параметр является последним."
          },
          {
            "type": "code",
            "content": "fun printUserGroup(count:Int, vararg users: String){\n    println(\"Count: $count\")\n    for(user in users)\n        println(user)\n}\n \nfun main() {\n \n    printUserGroup(3, \"Tom\", \"Bob\", \"Alice\")\n}"
          },
          {
            "type": "text",
            "content": "Однако это необязательно, но если после vararg-параметра идут еще какие-нибудь параметры, то при вызове функции значения этим параметрам передаются через именованные аргументы:"
          },
          {
            "type": "code",
            "content": "fun printUserGroup(group: String, vararg users: String, count:Int){\n    println(\"Group: $group\")\n    println(\"Count: $count\")\n    for(user in users)\n        println(user)\n}\nfun main() {\n \n    printUserGroup(\"KT-091\", \"Tom\", \"Bob\", \"Alice\", count=3)\n}"
          },
          {
            "type": "text",
            "content": "Здесь функция printUserGroup принимает три параметра. Значения параметрам до vararg-параметра передаются по позициям. То есть в данном случае \"KT-091\" будет представлять значение для параметра group. Последующие значения интерпретируются как значения дляvararg-параметра вплоть до именнованных аргументов."
          },
          {
            "type": "subtitle",
            "content": "Оператор *"
          },
          {
            "type": "text",
            "content": "Оператор * (spread operator) (не стоит путать со знаком умножения) позволяет передать параметру в качестве значения элементы из массива:"
          },
          {
            "type": "code",
            "content": "fun changeNumbers(vararg numbers: Int, koef: Int){\n    for(number in numbers)\n        println(number * koef)\n}\nfun main() {\n \n    val nums = intArrayOf(1, 2, 3, 4)\n    changeNumbers(*nums, koef=2)\n}"
          },
          {
            "type": "text",
            "content": "Обратите внимание на звездочку перед nums при вызове функции: changeNumbers (*nums, koef=2). Без применения данного оператора мы столкнулись бы с ошибкой, поскольку параметры функции представляют не массив, а неопределенное количество значений типа Int."
          }
        ]
      },
      {
        "id": 3,
        "title": "Оператор return",
        "blocks": [

          {
            "type": "subtitle",
            "content": "Возвращение результата. Оператор return"
          },
          {
            "type": "text",
            "content": "Функция может возвращать некоторый результат. В этом случае после списка параметров через двоеточие указывается возвращаемый тип. А в теле функции применяется оператор return, после которого указывается возвращаемое значение."
          },
          {
            "type": "text",
            "content": "Например, определим функцию, которая возвращает сумму двух чисел:"
          },
          {
            "type": "code",
            "content": "fun sum(x:Int, y:Int): Int{\n     \n    return x + y\n}\nfun main() {\n \n    val a = sum(4, 3)\n    val b = sum(5, 6)\n    val c = sum(6, 9)\n    println(\"a=$a  b=$b  c=$c\")\n}"
          },
          {
            "type": "text",
            "content": "В объявлении функции sum после списка параметров через двоеточие указывается тип Int, который будет представлять тип возвращаемого значения:"
          },
          {
            "type": "code",
            "content": "fun sum(x:Int, y:Int): Int"
          },
          {
            "type": "text",
            "content": "В самой функции с помощью оператора return возвращаем полученное значение - результат операции сложения:"
          },
          {
            "type": "code",
            "content": "return x + y"
          },
          {
            "type": "text",
            "content": "Так как функция возвращает значение, то при ее вызове это значение можно присвоить переменной:"
          },
          {
            "type": "code",
            "content": "val a = sum(4, 3)"
          },
          {
            "type": "subtitle",
            "content": "\nТип Unit"
          },
          {
            "type": "text",
            "content": "Если функция не возвращает какого-либо результата, то фактически неявно она возвращает значение типа Unit. Этот тип аналогичен типу void в ряде языков программирования, которое указывает, что функция ничего не возвращает. Например, следующая функция"
          },
          {
            "type": "code",
            "content": "fun hello(){\n    println(\"Hello\")\n}"
          },
          {
            "type": "text",
            "content": "будет аналогична следующей:"
          },
          {
            "type": "code",
            "content": "fun hello() : Unit{\n    println(\"Hello\")\n}"
          },
          {
            "type": "text",
            "content": "Формально мы даже можем присвоить результат такой функции переменной:"
          },
          {
            "type": "code",
            "content": "val d = hello()\nval e = hello()"
          },
          {
            "type": "text",
            "content": "Однако практического смысла это не имеет, так как возвращаемое значение представляет объект Unit, который больше никак не применяется."
          },
          {
            "type": "text",
            "content": "Если функция возвращает значение Unit, мы также можем использовать оператор return для возврата из функции:"
          },
          {
            "type": "code",
            "content": "fun checkAge(age: Int){\n    if(age < 0 || age > 110){\n        println(\"Invalid age\")\n        return\n    }\n    println(\"Age is valid\")\n}\nfun main() {\n \n    checkAge(-10)\n    checkAge(10)\n}"
          },
          {
            "type": "text",
            "content": "В данном случае если значение параметра age выходит за пределы диапазона от 0 до 110, то с помощью оператора return осуществляется выход из функции, и последующие инструкции не выполняются. При этом если функция возвращает значение Unit, то после оператора return можно не указывать никакого значения."
          }
        ]
      },
      {
        "id": 4,
        "title": "Однострочные и локальные функции",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Однострочные и локальные функции"
          },
          {
            "type": "subtitle",
            "content": "\nОднострочные функции"
          },
          {
            "type": "text",
            "content": "Однострочные функции (single expression function) используют сокращенный синтаксис определения функции в виде одного выражения. Эта форма позволяет опустить возвращаемый тип и оператор return."
          },
          {
            "type": "code",
            "content": "\t\nfun имя_функции (параметры_функции) = тело_функции"
          },
          {
            "type": "text",
            "content": "Функция также определяется с помощью ключевого слова fun, после которого идет имя функции и список параметров. Но после списка параметров не указывается возвращаемый тип. Возвращаемый тип будет выводится компилятором. Далее через оператор присвоения = определяется тело функции в виде одного выражения."
          },
          {
            "type": "text",
            "content": "Например, функция возведения числа в квадрат:"
          },
          {
            "type": "code",
            "content": "fun square(x: Int) = x * x\n \nfun main() {\n \n    val a = square(5)   // 25\n    val b = square(6)   // 36\n    println(\"a=$a  b=$b\")\n}"
          },
          {
            "type": "text",
            "content": "В данном случае функция square возводит число в квадрат. Она состоит из одного выраженияx * x. Значение этого выражения и будет возвращаться функцией. При этом оператор return не используется."
          },
          {
            "type": "text",
            "content": "Такие функции более лаконичны, более читабельны, но также опционально можно и указывать возвращаемый тип явно:"
          },
          {
            "type": "code",
            "content": "fun square(x: Int) : Int = x * x"
          },
          {
            "type": "subtitle",
            "content": "\nЛокальные функции"
          },
          {
            "type": "text",
            "content": "Одни функции могут быть определены внутри других функций. Внутренние или вложенные функции еще называют локальными."
          },
          {
            "type": "text",
            "content": "Локальные функции могут определять действия, которые используются только в рамках какой-то конкретной функции и нигде больше не применяются."
          },
          {
            "type": "text",
            "content": "Например, у нас есть функция, которая сравнивает два возраста:"
          },
          {
            "type": "code",
            "content": "fun compareAge(age1: Int, age2: Int){\n \n    fun ageIsValid(age: Int): Boolean{\n        return age > 0 && age < 111\n    }\n    if( !ageIsValid(age1) || !ageIsValid(age2)) {\n        println(\"Invalid age\")\n        return\n    }\n \n    when {\n        age1 == age2 -> println(\"age1 == age2\")\n        age1 > age2 -> println(\"age1 > age2\")\n        age1 < age2 -> println(\"age1 < age2\")\n    }\n}\nfun main() {\n \n    compareAge(20, 23)\n    compareAge(-3, 20)\n    compareAge(34, 134)\n    compareAge(15, 8)\n}"
          },
          {
            "type": "text",
            "content": "Однако извне могут быть переданы некорректные данные. Имеет ли смысл сравнивать возраст меньше нуля с другим? Очевидно нет. Для этой цели в функции определена локальная функцияa geIsValid(), которая возвращает true, если возраст является допустимым. Больше в программе эта функция нигде не используется, поэтому ее можно сделать локальной."
          },
          {
            "type": "text",
            "content": "При этом локальная может использоваться только в той функции, где она определена."
          },
          {
            "type": "text",
            "content": "Причем в данном случае удобнее сделать локальную функцию однострочной:"
          },
          {
            "type": "code",
            "content": "fun compareAge(age1: Int, age2: Int){\n \n    fun ageIsValid(age: Int)= age > 0 && age < 111\n \n    if( !ageIsValid(age1) || !ageIsValid(age2)) {\n        println(\"Invalid age\")\n        return\n    }\n \n    when {\n        age1 == age2 -> println(\"age1 == age2\")\n        age1 > age2 -> println(\"age1 > age2\")\n        age1 < age2 -> println(\"age1 < age2\")\n    }\n}"
          }
        ]
      },
      {
        "id": 5,
        "title": "Перегрузка функций",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Перегрузка функций"
          },
          {
            "type": "text",
            "content": "Перегрузка функций (function overloading) представляет определение нескольких функций с одним и тем же именем, но с различными параметрами. Параметры перегруженных функций могут отличаться по количеству, типу или по порядку в списке параметров."
          },
          {
            "type": "code",
            "content": "fun sum(a: Int, b: Int) : Int{\n    return a + b\n}\nfun sum(a: Double, b: Double) : Double{\n    return a + b\n}\nfun sum(a: Int, b: Int, c: Int) : Int{\n    return a + b + c\n}\nfun sum(a: Int, b: Double) : Double{\n    return a + b\n}\nfun sum(a: Double, b: Int) : Double{\n    return a + b\n}"
          },
          {
            "type": "text",
            "content": "В данном случае для одной функцииsum()определено пять перегруженных версий. Каждая из версий отличается либо по типу, либо количеству, либо по порядку параметров. При вызове функции sum компилятор в зависимости от типа и количества параметров сможет выбрать для выполнения нужную версию:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val a = sum(1, 2)\n    val b = sum(1.5, 2.5)\n    val c = sum(1, 2, 3)\n    val d = sum(2, 1.5)\n    val e = sum(1.5, 2)\n}"
          },
          {
            "type": "text",
            "content": "При этом при перегрузке не учитывает возвращаемый результат функции. Например, пусть у нас будут две следующие версии функции sum:"
          },
          {
            "type": "code",
            "content": "fun sum(a: Double, b: Int) : Double{\n    return a + b\n}\nfun sum(a: Double, b: Int) : String{\n    return \"$a + $b\"\n}"
          },
          {
            "type": "text",
            "content": "Они совпадают во всем за исключением возвращаемого типа. Однако в данном случае мы сталкивамся с ошибкой, так как перегруженные версии должны отличаться именно по типу, порядку или количеству параметров. Отличие в возвращаемом типе не имеют значения."
          }
        ]
      },
      {
        "id": 6,
        "title": "Тип функции",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Тип функции"
          },
          {
            "type": "text",
            "content": "В Kotlin все является объектом, в том числе и функции. И функции, как и другие объекты, имеют определенный тип. Тип функции определяется следующим образом:"
          },
          {
            "type": "code",
            "content": "(типы_параметров) -> возвращаемый_тип"
          },
          {
            "type": "text",
            "content": "Возьмем функцию которая не принимает никаких параметров и ничего не возвращает:"
          },
          {
            "type": "code",
            "content": "fun hello(){\n \n    println(\"Hello Kotlin\")\n}"
          },
          {
            "type": "text",
            "content": "Она имеет тип:"
          },
          {
            "type": "code",
            "content": "() -> Unit"
          },
          {
            "type": "text",
            "content": "Если функция не принимает параметров, в определении типа указываются пустые скобки. Если не указан возвращаемый тип, то фактически а в качестве типа возвращаемого значения применяется тип Unit."
          },
          {
            "type": "text",
            "content": "Возьмем другую функцию:"
          },
          {
            "type": "code",
            "content": "fun sum(a: Int, b: Int): Int{\n    return a + b\n}"
          },
          {
            "type": "text",
            "content": "Эта функция принимает два параметра типа Int и возвращает значение типа Int, поэтому она имеет тип"
          },
          {
            "type": "code",
            "content": "(Int, Int) -> Int"
          },
          {
            "type": "text",
            "content": "Что дает нам знание типа функции? Используя тип функции, мы можем определять переменные и параметры других функций, которые будут представлять функции."
          },
          {
            "type": "subtitle",
            "content": "Переменные-функции"
          },
          {
            "type": "text",
            "content": "Переменная может представлять функцию. С помощью типа функции можно определить, какие именно функции переменная может представлять:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val message: () -> Unit \n    message = ::hello\n    message()\n}\n \nfun hello(){\n    println(\"Hello Kotlin\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь переменная message представляет функцию с типом () -> Unit, то есть функцию без параметров, которая ничего не возвращает. Далее определена как раз такая функция - hello(), соответственно мы можем передать функцию hello переменной message."
          },
          {
            "type": "text",
            "content": "Чтобы передать функцию, перед названием функции ставится оператор '::'"
          },
          {
            "type": "code",
            "content": "message = ::hello"
          },
          {
            "type": "text",
            "content": "Затем мы можем обращаться к переменной message() как к обычной функции:"
          },
          {
            "type": "code",
            "content": "message()"
          },
          {
            "type": "text",
            "content": "Так как переменная message ссылается на функцию hello, то при вызове message() фактически будет вызываться функция hello()."
          },
          {
            "type": "text",
            "content": "При этом тип функции также может выводится исходя из присваемого переменной значения:"
          },
          {
            "type": "code",
            "content": "val message = ::hello // message имеет тип () -> Unit"
          },
          {
            "type": "text",
            "content": "Рассмотрим другой пример, когда переменная ссылается на функцию с параметрами:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val operation: (Int, Int) -> Int = ::sum\n    val result = operation(3, 5)\n    println(result) // 8\n}\nfun sum(a: Int, b: Int): Int{\n    return a + b\n}"
          },
          {
            "type": "text",
            "content": "Переменная operation представляет функцию с типом (Int, Int) -> Int, то есть функцию с двумя параметрами типа Int и возвращаемым значением типа Int. Соответственно такой переменной мы можем присвоить функциюsum, которая соответствует этому типу."
          },
          {
            "type": "text",
            "content": "Затем через имя переменной фактически можно обращаться к функции sum(), передавая ей значения для параметров и получая ее результат:"
          },
          {
            "type": "code",
            "content": "val result = operation(3, 5)"
          },
          {
            "type": "text",
            "content": "При этом динамически можно менять значение, главное чтобы оно соответствовало типу переменной:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    // operation указывает на функцию sum\n    var operation: (Int, Int) -> Int = ::sum\n    val result1 = operation(14, 5)\n    println(result1) // 19\n \n    // operation указывает на функцию subtract\n    operation = ::subtract      \n    val result2 = operation(14, 5)\n    println(result2) // 9\n \n}\nfun sum(a: Int, b: Int): Int{\n    return a + b\n}\nfun subtract(a: Int, b: Int): Int{\n    return a - b\n}"
          }
        ]
      },
      {
        "id": 7,
        "title": "Функции высокого порядка",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Функции высокого порядка"
          },
          {
            "type": "text",
            "content": "Функции высокого порядка (high order function) - это функции, которые либо принимают функцию в качестве параметра, либо возвращают функцию, либо и то, и другое."
          },
          {
            "type": "subtitle",
            "content":"\nФункция как параметр функции"
          },
          {
            "type": "text",
            "content": "Чтобы функция могла принимать другую функцию через параметр, этот параметр должен представлять тип функции:"
          },
          {
            "type": "code",
            "content": "fun main() {\n\n    displayMessage(::morning)\n    displayMessage(::evening)\n}\nfun displayMessage(mes: () -> Unit){\n    mes()\n}\nfun morning(){\n    println(\"Good Morning\")\n}\nfun evening(){\n    println(\"Good Evening\")\n}"
          },
          {
            "type": "text",
            "content": "В данном случае функция displayMessage() через параметр mes принимает функцию типа () -> Unit, то есть такую функцию, которая не имеет параметров и ничего не возвращает."
          },
          {
            "type": "code",
            "content":"fun displayMessage(mes: () -> Unit){"
          },
          {
            "type": "text",
            "content": "При вызове этой функции мы можем передать этому параметру функцию, которая соответствует этому типу:"
          },
          {
            "type": "code",
            "content":"displayMessage(::morning)"
          },
          {
            "type": "text",
            "content": "Рассмотрим пример параметра-функции, которая принимает параметры:"
          },
          {
            "type": "code",
            "content":"fun main() {\n\n    action(5, 3, ::sum)         // 8\n    action(5, 3, ::multiply)    // 15\n    action(5, 3, ::subtract)    // 2\n}\n\nfun action (n1: Int, n2: Int, op: (Int, Int)-> Int){\n    val result = op(n1, n2)\n    println(result)\n}\nfun sum(a: Int, b: Int): Int{\n    return a + b\n}\nfun subtract(a: Int, b: Int): Int{\n    return a - b\n}\nfun multiply(a: Int, b: Int): Int{\n    return a * b\n}"
          },
          {
            "type": "text",
            "content": "Здесь функция action принимает три параметра. Первые два параметра - значения типа Int. А третий параметр представляет функцию, которая имеет тип (Int, Int)-> Int, то есть принимает два числа и возвращает некоторое число."
          },
          {
            "type": "text",
            "content": "В самой функции action вызываем эту параметр-функцию, передавая ей два числа, и полученный результат выводим на консоль."
          },
          {
            "type": "text",
            "content": "При вызове функции action мы можем передать для ее третьего параметра конкретную функцию, которая соответствует этому параметру по типу:"
          },
          {
            "type": "code",
            "content":"action(5, 3, ::sum)         // 8\naction(5, 3, ::multiply)    // 15\naction(5, 3, ::subtract)    // 2"
          },
          {
            "type": "subtitle",
            "content": "\nВозвращение функции из функции"
          },
          {
            "type": "text",
            "content": "В более редких случаях может потребоваться возвратить функцию из другой функции. В этом случае для функции в качестве возвращаемого типа устанавливается тип другой функции. А в теле функции возвращается лямбда выражение. Например:"
          },
          {
            "type": "code",
            "content":"fun main() {\n    val action1 = selectAction(1)\n    println(action1(8,5))    // 13\n\n    val action2 = selectAction(2)\n    println(action2(8,5))    // 3\n}\nfun selectAction(key: Int): (Int, Int) -> Int{\n    // определение возвращаемого результата\n    when(key){\n        1 -> return ::sum\n        2 -> return ::subtract\n        3 -> return ::multiply\n        else -> return ::empty\n    }\n}\nfun empty (a: Int, b: Int): Int{\n    return 0\n}\nfun sum(a: Int, b: Int): Int{\n    return a + b\n}\nfun subtract(a: Int, b: Int): Int{\n    return a - b\n}\nfun multiply(a: Int, b: Int): Int{\n    return a * b\n}"
          },
          {
            "type": "text",
            "content": "Здесь функция selectAction принимает один параметр - key, который представляет тип Int. В качестве возвращаемого типа у функции указан тип (Int, Int) -> Int. То есть selectAction будет возвращать некую функцию, которая принимает два параметра типа Int и возвращает объект типа Int."
          },
          {
            "type": "text",
            "content": "В теле функции selectAction в зависимости от значения параметра key возвращается определенная функция, которая соответствует типу (Int, Int) -> Int."
          },
          {
            "type": "text",
            "content": "Далее в функции main определяется переменная action1 хранит результат функции selectAction. Так какselectAction()возвращает функцию, то и переменная action1 будет хранить эту функцию. Затем через переменную action1 можно вызвать эту функцию."
          }
        ]
      },
      {
        "id": 8,
        "title": "Анонимные функции",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Анонимные функции"
          },
          {
            "type": "text",
            "content": "Анонимные функции выглядят как обычные за тем исключением, что они не имеют имени. Анонимная функция может иметь одно выражение:"
          },
          {
            "type": "code",
            "content": "fun(x: Int, y: Int): Int = x + y"
          },
          {
            "type": "text",
            "content": "Либо может представлять блок кода:"
          },
          {
            "type": "code",
            "content": "fun(x: Int, y: Int): Int{ \n    return x + y\n}"
          },
          {
            "type": "text",
            "content": "Анонимную функцию можно передавать в качестве значения переменной:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val message = fun()=println(\"Hello\")\n    message()\n}"
          },
          {
            "type": "text",
            "content": "Здесь переменной message передается анонимная функция fun()=println(\"Hello\"). Эта анонимная функция не принимает параметров и просто выводит на консоль строку \"Hello\". Таким образом, переменная message будет представлять тип () -> Unit."
          },
          {
            "type": "text",
            "content": "Далее мы можем вызывать эту функцию через имя переменной как обычную функцию: message()."
          },
          {
            "type": "text",
            "content": "Другой пример - анонимная функция с параметрами:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val sum = fun(x: Int, y: Int): Int = x + y \n    val result = sum(5, 4)\n    println(result)     // 9\n}"
          },
          {
            "type": "text",
            "content": "В данном случае переменной sum присваивается анонимная функция, которая принимает два параметра - два целых числа типа Int и возвращает их сумму."
          },
          {
            "type": "text",
            "content": "Также через имя переменной мы можем вызвать эту анонимную функцию, передав ей некоторые значения для параметров и получить ее результат: val result = sum(5, 4)"
          },
          {
            "type": "subtitle",
            "content": "\nАнонимная функция как аргумент функции"
          },
          {
            "type": "text",
            "content": "Анонимную функцию можно передавать в функцию, если параметр соответствует типу этой функции:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    doOperation(9,5, fun(x: Int, y: Int): Int = x + y )     // 14\n    doOperation(9,5, fun(x: Int, y: Int): Int = x - y)      // 4\n \n    val action = fun(x: Int, y: Int): Int = x * y\n    doOperation(9, 5, action)       // 45\n}\nfun doOperation(x: Int, y: Int, op: (Int, Int) ->Int){\n \n    val result = op(x, y)\n    println(result)\n"
          },
          {
            "type": "subtitle",
            "content": "\nВозвращение анонимной функции из функции"
          },
          {
            "type": "text",
            "content": "И также фунция может возвращать анонимную функцию в качестве результата:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val action1 = selectAction(1)\n    val result1 = action1(4, 5)\n    println(result1)        // 9\n \n    val action2 = selectAction(3)\n    val result2 = action2(4, 5)\n    println(result2)        // 20\n \n    val action3 = selectAction(9)\n    val result3 = action3(4, 5)\n    println(result3)        // 0\n}\n \nfun selectAction(key: Int): (Int, Int) -> Int{\n    // определение возвращаемого результата\n    when(key){\n        1 -> return fun(x: Int, y: Int): Int = x + y\n        2 -> return fun(x: Int, y: Int): Int = x - y\n        3 -> return fun(x: Int, y: Int): Int = x * y\n        else -> return fun(x: Int, y: Int): Int = 0\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь функция selectAction() в зависимости от переданного значения возвращает одну из четырех анонимных функций. Последняя анонимная функция fun(x: Int, y: Int): Int = 0 просто возвращает число 0."
          },
          {
            "type": "text",
            "content": "При обращении к selectAction() переменная получит определенную анонимную функцию:"
          },
          {
            "type": "code",
            "content": "val action1 = selectAction(1)"
          },
          {
            "type": "text",
            "content": "То есть в данном случае переменная action1 хранит ссылку на функцию fun(x: Int, y: Int): Int = x + y"
          }
        ]
      },
      {
        "id": 9,
        "title": "Лямбда-выражения",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Лямбда-выражения"
          },
          {
            "type": "text",
            "content": "Лямбда-выражения представляют небольшие кусочки кода, которые выполняют некоторые действия. Фактически лямбды преставляют сокращенную запись функций. При этом лямбды, как и обычные и анонимные функции, могут передаваться в качестве значений переменным и параметрам функции."
          },
          {
            "type": "text",
            "content": "Лямбда-выражения оборачиваются в фигурные скобки:"
          },
          {
            "type": "code",
            "content": "{println(\"hello\")}"
          },
          {
            "type": "text",
            "content": "В данном случае лямбда-выражение выводит на консоль строку \"hello\"."
          },
          {
            "type": "text",
            "content": "Лямбда-выражение можно сохранить в обычную переменную и затем вызывать через имя этой переменной как обычную функцию."
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val hello = {println(\"Hello Kotlin\")}\n    hello()\n    hello()\n}"
          },
          {
            "type": "text",
            "content": "В данном случае лямбда сохранена в переменную hello и через эту переменную вызывается два раза. Поскольку лямбда-выражение представляет сокращенную форму функции, то переменная hello имеет тип функции() -> Unit."
          },
          {
            "type": "code",
            "content": "val hello: ()->Unit = {println(\"Hello Kotlin\")}"
          },
          {
            "type": "text",
            "content": "Также лямбда-выражение можно запускать как обычную функцию, используя круглые скобки:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    {println(\"Hello Kotlin\")}()\n}"
          },
          {
            "type": "text",
            "content": "Следует учитывать, что если до подобной записи идут какие-либо инструкции, то Kotlin автоматически может не определять, что определения лямбда-выражения составляет новую инструкцию. В этом случае предыдущую инструкции можно завершить точкой с запятой:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    {println(\"Hello Kotlin\")}();\n    {println(\"Kotlin on Metanit.com\")}()\n}"
          },
          {
            "type": "subtitle",
            "content": "\nПередача параметров"
          },
          {
            "type": "text",
            "content": "Лямбды как и функции могут принимать параметры. Для передачи параметров используется стрелка ->. Параметры указываются слева от стрелки, а тело лямбда-выражения, то есть сами выполняемые действия, справа от стрелки."
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val printer = {message: String -> println(message)}\n    printer(\"Hello\")\n    printer(\"Good Bye\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь лямбда-выражение принимает один параметр типа String, значение которого выводится на консоль. Переменная printer в данном случае имеет тип (String) -> Unit."
          },
          {
            "type": "text",
            "content": "При вызове лямбда-выражения сразу при его определении в скобках передаются значения для его параметров:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    {message: String -> println(message)}(\"Welcome to Kotlin\")\n}"
          },
          {
            "type": "text",
            "content": "Если параметров несколько, то они передаются слева от стрелки через запятую:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val sum = {x:Int, y:Int -> println(x + y)}\n    sum(2, 3)   // 5\n    sum(4, 5)   // 9\n}"
          },
          {
            "type": "text",
            "content": "Если в лямбда-выражении надо выполнить не одно, а несколько действий, то эти действия можно размещать на отдельных строках после стрелки:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val sum = {x:Int, y:Int -> println(x + y)}\n    sum(2, 3)   // 5\n    sum(4, 5)   // 9\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВозвращение результата"
          },
          {
            "type": "text",
            "content": "Выражение, стоящее после стрелки, определяет результат лямбда-выражения. И этот результат мы можем присвоить, например, переменной."
          },
          {
            "type": "text",
            "content": "Если лямбда-выражение формально не возвращает никакого результата, то фактически, как и в функциях, возвращается значение типа Unit:"
          },
          {
            "type": "code",
            "content": "val hello = { println(\"Hello\")}\nval h = hello()             // h представляет тип Unit\n \nval printer = {message: String -> println(message)}\nval p = printer(\"Welcome\")    // p представляет тип Unit"
          },
          {
            "type": "text",
            "content": "В обоих случаях используется функция println, которая формально не возвращает никакого значения (точнее возвращает объект типа Unit)."
          },
          {
            "type": "text",
            "content": "Но также может возвращаться конкретное значение:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val sum = {x:Int, y:Int -> x + y}\n     \n    val a = sum(2, 3)   // 5\n    val b = sum(4, 5)   // 9\n    println(\"a=$a  b=$b\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь выражение справа от стрелки x + y продуцирует новое значение - сумму чисел, и при вызове лямбда-выражения это значение можно передать переменной. В данном случае лямбда-выражение имеет тип (Int, Int) -> Int."
          },
          {
            "type": "text",
            "content": "Если лямбда-выражение многострочное, состоит из нескольких инструкций, то возвращается то значение, которое генерируется последней инструкцией:"
          },
          {
            "type": "code",
            "content": "val sum = {x:Int, y:Int ->\n    val result = x + y\n    println(\"$x + $y = $result\")\n    result\n}"
          },
          {
            "type": "text",
            "content": "Последнее выражение по сути представляет число - сумму чисел x и y и оно будет возвращаться в качестве результата лямбда-выражения."
          },
          {
            "type": "subtitle",
            "content": "\nЛямбда-выражения как аргументы функций"
          },
          {
            "type": "text",
            "content": "Лямбда-выражения можно передавать параметрам функции, если они представляют один и тот же тип функции:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val sum = {x:Int, y:Int -> x + y }\n    doOperation(3, 4, sum)                          // 7\n    doOperation(3, 4, {a:Int, b: Int -> a * b}) // 12\n \n}\nfun doOperation(x: Int, y: Int, op: (Int, Int) ->Int){\n \n    val result = op(x, y)\n    println(result)\n}"
          },
          {
            "type": "subtitle",
            "content": "\nТипизиция параметров лямбды"
          },
          {
            "type": "text",
            "content": "При передаче лямбды параметру или переменной, для которой явным образом указан тип, мы можем опустить в лямбда-выражении типы параметров:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val sum: (Int, Int) -> Int = {x, y -> x + y } \n    doOperation(3, 4, {a, b -> a * b})\n}\nfun doOperation(x: Int, y: Int, op: (Int, Int) ->Int){\n \n    val result = op(x, y)\n    println(result)\n}"
          },
          {
            "type": "text",
            "content": "Здесь в случае с переменной sumKotlin видит, что ее тип(Int, Int) -> Int, то есть и первый, и второй параметр представляют типInt. Поэтому при присвоении переменной лямбды {x, y -> x + y } Kotlin автоматически поймет, что параметры x и y представляют именно тип Int."
          },
          {
            "type": "text",
            "content": "То же самое касается и вызова функции doOperation() - при передаче в него лямбды Kotlin автоматически поймет какой параметр какой тип представляет."
          },
          {
            "type": "subtitle",
            "content": "\nTrailing lambda"
          },
          {
            "type": "text",
            "content": "Если параметр, который принимает функцию, является последним в списке, то при передачи ему лямбда-выражения, саму лямбду можно прописать после списка параметров. Например, возьмем выше использованную функцию doOperation():"
          },
          {
            "type": "code",
            "content": "fun doOperation(x: Int, y: Int, op: (Int, Int) ->Int){\n \n    val result = op(x, y)\n    println(result)\n}"
          },
          {
            "type": "text",
            "content": "Здесь параметр, который представляет функцию - параметр op, является последним в списке параметров. Поэтому вместо того, чтобы написать так:"
          },
          {
            "type": "code",
            "content": "doOperation(3, 4, {a, b -> a * b}) // 12"
          },
          {
            "type": "text",
            "content": "Мы также можем написать так:"
          },
          {
            "type": "code",
            "content": "doOperation(3, 4) {a, b -> a * b} // 12"
          },
          {
            "type": "text",
            "content": "То есть вынести лямбду за список параметров. Это так называемая конечная лямбда илиtrailing lambda"
          },
          {
            "type": "subtitle",
            "content": "\nВозвращение лямбда-выражения из функции"
          },
          {
            "type": "text",
            "content": "Также фукция может возвращать лямбда-выражение, которое соответствует типу ее возвращаемого результата:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val action1 = selectAction(1)\n    val result1 = action1(4, 5)\n    println(result1)        // 9\n \n    val action2 = selectAction(3)\n    val result2 = action2(4, 5)\n    println(result2)        // 20\n \n    val action3 = selectAction(9)\n    val result3 = action3(4, 5)\n    println(result3)        // 0\n}\nfun selectAction(key: Int): (Int, Int) -> Int{\n    // определение возвращаемого результата\n    when(key){\n        1 -> return {x, y -> x + y }\n        2 -> return {x, y -> x - y }\n        3 -> return {x, y -> x * y }\n        else -> return {x, y -> 0 }\n    }\n}"
          },
          {
            "type": "subtitle",
            "content": "\nНеиспользуемые параметры"
          },
          {
            "type": "text",
            "content": "Обратим внимание на предыдущий пример на последнюю лямбду:"
          },
          {
            "type": "code",
            "content": "else -> return {x, y -> 0 }"
          },
          {
            "type": "text",
            "content": "Если в функцию selectAction() передается число, отличное от 1, 2, 3, то возвращается лямбда-выражение, которое просто возвращает число 0. С одной стороны, это лямбда-выражение должно соответствовать типу возвращаемого результата функции selectAction() - (Int, Int) -> Int"
          },
          {
            "type": "text",
            "content": "С другой стороны, оно не использует параметры, эти параметры не нужны. В этом случае вместо неиспользуемых параметров можно указать прочерки:"
          },
          {
            "type": "code",
            "content": "else -> return {_, _ -> 0 }"
          }
        ]
      },
      {
        "id": 10,
        "title": "Замыкания",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Замыкания"
          },
          {
            "type": "text",
            "content": "Замыкание (closure) представляет объект функции, который запоминает свое лексическое окружение даже в том случае, когда она выполняется вне своей области видимости."
          },
          {
            "type": "text",
            "content": "Технически замыкание включает три компонента:"
          },
          {
            "type": "text",
            "content": "\t• внешняя функция, которая определяет некоторую область видимости и в которой определены некоторые переменные и параметры - лексическое окружение"
          },
          {
            "type": "text",
            "content": "\t• переменные и параметры (лексическое окружение), которые определены во внешней функции"
          },
          {
            "type": "text",
            "content": "\t• вложенная функция, которая использует переменные и параметры внешней функции"
          },
          {
            "type": "code",
            "content": "fun outer(): ()->Unit{       // внешняя функция\n    var n              // некоторая переменная - лексическое окружение\n    fun inner(){     // вложенная функция\n        // действия с переменной n\n    }\n    return ::inner  // возвращаем вложенную функцию\n}"
          },
          {
            "type": "text",
            "content": "В данном случае функция inner и есть замыкание."
          },
          {
            "type": "text",
            "content": "Рассмотрим замыкания на простейшем примере:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val fn = outer() // fn = inner, так как функция outer возвращает функцию inner\n    // вызываем внутреннюю функцию inner\n    fn() // 6\n    fn() // 7\n    fn() // 8\n}\nfun outer(): ()->Unit{       // внешняя функция\n    var n = 5         // некоторая переменная - лексическое окружение функции inner\n    fun inner(){     // вложенная функция\n        // действия с переменной n\n        n++\n        println(n)\n    }\n    return ::inner\n}"
          },
          {
            "type": "text",
            "content": "Здесь функция outer задает область видимости, в которой определены внутренняя функция inner и переменная n. Переменная n представляет лексическое окружение для функции inner. В самой функции inner инкрементируем переменную n и выводим ее значение на консоль. В конце функция outer возвращает функцию inner."
          },
          {
            "type": "text",
            "content": "Далее вызываем функцию outer:"
          },
          {
            "type": "code",
            "content": "val fn = outer()"
          },
          {
            "type": "text",
            "content": "Поскольку функция outer возвращает функцию inner, то переменная fn будет хранить ссылку на функцию inner. При этом эта функция запомнила свое окружение - то есть внешнюю переменную n."
          },
          {
            "type": "text",
            "content": "Далее мы фактически три раза вызываем функцию inner, и мы видим, что переменная n, которая определена вне функции inner, увеличивается на единицу:"
          },
          {
            "type": "code",
            "content": "fn()   // 6\nfn()   // 7\nfn()   // 8"
          },
          {
            "type": "text",
            "content": "То есть несмотря на то, что переменная x определена вне функции inner, эта функция запомнила свое окружение и может его использовать, несомотря на то, что она вызывается вне функции outer, в которой была определена. В этом и суть замыканий."
          },
          {
            "type": "text",
            "content": "Кстати мы можем сократить определение функции outer, используя анонимную функцию:"
          },
          {
            "type": "code",
            "content": "fun outer(): ()-> Unit{\n    var n = 5\n    return {\n        n++\n        println(n)\n    }\n}"
          },
          {
            "type": "text",
            "content": "Рассмотрим другой пример:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val func = multiply(5)\n    val result1 = func(6) // 30\n    println(result1)       // 30\n \n    val result2 = func(5) // 25\n    println(result2)          // 25\n}\nfun multiply(n:Int): (Int)->Int{\n \n    return {m:Int-> n * m}\n}"
          },
          {
            "type": "text",
            "content": "Итак, здесь вызов функцииm ultiply() приводит к вызову другой внутренней функции. Внутренняя же функция представлена лямбда-выражением:"
          },
          {
            "type": "code",
            "content": "{m:Int-> n * m}"
          },
          {
            "type": "text",
            "content": "Оно запоминает окружение, в котором было создана, в частности, значение параметра n."
          },
          {
            "type": "text",
            "content": "В итоге при вызове функции multiply определяется переменная func, которая и представляет собой замыкание, то есть объединяет две вещи: функцию и окружение, в котором функция была создана. Окружение состоит из любой локальной переменной или любого параметра, которые были определены в области действия функции multiply во время создания замыкания."
          },
          {
            "type": "text",
            "content": "То есть result1 — это замыкание, которое содержит и внутреннюю функцию{m:Int-> n * m}, и параметр n, который существовал во время создания замыкания."
          },
          {
            "type": "text",
            "content": "При этом важно не запутаться в параметрах. При определении замыкания:"
          },
          {
            "type": "code",
            "content": "val func = multiply(5)"
          },
          {
            "type": "text",
            "content": "Число 5 передается для параметра n функции multiply."
          },
          {
            "type": "text",
            "content": "При вызове внутренней функции:"
          },
          {
            "type": "code",
            "content": "val result1 = func(6) // 30"
          },
          {
            "type": "text",
            "content": "Число 6 передается для параметра m во внутреннюю функцию (int m) => n * m;"
          },
          {
            "type": "text",
            "content": "Также мы можем использовать другой вариант для вызова замыкания:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val result1 = multiply(5)(6) // 30\n    println(result1)       // 30\n \n    val result2 = multiply(5)(5) // 25\n    println(result2)          // 25\n}\nfun multiply(n:Int): (Int)->Int{\n \n    return {m:Int-> n * m}\n}"
          }
        ]
      }
      ]
  },
  {
    "chapterId": 4,
    "chapterTitle": "Объектно-ориентированное программирование",
    "articles": [
      {
        "id": 1,
        "title": "Классы и объекты",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Объектно-ориентированное программирование"
          },
          {
            "type": "subtitle",
            "content": "\nКлассы и объекты"
          },
          {
            "type": "text",
            "content": "Kotlin поддерживает объектно-ориентированную парадигму программирования, а это значит, что программу на данном языке можно представить в виде взаимодействующих между собой объектов."
          },
          {
            "type": "text",
            "content": "Представлением объекта является класс. Класс фактически представляет определение объекта. А объект является конкретным воплощением класса. Например, у всех есть некоторое представление о машине, например, кузов, четыре колеса, руль и т.д. - некоторый общий набор характеристик, присущих каждой машине. Это представление фактически и является классом. При этом есть разные машины, у которых отличается форма кузова, какие-то другие детали, то есть есть конкретные воплощения этого класса, конкретные объекты или экземпляры класса."
          },
          {
            "type": "text",
            "content": "Для определения класса применяется ключевое слово class, после которого идет имя класса. А после имени класса в фигурных скобках определяется тело класса. Если класс не имеет тела, то фигурные скобки можно опустить. Например, определим класс, который представляет человека:"
          },
          {
            "type": "code",
            "content": "class Person\n \n// либо можно так\nclass Person { }"
          },
          {
            "type": "text",
            "content": "Класс фактически представляет новый тип данных, поэтому мы можем определять переменные этого типа:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom: Person\n    val bob: Person\n    val alice: Person\n}\n \nclass Person"
          },
          {
            "type": "text",
            "content": "В функции main определены три переменных типа Person."
          },
          {
            "type": "text",
            "content": "Для создания объекта класса необходимо вызвать конструктор данного класса. Конструктор фактически представляет функцию, которая называется по имени класса и которая выполняет инициализацию объекта. По умолчанию для класса компилятор генерирует пустой конструктор, который мы можем использовать:"
          },
          {
            "type": "code",
            "content": "val tom: Person = Person()"
          },
          {
            "type": "text",
            "content": "Часть кода после знака равно Person() как раз и представляет вызов конструктора, который создает объект класса Person. До вызова конструктора переменная класса не указывает ни на какой объект."
          },
          {
            "type": "text",
            "content": "Например, создадим три объекта класса Person:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom: Person = Person()\n    val bob: Person = Person()\n    val alice: Person = Person()\n}\n \nclass Person"
          },
          {
            "type": "subtitle",
            "content": "\nСвойства"
          },
          {
            "type": "text",
            "content": "Каждый класс может хранить некоторые данные или состояние в виде свойств. Свойства представляют переменные, определенные на уровне класса с ключевыми словами val и var. Если свойство определено с помощью val, то значение такого свойства можно установить только один раз, то есть оно immutable. Если свойство определено с помощью var, то значение этого свойства можно многократно изменять."
          },
          {
            "type": "text",
            "content": "Свойство должно быть инициализировано, то есть обязательно должно иметь начальное значение. Например, определим пару свойств:"
          },
          {
            "type": "code",
            "content": "class Person{\n    var name: String = \"Undefined\"\n    var age: Int = 18\n}"
          },
          {
            "type": "text",
            "content": "В данном случае в классе Person, который представляет человека, определены свойства name (имя человека) и age (возраст человека). И эти свойства инициализированы начальными значениями."
          },
          {
            "type": "text",
            "content": "Поскольку эти свойства определены с var, то мы можем изменить их начальные значения:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val bob: Person = Person()  // создаем объект\n    println(bob.name)       // Undefined\n    println(bob.age)        // 18\n \n    bob.name = \"Bob\"\n    bob.age = 25\n \n    println(bob.name)       // Bob\n    println(bob.age)        // 25\n}\n \nclass Person{\n    var name: String = \"Undefined\"\n    var age: Int = 18\n}"
          },
          {
            "type": "text",
            "content": "Для обращения к свойствам используется имя переменной, которая предствляет объект, и после точки указывается имя свойства. Например, получение значения свойства:"
          },
          {
            "type": "code",
            "content": "val personName : String = bob.name"
          },
          {
            "type": "text",
            "content": "Установка значения свойства:"
          },
          {
            "type": "code",
            "content": "bob.name = \"Bob\""
          },
          {
            "type": "subtitle",
            "content": "\nФункции класса"
          },
          {
            "type": "text",
            "content": "Класс также может содержать функции. Функции определяют поведение объектов данного класса. Такие функции еще называют member functions или функции-члены класса. Например, определим класс с функциями:"
          },
          {
            "type": "code",
            "content": "class Person{\n    var name: String = \"Undefined\"\n    var age: Int = 18\n \n    fun sayHello(){\n        println(\"Hello, my name is $name\")\n    }\n \n    fun go(location: String){\n        println(\"$name goes to $location\")\n    }\n \n    fun personToString() : String{\n        return \"Name: $name  Age: $age\"\n    }\n}"
          },
          {
            "type": "text",
            "content": "Функции класса определяется также как и обычные функции. В частности, здесь в классе Person определена функция sayHello(), которая выводит на консоль строку \"Hello\" и эмулирует приветствие объекта Person. Вторая функция - go() эмулирует движение объекта Person к определенному местоположению. Местоположение передается через параметр location. И третья функция personToString() возвращает информацию о текущем объекте в виде строки."
          },
          {
            "type": "text",
            "content": "В функциях, которые определены внутри класса, доступны свойства этого класса. Так, в данном случае в функциях можно обратиться к свойствам name и age, которые определены в классе Person."
          },
          {
            "type": "text",
            "content": "Для обращения к функциям класса необходимо использовать имя объекта, после которого идет название функции и в скобках значения для параметров этой функции:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person()\n    tom.name = \"Tom\"\n    tom.age = 37\n \n    tom.sayHello()\n    tom.go(\"the shop\")\n    println(tom.personToString())\n \n}\n \nclass Person{\n    var name: String = \"Undefined\"\n    var age: Int = 18\n \n    fun sayHello(){\n        println(\"Hello, my name is $name\")\n    }\n \n    fun go(location: String){\n        println(\"$name goes to $location\")\n    }\n \n    fun personToString() : String{\n        return \"Name: $name  Age: $age\"\n    }\n}"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Hello, my name is Tom\nTom goes to the shop\nName: Tom  Age: 37"
          }
        ]
      },
      {
        "id": 2,
        "title": "Конструкторы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Конструкторы"
          },
          {
            "type": "text",
            "content": "Для создания объекта необходимо вызвать конструктор класса. По умолчанию компилятор создает конструктор, который не принимает параметров и который мы можем использовать. Но также мы можем определять свои собственные конструкторы. Классы в Kotlin могут иметь одинпервичный конструктор (primary constructor) и один или нескольковторичных конструкторов (secondary constructor)."
          },
          {
            "type": "subtitle",
            "content": "\nВторичные конструкторы"
          },
          {
            "type": "text",
            "content": "Вторичные конструкторы определяются в теле класса с помощью ключевого слова `constructor:"
          },
          {
            "type": "code",
            "content": "fun main() {\n     \n    val tom = Person(\"Tom\", 39)\n    val bob = Person(\"Bob\", 45)\n      \n    println(\"Name: ${tom.name}  Age: ${tom.age}\")\n    println(\"Name: ${bob.name}  Age: ${bob.age}\")\n}\n \nclass Person{\n    val name: String\n    var age: Int\n      \n    constructor(_name: String, _age: Int){\n        name = _name\n        age = _age\n    }\n}"
          },
          {
            "type": "text",
            "content": "Конструкторы во многом похожи на функциии, как и обычные функции, могут иметь параметры. Здесь в классе Person определен конструктор, принимает два параметра: _name и _age - условно говоря имя и возраст человека. Внутри конструктора эти значения передаются переменным name и age:"
          },
          {
            "type": "code",
            "content": "constructor(_name: String, _age: Int){\n    name = _name\n    age = _age\n}"
          },
          {
            "type": "text",
            "content": "В функции main создаются два объекта Person. Для их создания применяется вторичный конструктор, параметрам которого передаются некоторые значения:"
          },
          {
            "type": "code",
            "content": "val tom = Person(\"Tom\", 39)\nval bob = Person(\"Bob\", 45)"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Name: Tom  Age: 39\nName: Bob  Age: 45"
          },
          {
            "type": "text",
            "content": "Аналогичным образом мы можем определять и большее количество конструкторов:"
          },
          {
            "type": "code",
            "content": "fun main() {\n     \n    val tom = Person(\"Tom\")\n    val bob = Person(\"Bob\", 45)\n      \n    println(\"Name: ${tom.name}  Age: ${tom.age}\")\n    println(\"Name: ${bob.name}  Age: ${bob.age}\")\n}\n \nclass Person{\n    val name: String\n    var age: Int = 0\n     \n    constructor(_name: String){\n        name = _name\n    }\n    constructor(_name: String, _age: Int){\n        name = _name\n        age = _age\n    }\n}"
          },
          {
            "type": "text",
            "content": "Теперь в классе Person также определен еще один конструктор, который принимает только один параметр - имя человека и передает его значение переменной name. Переменная age в данном случае оставляет значение по умолчанию - число 0."
          },
          {
            "type": "text",
            "content": "В функции main вызываем оба конструктора:"
          },
          {
            "type": "code",
            "content": "val tom = Person(\"Tom\")\nval bob = Person(\"Bob\", 45)"
          },
          {
            "type": "text",
            "content": "Для создания первого объекта вызывается первый конструктор, а для второго - второй конструктор. Консольный вывод:"
          },
          {
            "type": "code",
            "content": "Name: Tom  Age: 0\nName: Bob  Age: 45"
          },
          {
            "type": "text",
            "content": "Однако в данном случае мы сталкиваемся с дублированием кода - установкой переменной name. В данном случае это может быть не актуально. Но что, если мы захотим добавить какую-то более сложную логику установки имени, например, с проверкой на длину строки, какие-то другие маркеры? В этом случае лучше делегировать во втором конструкторе установку имени в первый конструктор. То есть из второго конструктора вызвать первый. Для этого применяется ключевое слово this:"
          },
          {
            "type": "code",
            "content": "class Person{\n    val name: String\n    var age: Int = 0\n     \n    constructor(_name: String){\n        name = _name\n    }\n    constructor(_name: String, _age: Int): this(_name){\n        age = _age\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь выражение this(_name) как раз и представляет вызов первого конструктора, где и устанавливается имя."
          },
          {
            "type": "subtitle",
            "content": "\nПервичный конструктор"
          },
          {
            "type": "text",
            "content": "Первичный конструктор является частью заголовка класса и определяется сразу после имени класса:"
          },
          {
            "type": "code",
            "content": "class Person constructor(_name: String, _age: Int){\n    \n}"
          },
          {
            "type": "text",
            "content": "Конструкторы, как и обычные функции, могут иметь параметры. Так, в данном случае конструктор имеет параметр _name, который представляет тип String. Через параметры конструктора мы можем передать извне данные и использовать их для инициализации объекта. При этом первичный конструктор в отличие от функций не определяет никаких действий, он только может принимать данные извне через параметры."
          },
          {
            "type": "text",
            "content": "Если первичный конструктор не имеет никаких аннотаций или модификаторов доступа, как в данном случае, то ключевое слово constructor можно опустить:"
          },
          {
            "type": "code",
            "content": "class Person (_name: String, _age: Int){\n    \n}"
          },
          {
            "type": "text",
            "content": "Значения параметров первичного конструктора можно использовать внутри класса, например, передать их значения переменным класса:"
          },
          {
            "type": "code",
            "content": "fun main() {\n     \n    val tom = Person(\"Tom\", 39)\n    val bob = Person(\"Bob\", 45)\n      \n    println(\"Name: ${tom.name}  Age: ${tom.age}\")\n    println(\"Name: ${bob.name}  Age: ${bob.age}\")\n}\n \nclass Person (_name: String, _age: Int){\n    val name: String = _name\n    var age: Int = _age\n}"
          },
          {
            "type": "text",
            "content": "Стоит отметить, что класс может иметь только один первичный конструктор. И также в классе могут быть одновременно и первичный, и вторичные конструкторы. Однако если для класса определен первичный конструктор, то вторичный конструктор должен вызывать первичный с помощью ключевого слова this:"
          },
          {
            "type": "code",
            "content": "class Person(_name: String){\n    val name: String = _name\n    var age: Int = 0\n     \n    constructor(_name: String, _age: Int) : this(_name){\n        age = _age\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь в классе Person определен первичный конструктор, который принимает значение для установки свойства name:"
          },
          {
            "type": "code",
            "content": "class Person(_name: String)"
          },
          {
            "type": "text",
            "content": "И также добавлен вторичный конструктор. Он принимает два параметра: _name и _age. С помощью ключевого слова this вызывается первичный конструктор, поэтому через этот вызов необходимо передать значения для параметров первичного конструктора. В частности, в первичный конструктор передается значение параметра _name. В самом вторичном конструкторе устанавливается значение свойства age."
          },
          {
            "type": "code",
            "content": "constructor(_name: String, _age: Int) : this(_name){\n    age = _age\n}"
          },
          {
            "type": "text",
            "content": "Таким образом, при вызове вторичного конструктора вначале вызывается первичный конструктор, срабатывает блок инициализатора, который устанавливает свойство name. Затем выполняются собственно действия вторичного конструктора, который устанавливает свойство age."
          },
          {
            "type": "text",
            "content": "Используем данную модификацию класса Person:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"Tom\")         // обращение к первичному конструктору\n    val bob = Person(\"Bob\", 45)     // обращение к вторичному конструктору\n     \n    println(\"Name: ${tom.name}  Age: ${tom.age}\")\n    println(\"Name: ${bob.name}  Age: ${bob.age}\")\n}\n \nclass Person(_name: String){\n    val name: String = _name\n    var age: Int = 0\n     \n    constructor(_name: String, _age: Int) : this(_name){\n        age = _age\n    }\n}"
          },
          {
            "type": "text",
            "content": "В функции main создаются два объекта Person. Для создания объекта tom применяется первичный конструктор, который принимает один параметр. Для создания объекта bob применяется вторичный конструктор с двумя параметрами."
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Name: Tom  Age: 0\nName: Bob  Age: 45 "
          },
          {
            "type": "subtitle",
            "content": "\nПервичный конструктор и свойства"
          },
          {
            "type": "text",
            "content": "Первичный конструктор также может использоваться для определения свойств:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val bob = Person(\"Bob\", 23)\n \n    println(\"Name: ${bob.name}  Age: ${bob.age}\")\n}\n \nclass Person(val name: String, var age: Int)    // { } - здесь не нужны"
          },
          {
            "type": "text",
            "content": "Свойства определяются как и параметры, при этом их определение начинается с ключевого слова val (если их не планируется изменять) и var (если свойства должны быть изменяемыми). И в этом случае нам уже необязательно явным образом определять эти свойства в теле класса, так как их уже определяет конструктор. И при вызове конструктора этим свойствам автоматически передаются значения: Person (\"Bob\", 23)"
          },
          {
            "type": "text",
            "content": "Обратите внимание, что если в классе определен только первичный конструктор, то фигурные скобки, которые оформляют тело класса, использовать необязательно. Хотя мы могли бы написать и так:"
          },
          {
            "type": "code",
            "content": "class Person(val name: String, var age: Int){ }"
          },
          {
            "type": "subtitle",
            "content": "\nИнициализатор"
          },
          {
            "type": "text",
            "content": "Кроме конструкторов для инициализации объектов мы можем использовать блоки инициализаторов. Они представляют блок кода в фигурных скобках, перед которым идет слово init:"
          },
          {
            "type": "code",
            "content": "fun main() {\n     \n    val tom = Person(\"Tom\", -100)\n    val bob = Person(\"Bob\", 45)\n      \n    println(\"Name: ${tom.name}  Age: ${tom.age}\")\n    println(\"Name: ${bob.name}  Age: ${bob.age}\")\n}\n \nclass Person (_name: String, _age: Int){\n    val name: String\n    var age: Int = 1\n \n    init{\n        name = _name\n        if(_age >0 && _age < 110) age = _age\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь в классе Person определен следующий блок инициализатора:"
          },
          {
            "type": "code",
            "content": "init{\n        name = _name\n        if(_age >0 && _age < 110) age = _age\n    }"
          },
          {
            "type": "text",
            "content": "В данном случае блок инициализатора применяется для установки переменных. Так, мы можем определить здесь проверку входных значений, как в случае с параметром _age. Можно определить какую-то другую логику, которая должна выполняться при инициализации объекта."
          },
          {
            "type": "text",
            "content": "Стоит отметить, что в классе может быть определено одновременно несколько блоков инициализатора."
          }
        ]
      },
      {
        "id": 3,
        "title": "Пакеты и импорты",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Пакеты и импорт"
          },
          {
            "type": "text",
            "content": "Пакеты в Kotlin представляют логический блок, который объединяет функционал, например, классы и функции, используемые для решения близких по характеру задач. Так, классы и функции, которые предназначены для решения одной задачи, можно поместить в один пакет, классы и функции для других задач можно поместить в другие пакеты."
          },
          {
            "type": "text",
            "content": "Для определения пакета применяется ключевое словоpackage, после которого идет имя пакета:"
          },
          {
            "type": "code",
            "content": "package email"
          },
          {
            "type": "text",
            "content": "Определение пакета помещается в самое начало файла. И все содержимое файла рассматривается как содержимое этого пакета."
          },
          {
            "type": "text",
            "content": "Например, добавим в проект новый файлemail.kt:"
          },
          {
            "type": "image",
            "content": "ch4ar3_1"
          },
          {
            "type": "text",
            "content": "И определим в нем следующий код:"
          },
          {
            "type": "code",
            "content": "package email\n \nclass Message(val text: String)\n \nfun send(message: Message, address: String){\n    println(\"Message `${message.text}` has been sent to $address\")\n}"
          },
          {
            "type": "text",
            "content": "Пакет называется \"email\". Он содержит класс Message, который содежит одно свойство text. Условно говоря, это класс представляет email-сообщение, а свойство text - его текст."
          },
          {
            "type": "text",
            "content": "Также в этом пакете определена функция send(), которая условно отправляет сообшение на некоторый адрес."
          },
          {
            "type": "text",
            "content": "Допустим, мы хотим использовать функционал этого пакета в другом файле. Для подключения сущностей из пакета необходимо применить директиву import. Здесь возможны различные способы подключения функционала из пакета. Можно подключить в целом весь пакет:"
          },
          {
            "type": "code",
            "content": "import email.*  "
          },
          {
            "type": "text",
            "content": "После названия пакета ставится точка и звездочка, тем самым импортируются все типы из этого пакета. Например, возьмем другой файл проекта -app.kt, который определяет функцию main, и используем в нем функционал пакета email:"
          },
          {
            "type": "code",
            "content": "import email.*\n \nfun main() {\n \n    val myMessage = Message(\"Hello Kotlin\")\n    send(myMessage, \"tom@gmail.com\")\n}"
          },
          {
            "type": "text",
            "content": "Поскольку в начале файла импортированы все типы из пакета email, то мы можем использовать класс Message и функцию send в функции main."
          },
          {
            "type": "text",
            "content": "Консольный вывод данной программы:"
          },
          {
            "type": "code",
            "content": "Message `Hello Kotlin` has been sent to tom@gmail.com"
          },
          {
            "type": "text",
            "content": "Также можно импортировать типы, определенные в пакете, по отдельности:"
          },
          {
            "type": "code",
            "content": "import email.send\nimport email.Message"
          },
          {
            "type": "subtitle",
            "content": "\nПсевдонимы"
          },
          {
            "type": "text",
            "content": "С помощью оператора as можно определять псевдоним для подключаемого типа и затем обращаться к этому типу через его псевдоним:"
          },
          {
            "type": "code",
            "content": "import email.send as sendEmail\nimport email.Message as EmailMessage\n \nfun main() {\n \n    val myMessage = EmailMessage(\"Hello Kotlin\")\n    sendEmail(myMessage, \"tom@gmail.com\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь для функции send() определен псевдоним sendEmail. И далее для обращения к этой функции надо использовать ее псевдоним:"
          },
          {
            "type": "code",
            "content": "sendEmail(myMessage, \"tom@gmail.com\")"
          },
          {
            "type": "text",
            "content": "Также для класса Message определен псевдоним EmailMessage. Соответственно при использовании класса необходимо применять его псевдоним, а не оригинальное имя:"
          },
          {
            "type": "code",
            "content": "val myMessage = EmailMessage(\"Hello Kotlin\")"
          },
          {
            "type": "text",
            "content": "Псевдонимы могут нам особенно пригодится, если у нас импортируются из разных пакетов типы с одним и тем же именем. Например, пусть в проекте есть файл sms.kt:"
          },
          {
            "type": "code",
            "content": "package sms\n \nclass Message(val text: String)\n \nfun send(message: Message, phoneNumber: String){\n    println(\"Message `${message.text}` has been sent to $phoneNumber\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь определен пакет sms также с классом Message и функцией send для отправке сообшения по sms."
          },
          {
            "type": "text",
            "content": "Допустим, в файл еapp.kt мы одновременно хотим использовать класс Message и функцию send и из файла email.kt, и из файла sms.kt:"
          },
          {
            "type": "code",
            "content": "import email.send as sendEmail\nimport email.Message as EmailMessage\nimport sms.send as sendSms\nimport sms.Message as SmsMessage\n \nfun main() {\n \n    val myEmailMessage = EmailMessage(\"Hello Kotlin\")\n    sendEmail(myEmailMessage, \"tom@gmail.com\")\n \n    val mySmsMessage = SmsMessage(\"Hello Kotlin\")\n    sendSms(mySmsMessage, \"+1234567890\")\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВстроенные пакеты"
          },
          {
            "type": "text",
            "content": "Kotlin имеет ряд встроенных пакетов, которые подключаюся по умолчанию в любой файл на языке Kotlin:"
          },
          {
            "type": "text",
            "content": "\t• kotlin.*"
          },
          {
            "type": "text",
            "content": "\t• kotlin.annotation.*"
          },
          {
            "type": "text",
            "content": "\t• kotlin.collections.*"
          },
          {
            "type": "text",
            "content": "\t• kotlin.comparisons.*"
          },
          {
            "type": "text",
            "content": "\t• kotlin.io.*"
          },
          {
            "type": "text",
            "content": "\t• kotlin.ranges.*"
          },
          {
            "type": "text",
            "content": "\t• kotlin.sequences.*"
          },
          {
            "type": "text",
            "content": "\t• kotlin.text.*"
          },
          {
            "type": "text",
            "content": "Поэтому если возникнет необходимость использовать какие-то типы, определенные в этих пакетах, то явным образом эти пакеты не нужно импортировать."
          }
        ]
      },
      {
        "id": 4,
        "title": "Наследование",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Наследование"
          },
          {
            "type": "text",
            "content": "Наследование позволяет создавать классы, которые расширяют функциональность или изменяют поведение уже существующих классов. В отношении наследования выделяются два ключевых компонента. Прежде всего этобазовый класс (класс-родитель, родительский класс, суперкласс), который определяет базовую функциональность. Ипроизводный класс(класс-наследник, подкласс), который наследует функциональность базового класса и может расширять или модифицировать ее."
          },
          {
            "type": "text",
            "content": "Чтобы функциональность класса можно было унаследовать, необходимо определить для этого класса аннотацию open. По умолчанию без этой аннотации класс не может быть унаследован."
          },
          {
            "type": "code",
            "content": "open class базовый_класс\nclass производный_класс: первичный_конструктор_базового_класса"
          },
          {
            "type": "text",
            "content": "Для установки наследования после названия производного класса идет двоеточие. После двоеточия в общем случае вызывается первичный конструктор класса, от которого идет наследование. Рассмотрим пример:"
          },
          {
            "type": "code",
            "content": "open class Person{\n    var name: String = \"Undefined\"\n    fun printName() = println(name)\n}\nclass Employee: Person()"
          },
          {
            "type": "text",
            "content":"Например, в данном случае класс Person представляет человека, который имеет свойство name (имя человека) и метод printName() для вывода информации о человеке. Класс Employee представляет условного работника. Поскольку работник является человеком, то класс работника будет разделять общий функционал с классом человека. Поэтому вместо того, чтобы заново определять в классе Employee свойство name, лучше уснаследовать весь функционал класса Person. То есть в данном случае класс Person является базовым или суперклассом, а класс Employee - производным классом или классом-наследником."
          },
          {
            "type": "text",
            "content": "Но стоит учитывать, что при наследовании производный класс должен вызывать первичный конструктор (а если такого нет, то конструктор по умолчанию) базового класса."
          },
          {
            "type": "text",
            "content": "Здесь класс Person явным образом не определяет первичных конструкторов, поэтому в классе Employee надо вызывать конструктор по умолчанию для класса Person"
          },
          {
            "type": "text",
            "content": "Вызвать конструктор базового класса в производном классе можно двумя способами. Первый способ - после двоеточия сразу указать вызов конструктора базового класса:"
          },
          {
            "type": "code",
            "content": "class Employee: Person()"
          },
          {
            "type": "text",
            "content": "Здесь запись Person() как раз представляет вызов конструктора по умолчанию класса Person."
          },
          {
            "type": "text",
            "content": "Второй способ вызвать конструктор базового класса - определить в производном классе вторичный конструктор и в нем вызвать конструктор базового класса с помощью ключевого слова super:"
          },
          {
            "type": "code",
            "content": "open class Person{\n    var name: String = \"Undefined\"\n    fun printName() = println(name)\n}\nclass Employee: Person{\n \n    constructor() : super()\n}"
          },
          {
            "type": "text",
            "content": "Здесь с помощью ключевого слова constructorв классе Employee определяется вторичный конструктор. А после списка его параметров после двоеточия идет обращение к конструктору базового класса:constructor() : super(). То есть здесь вызов super() - это и есть вызов конструктора базового класса."
          },
          {
            "type": "text",
            "content": "Вне зависимости какой способ будет выбран, далее мы сможем создавать объекты класса Employee и использовать для него уснаследованный от класса Person функционал:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val bob: Employee = Employee()\n    bob.name = \"Bob\"\n    bob.printName()     // Bob\n}\nopen class Person{\n    var name: String = \"Undefined\"\n    fun printName() = println(name)\n}\nclass Employee: Person()"
          },
          {
            "type": "text",
            "content": "Стоит отметить, что те классы, которые явным образом не наследуются от других классов, неявно наследуются от класса Any."
          },
          {
            "type": "subtitle",
            "content": "\nНаследование класса с первичным конструктором"
          },
          {
            "type": "text",
            "content": "Если базовый класс явным образом определяет конструктор (первичный или вторичный), то производный класс должен вызывать этот конструктор. Для вызова конструктора базового в производном применяются те ж способы."
          },
          {
            "type": "text",
            "content": "Первый способ - вызвать конструктор после названия класса через двоеточие:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val bob: Employee = Employee()\n    bob.name = \"Bob\"\n    bob.printName()     // Bob\n}\nopen class Person{\n    var name: String = \"Undefined\"\n    fun printName() = println(name)\n}\nclass Employee: Person()"
          },
          {
            "type": "text",
            "content": "В данном случае класс Person через конструктор устанавливает свойство name. Поэтому в классе Employee тоже определен конструктор, который принимает стороковое значение и передает его в конструктор Person."
          },
          {
            "type": "text",
            "content": "Если производный класс не имеет явного первичного конструктора, тогда при вызове вторичного конструктора должен вызываться конструктор базового класса через ключевое слово super:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String){\n    fun printName()= println(name)\n}\nclass Employee: Person{\n \n    constructor(empName: String) : super(empName){}\n}"
          },
          {
            "type": "text",
            "content": "Опять же, поскольку конструктор Person принимает один параметр, то вsuper()нам надо передать значение для этого параметра."
          },
          {
            "type": "text",
            "content": "Применение классов:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val bob = Employee(\"Bob\")\n    bob.printName()\n}\n \nopen class Person(val name: String){\n    fun printName() = println(name)\n}\nclass Employee(empName: String): Person(empName)"
          },
          {
            "type": "text",
            "content": "Выше рассматривался случай, когда в базовом классе определен первичный конструктор. Но все то же действует и в том случае, если в базовом классе есть только вторичные конструкторы:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val bob = Employee(\"Bob\")\n    bob.printName()\n}\n \nopen class Person{\n \n    val name: String\n    constructor(userName: String){\n        name = userName\n    }\n    fun printName() = println(name)\n}\nclass Employee(empName: String): Person(empName)"
          },
          {
            "type": "subtitle",
            "content": "\nРасширение базового класса"
          },
          {
            "type": "text",
            "content": "Производный класс наследует функционал от базового класса, но также может определять и свой собственный функционал:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val bob = Employee(\"Bob\", \"JetBrains\")\n    bob.printName()\n    bob.printCompany()\n}\n \nopen class Person(val name: String){\n    fun printName() = println(name)\n}\nclass Employee(empName: String, val company: String): Person(empName){\n \n    fun printCompany() = println(company)\n}"
          },
          {
            "type": "text",
            "content": "В данном случае класс Employee добаваляет к унаследованному функционалу свойство company, которое хранит компанию работника, и функцию printCompany()."
          },
          {
            "type": "text",
            "content": "Стоит отметить, что в Kotlin мы можем унаследовать класс только от одного класса, множественное наследование не поддерживается."
          },
          {
            "type": "text",
            "content": "Также, стоит отметить, что все классы по умолчанию наследуются от класса Any, даже если класс Any явным образом не указан в качестве базового. Поэтому любой класс уже по умолчанию будет иметь все свойства и функции, которые определены в классе Any."
          }
        ]
      },
      {
        "id": 5,
        "title": "Переопределение методов и свойств",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Переопределение методов и свойств"
          },
          {
            "type": "text",
            "content": "Kotlin позволяет переопределять в производном классе функции и свойства, которые определенны в базовом классе. Чтобы функции и свойства базового класа можно было переопределить, к ним применяется аннотация open. При переопределении в производном классе к этим функциям применяется аннотация override."
          },
          {
            "type": "subtitle",
            "content": "\nПереопределение свойств"
          },
          {
            "type": "text",
            "content": "Чтобы указать, что свойство можно переопределить в производном классе, перед его определением указывается ключевое слово open:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String){\n    open var age: Int = 1\n}"
          },
          {
            "type": "text",
            "content": "В данном случае свойство age доступно для переопределения."
          },
          {
            "type": "text",
            "content": "Если свойство определяется через первичный конструктор, то также перед его определением ставится аннотация open:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String, open var age: Int = 1)"
          },
          {
            "type": "text",
            "content": "В производном классе для переопределения свойства перед ним указывается аннотация override."
          },
          {
            "type": "code",
            "content": "open class Person(val name: String, open var age: Int = 1)\n \nopen class Employee(name: String): Person(name){\n \n    override var age: Int = 18\n}"
          },
          {
            "type": "text",
            "content": "Здесь переопределение заключается в изменении начального значения для свойства age."
          },
          {
            "type": "text",
            "content": "Также переопределить свойство можно сразу в первичном конструкторе:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String, open var age: Int = 1)\n \nopen class Employee(name: String, override var age: Int = 18): Person(name, age)"
          },
          {
            "type": "text",
            "content": "Применение:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"Tom\")\n    println(\"Name: ${tom.name}  Age: ${tom.age}\")\n \n    val bob = Employee(\"Bob\")\n    println(\"Name: ${bob.name}  Age: ${bob.age}\")\n}\nopen class Person(val name: String, open var age: Int = 1)\n \nopen class Employee(name: String, override var age: Int = 18): Person(name, age)"
          },
          {
            "type": "text",
            "content": "Консольный вывод:"
          },
          {
            "type": "code",
            "content": "Name: Tom  Age: 1\nName: Bob  Age: 18"
          },
          {
            "type": "subtitle",
            "content": "\nПереопределение геттеров и сеттеров"
          },
          {
            "type": "text",
            "content": "Также можно переопределять геттеры и сеттеры свойств:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String){\n \n    open val fullInfo: String\n        get() = \"Person $name - $age\"\n \n    open var age: Int = 1\n        set(value){\n            if(value in 1..109) field = value\n        }\n}\nopen class Employee(name: String): Person(name){\n \n    override val fullInfo: String\n        get() = \"Employee $name - $age\"\n \n    override var age: Int = 18\n        set(value){\n            if(value in 18..109) field = value\n        }\n}\n \nfun main() {\n \n    val tom = Person(\"Tom\")\n    tom.age = 14\n    println(tom.fullInfo)       // Person Tom - 14\n \n    val bob = Employee(\"Bob\")\n    bob.age = 14\n    println(bob.fullInfo)       // Employee Bob - 18\n}"
          },
          {
            "type": "text",
            "content": "Здесь класс Employee переопределяет геттер свойства fullInfoи сеттер свойства age"
          },
          {
            "type": "subtitle",
            "content": "\nПереопределение методов"
          },
          {
            "type": "text",
            "content": "Чтобы функции базового класа можно было переопределить, к ним применяется аннотация open. При переопределении в производном классе к этим функциям применяется аннотация override:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String){\n    open fun display() = println(\"Name: $name\")\n}\nclass Employee(name: String, val company: String): Person(name){\n \n    override fun display() = println(\"Name: $name    Company: $company\")\n}\n \nfun main() {\n \n    val tom = Person(\"Tom\")\n    tom.display()       // Name: Tom\n \n    val bob = Employee(\"Bob\", \"JetBrains\")\n    bob.display()       // Name: Bob  Company: JetBrains\n}"
          },
          {
            "type": "text",
            "content": "Функция display определена в классе Person с аннотацией open, поэтому в производных классах его можно переопределить. В классе Employee эта функция переопределена с применением аннотации override."
          },
          {
            "type": "subtitle",
            "content": "\nПереопределение в иерархии наследования классов"
          },
          {
            "type": "text",
            "content": "Стоит учитывать, что переопределить функции можно по всей иерархии наследования. Например, у нас может быть класс Manager, унаследованный от Employee:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String){\n \n    open fun display() =  println(\"Name: $name\")\n}\nopen class Employee(name: String, val company: String): Person(name){\n \n    override fun display() {\n        println(\"Name: $name    Company: $company\")\n    }\n}\nclass Manager(name: String, company: String):Employee(name, company){\n \n    override fun display() {\n        println(\"Name: $name Company: $company  Position: Manager\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае класс Manager переопределяет функцию display, поскольку среди его базовых классов есть класс Person, который определяет эту функцию с ключевым словом open."
          },
          {
            "type": "subtitle",
            "content": "\nЗапрет переопределения"
          },
          {
            "type": "text",
            "content": "В это же время иногда бывает необходимо запретить дальнейшее переопределение функции в классах-наследниках. Для этого применяется ключевое слово final:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String){\n \n    open fun display() = println(\"Name: $name\")\n}\nopen class Employee(name: String, val company: String): Person(name){\n \n    final override fun display() {\n        println(\"Name: $name    Company: $company\")\n    }\n}\nclass Manager(name: String, company: String):Employee(name, company){\n    // теперь функцию нельзя переопределить\n    /*override fun display() {\n        println(\"Name: $name Company: $company  Position: Manager\")\n    }*/\n}"
          },
          {
            "type": "subtitle",
            "content": "\nОбращение к реализации из базового класса"
          },
          {
            "type": "text",
            "content": "С помощью ключевого слова super в производном классе можно обращаться к реализации из базового класса."
          },
          {
            "type": "code",
            "content": "open class Person(val name: String){\n \n    open val fullInfo: String\n        get() = \"Name: $name\"\n \n    open fun display(){\n        println(\"Name: $name\")\n    }\n}\nopen class Employee(name: String, val company: String): Person(name){\n \n    override val fullInfo: String\n        get() = \"${super.fullInfo} Company: $company\"\n \n    final override fun display() {\n        super.display()\n        println(\"Company: $company\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае производный класс Employee при переопределении свойства и функции применяет реализацию из базового класса Person. Например, через super.fullInfo возвращается значение свойства из базового класса (то есть значение свойства name), а с помощью вызова super.display() вызывается реализация функции display из класса Person."
          }
        ]
      },
      {
        "id": 6,
        "title": "Модификаторы видимости",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Модификаторы видимости"
          },
          {
            "type": "text",
            "content": "Все используемые типы, а также компоненты типов (классы, объекты, интерфейсы, конструкторы, функции, свойства) имеют определеннй уровень видимости, определяемый модификатором видимости (модификатором доступа). Модификатор видимости определяет, где те или иные типы и их компоненты доступны и где их можно использовать. В Kotlin есть следующие модификаторы видимости:"
          },
          {
            "type": "text",
            "content": "\t• private: классы, объекты, интерфейсы, а также функции и свойства, определенные вне класса, с этим модификатором видны только в том файле, в котором они определены. Члены класса с этим модификатором видны только в рамках своего класса"
          },
          {
            "type": "text",
            "content": "\t• protected: члены класса с этим модификатором видны в классе, в котором они определены, и в классах-наследниках"
          },
          {
            "type": "text",
            "content": "\t• internal: классы, объекты, интерфейсы, функции, свойства, конструкторы с этим модификатором видны в любой части модуля, в котором они определены. Модуль представляет набор файлов Kotlin, скомпилированных вместе в одну структурную единицу. Это может быть модуль IntelliJ IDEA или проект Maven"
          },
          {
            "type": "text",
            "content": "\t• public: классы, функции, свойства, объекты, интерфейсы с этим модификатором видны в любой части программы. (При этом если функции или классы с этим модификатором определены в другом пакете их все равно нужно импортировать)"
          },
          {
            "type": "text",
            "content": "Для установки уровня видимости модификатор ставится перед ключевыми словами var/val/fun в самом начале определения свойства или функции."
          },
          {
            "type": "text",
            "content": "Если модификатор видимости явным образом не указан, то применяется модификатор public. То есть следующий класс"
          },
          {
            "type": "code",
            "content": "class Person(){\n \n    var name = \"Undefined\"\n    var age = 18\n     \n    fun printPerson(){\n        println(\"Name: $name  Age: $age\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Будет эквивалентен следующему определению класса:"
          },
          {
            "type": "code",
            "content": "class Person(){\n \n    public var name = \"Undefined\"\n    public var age = 18\n \n    public fun printPerson(){\n        println(\"Name: $name  Age: $age\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Если свойства объявляются через первичный конструктор и для них явным образом не указан модификатор видимости:"
          },
          {
            "type": "code",
            "content": "class Person(val name: String, val age: Int){\n    public fun printPerson(){\n        println(\"Name: $name  Age: $age\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "То также к таким свойствам автоматически применяется public:"
          },
          {
            "type": "code",
            "content": "class Person(public val name: String, public val age: Int){\n    public fun printPerson(){\n        println(\"Name: $name  Age: $age\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Соответственно мы можем обращаться к подобным компонентам класса в любом месте программы:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"Tom\", 37)\n    tom.printPerson()       // Name: Tom    Age: 37\n \n    println(tom.name)\n    println(tom.age)\n}"
          },
          {
            "type": "subtitle",
            "content": "\nprivate"
          },
          {
            "type": "text",
            "content": "Если же к свойствам и методам применяется модификатор private, то к ним нельзя будет обратиться извне - вне данного класса."
          },
          {
            "type": "code",
            "content": "class Person(private val name:String, _age: Int){\n \n    private val age = _age\n \n    fun printPerson(){\n        printName()\n        printAge()\n    }\n    private fun printName(){\n        println(\"Name: $name\")\n    }\n    private fun printAge(){\n        println(\"Age: $age\")\n    }\n}\n \nfun main() {\n \n    val tom = Person(\"Tom\", 37)\n    tom.printPerson()\n     \n    // println(tom.name)   // Ошибка! - свойство name - private\n    // tom.printAge()  // Ошибка! - функция printAge - private\n}"
          },
          {
            "type": "text",
            "content": "В данном случае класс Person определяет два свойства name (имя человека) и age (возраст человека). Чтобы было более показательно, одно свойство определено через конструктор, а второе как переменная класса. И поскольку эти свойства определены с модификатором private, то мы можем к ним обращаться только внутри этого класса. Вне класса обращаться к ним нельзя:"
          },
          {
            "type": "code",
            "content": "println(tom.name)   // Ошибка! - свойство name - private"
          },
          {
            "type": "text",
            "content": "Также в классе определены три функции printPerson(), printAge() и printName(). Последние две функции выводят значения свойств. А функция printPerson выводит информацию об объекте, вызывая предыдущие две функции."
          },
          {
            "type": "text",
            "content": "Однако функции printAge() и printName() определены как приватные, поэтому их можно использовать только внутри класса:"
          },
          {
            "type": "code",
            "content": "tom.printAge()  // Ошибка! - функция printAge - private"
          },
          {
            "type": "subtitle",
            "content": "\nprotected"
          },
          {
            "type": "text",
            "content": "Модификатор protected определяет свойства и функции, которые из вне класса видны только в классах-наследниках:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Employee(\"Tom\", 37)\n    tom.printEmployee()       // Name: Tom    Age: 37\n \n    // println(tom.name)   // Ошибка! - свойство name - protected\n    // tom.printPerson()  // Ошибка! - функция printPerson - protected\n}\nopen class Person(protected val name:String, private val age: Int){\n \n     protected fun printPerson(){\n        printName()\n        printAge()\n    }\n    private fun printName(){\n        println(\"Name: $name\")\n    }\n    private fun printAge(){\n        println(\"Age: $age\")\n    }\n}\nclass Employee(name:String, age: Int) : Person(name, age){\n \n    fun printEmployee(){\n        println(\"Employee $name. Full information:\")\n        printPerson()\n        // printName() // нельзя - printName - private\n        // println(\"Age: $age\")    // нельзя age - private\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь в классе Person свойство name определенно как protected, поэтому оно доступно в классе-наследнике Employee (однако вне базового и производного класса - например, в функции main оно недоступно). А вот свойство age- приватное, поэтому оно доступно только внутри класса Person."
          },
          {
            "type": "text",
            "content": "Также в классе Employee будет доступна функция printPerson(), так как она имеет модификатор protected, а функции printAge() и printName() с модификатором private будут недоступны."
          },
          {
            "type": "subtitle",
            "content": "\nМодификаторы конструкторов"
          },
          {
            "type": "text",
            "content": "Конструкторы как первичные, так и вторичные также могут иметь модификаторы. Модификатор указывается перед ключевым словом constructor. По умолчанию они имеют модификатор public. Если для первичного конструктора необходимо явным образом установить модификатор доступа, то конструктор определяется с помощью ключевого слова constructor:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    // val bob  = Person(\"Bob\")    // Так нельзя - конструктор private\n}\nopen class Person private constructor(val name:String){\n \n     fun printPerson(){\n        println(\"Name: $name\")\n    }\n}\n// class Employee(name:String) : Person(name)  // так нельзя - конструктор в Person private"
          },
          {
            "type": "text",
            "content": "Стоит отметить, что в данном случае, поскольку конструктор приватный мы не можем его использовать вне класса ни для создания объекта класса в функции main, ни при наследовании. Но мы можем использовать такой конструктор в других конструкторах внутри класса:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Employee(\"Tom\", 37)\n    tom.printPerson()\n}\nopen class Person private constructor(val name:String){\n \n    var age: Int = 0\n    protected constructor(_name:String, _age: Int): this(_name){    // вызываем приватный конструктор\n        age = _age\n    }\n     fun printPerson(){\n        println(\"Name: $name Age: $age\")\n    }\n}\nclass Employee(name:String, age: Int) : Person(name, age)"
          },
          {
            "type": "text",
            "content": "Здесь вторичный конструктор класса Person, который имеет модификатор protected (то есть доступен в текущем классе и классах-наследниках) вызывает первичный конструктор класса Person, который имеет модификато рprivate."
          },
          {
            "type": "subtitle",
            "content": "\nМодификаторы объектов и типов верхнего уровня"
          },
          {
            "type": "text",
            "content": "Классы, а также переменные и функции, которые определены вне других классов, также могут иметь модификаторы public, private и internal."
          },
          {
            "type": "text",
            "content": "Допустим, у нас есть файл base.kt, который определяет одноименный пакет:"
          },
          {
            "type": "code",
            "content": "package base\n \nprivate val privateVal = 3\ninternal val internalVal = 4\nval publicVal = 5\n \nprivate fun privateFun() = println(\"privateFn\")\nfun internalFun() = println(\"internalFn\")\nfun publicFun() = println(\"publicFn\")\n \nprivate class PrivateClass(val name: String)\ninternal class InternalClass(val name:String)\nclass PublicClass(val name:String)\n \nfun printData(){\n    // внутри модуля доступны приватные идентификаторы\n    val privateClass= PrivateClass(\"Tom\")\n    println(privateVal)\n    privateFun()\n \n    // внутри модуля доступны internal-идентификаторы\n    val internalClass= InternalClass(\"Tom\")\n    println(internalVal)\n    internalFun()\n \n    // внутри модуля доступны public-идентификаторы\n    val publicClass= PublicClass(\"Tom\")\n    println(publicVal)\n    publicFun()\n}"
          },
          {
            "type": "text",
            "content": "Внутри данного файла мы можем использовать его приватные переменные, функции классы. Однако при подключении этого пакета в другие файлы, приватные переменные, функции и классы будут недоступны:"
          },
          {
            "type": "code",
            "content": "import base.*\n \nfun main() {\n \n    publicFun()\n    val publicClass= PublicClass(\"Tom\")\n    println(publicVal)\n \n \n    // privateFun()                         // функция недоступна\n    // val privateClass= PrivateClass(\"Tom\")    // класс недоступен\n    // println(privateVal)      // переменная недоступна\n \n    // если в одном модуле, то internal-компоненты доступны\n    internalFun()                         // функция доступна\n    val internalClass= InternalClass(\"Tom\")    // класс доступен\n    println(internalVal)      // переменная доступна\n}"
          },
          {
            "type": "text",
            "content": "Однако даже внутри одного файла есть ограничения на использование приватных классов:"
          },
          {
            "type": "code",
            "content": "package email\n \nprivate class Message(val text: String)\n \nfun send(message: Message, address : String){\n    println(\"Message `${message.text}` has been sent to $address\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь мы столкнемся с ошибкой, так как публичная функция не может принимать параметр приватного класса. И в данном случае нам надо либо сделать класс Message публичным, либо функцию send приватной."
          }
        ]
      },
      {
        "id": 7,
        "title": "Геттеры и сеттеры",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Геттеры и сеттеры"
          },
          {
            "type": "text",
            "content": "Геттеры (getter) и сеттеры (setter) (еще их называют методами доступа) позволяют управлять доступом к переменной. Их формальный синтаксис:еВперед"
          },
          {
            "type": "code",
            "content": "var имя_свойства[: тип_свойства] [= инициализатор_свойства]\n    [getter]\n    [setter]"
          },
          {
            "type": "text",
            "content": "Инициализатор, геттер и сеттер свойства необязательны. Указывать тип свойства также необязательно, если он может быть выведен их значения инициализатора или из возвращаемого значения геттера."
          },
          {
            "type": "text",
            "content": "Геттеры и сеттеры необязательно определять именно для свойств внутри класса, они могут также применяться к переменным верхнего уровня."
          },
          {
            "type": "subtitle",
            "content": "\nСеттер"
          },
          {
            "type": "text",
            "content": "Сеттер определяет логику установки значения переменной. Он определяется с помощью слова set. Например, у нас есть переменная age, которая хранит возраст пользователя и представляет числовое значение."
          },
          {
            "type": "code",
            "content": "var age: Int = 18"
          },
          {
            "type": "text",
            "content": "Но теоретически мы можем установить любой возраст: 2, 6, -200, 100500. И не все эти значения будут корректными. Например, у человека не может быть отрицательного возраста. И для проверки входных значений можно использовать сеттер:"
          },
          {
            "type": "code",
            "content": "var age: Int = 18\n    set(value){\n        if((value>0) and (value < 110))\n            field = value\n    }\n \nfun main() {\n \n    println(age)    // 18\n    age = 45\n    println(age)    // 45\n    age = -345\n    println(age)    // 45\n}"
          },
          {
            "type": "text",
            "content": "Блок set определяется сразу после свойства, к которому оно относится - в данном случае после свойства age."
          },
          {
            "type": "text",
            "content": "В блоке set проверяем, входит ли устанавливаемое значение в диапазон допустимых значений. Если входит, то есть если значение корректно, то передаем его объекту field. Если значение некорректно, то свойство просто сохраняет свое предыдущее значение."
          },
          {
            "type": "text",
            "content": "Идентификатор field представляет автоматически генерируемое поле, которое непосредственно хранит значение свойства. Стоит отметить, что к полю через идентификатор field можно обратиться только в геттере или в сеттере, и в каждом конкретном свойстве можно обращаться только к своему полю."
          },
          {
            "type": "text",
            "content": "В функции main при втором обращении к сеттеру (age = -345) можно заметить, что значение свойства age не изменилось. Так как новое значение -345 не входит в диапазон от 0 до 110."
          },
          {
            "type": "subtitle",
            "content": "\nГеттер"
          },
          {
            "type": "text",
            "content": "Геттер управляет получением значения свойства и определяется с помощью ключевого слова get:"
          },
          {
            "type": "code",
            "content": "var age: Int = 18\n    set(value){\n        if((value>0) and (value <110))\n            field = value\n    }\n    get() = field"
          },
          {
            "type": "text",
            "content": "Справа от выражения get() через знак равно указывается возвращаемое значение. В данном случае возвращается значения поля field, которое хранит значение свойства name. Хотя в таком геттер большого смысла нет, поскольку получить подобное значение мы можем и без геттера."
          },
          {
            "type": "text",
            "content": "Если геттер должен содержать больше инструкций, то геттер можно оформить в блок с кодом внутри фигурных скобок:"
          },
          {
            "type": "code",
            "content": "var age: Int = 18\n    set(value){\n        println(\"Call setter\")\n        if((value>0) and (value <110))\n            field = value\n    }\n    get(){\n        println(\"Call getter\")\n        return field\n    }"
          },
          {
            "type": "text",
            "content": "Если геттер оформлен в блок кода, то для возвращения значения необходимо использовать оператор return. И, таким образом, каждый раз, когда мы будем получать значение переменной age(например, в случае с вызовом println(age)), будет срабатывать геттер, когда возвращает значение. Например:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    println(age)    // срабатывает get\n    age = 45        // срабатывает set\n    println(age)    // срабатывает get\n}"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Call getter\n18\nCall setter\nCall getter\n45"
          },
          {
            "type": "subtitle",
            "content": "\nИспользование геттеров и сеттеров в классах"
          },
          {
            "type": "text",
            "content": "Хотя геттеры и сеттеры могут использоваться к глобальным переменным, как правило, они применяются для опосредования доступа к свойствам класса."
          },
          {
            "type": "text",
            "content": "Используем сеттер:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val bob: Person = Person(\"Bob\")\n    bob.age = 25        // вызываем сеттер\n \n    println(bob.age)   // 25\n    bob.age = -8        // вызываем сеттер\n    println(bob.age)   // 25\n}\nclass Person(val name: String){\n \n    var age: Int = 1\n        set(value){\n            if((value>0) and (value <110))\n                field = value\n        }\n}"
          },
          {
            "type": "text",
            "content": "При втором обращении к сеттеру (bob.age = -8) можно заметить, что значение свойства age не изменилось. Так как новое значение -8 не входит в диапазон от 0 до 110."
          },
          {
            "type": "subtitle",
            "content": "\nВычисляемый геттер"
          },
          {
            "type": "text",
            "content": "Геттер может возвращать вычисляемые значения, которые могут задействовать несколько свойств:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val tom = Person(\"Tom\", \"Smith\")\n    println(tom.fullname)   // Tom Smith\n    tom.lastname = \"Simpson\"\n    println(tom.fullname)   // Tom Simpson\n}\nclass Person(var firstname: String, var lastname: String){\n \n    val fullname: String\n        get() = \"$firstname $lastname\"\n}"
          },
          {
            "type": "text",
            "content": "Здесь свойство fullname определяет блок get, который возвращает полное имя пользователя, созданное на основе его свойств firstname и lastname. При этом значение самого свойства fullname напрямую мы изменить не можем - оно определено доступно только для чтения. Однако если изменятся значения составляющих его свойств - firstname и lastname, то также изменится значение, возвращаемое из fullname."
          },
          {
            "type": "subtitle",
            "content": "\nИспользование полей для хранения значений"
          },
          {
            "type": "text",
            "content": "Выше уже рассматривалось, что с помощью специального поля field в сеттере и геттере можно обращаться к непосредственному значению свойства, которое хранится в специальном поле. Однако мы сами можем явным образом определить подобное поле. Нередко это приватное поле:"
          },
          {
            "type": "text",
            "content": "Можно использовать одновременно и геттер, и сеттер:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = Person(\"Tom\")\n    println(tom.age)    // 1\n    tom.age = 37\n    println(tom.age)    // 37\n    tom.age = 156\n    println(tom.age)    // 37\n}\nclass Person(val name: String){\n \n    private var _age = 1\n    var age: Int\n        set(value){\n            if((value > 0) and (value < 110))\n                _age = value\n        }\n        get()=  _age\n}"
          },
          {
            "type": "text",
            "content": "Здесь для свойства age добавлены геттер и сеттер, которые фактически являются надстройкой над полей _age, которое собственно хранит значение."
          }
        ]
      },
      {
        "id": 8,
        "title": "Абстрактные классы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Абстрактные классы и методы"
          },
          {
            "type": "text",
            "content": "Абстрактные классы - это классы, определенные с модификатором abstract. Отличительной особенностью абстрактных классов является то, что мы не можем создать объект подобного класса. Например, определим абстрактный класс Human:"
          },
          {
            "type": "code",
            "content": "abstract class Human(val name: String)"
          },
          {
            "type": "text",
            "content": "Абстрактный класс, как и обычный, может иметь свойства, функции, конструкторы, но создать его объект напрямую вызвав его конструктор мы не можем:"
          },
          {
            "type": "code",
            "content": "val kate: Human     // норм, просто определение переменной\nval alice: Human = Human(\"Alice\")   // ! ошибка, создать объект нельзя"
          },
          {
            "type": "text",
            "content": "Такой класс мы можем только унаследовать:"
          },
          {
            "type": "code",
            "content": "abstract class Human(val name: String){\n \n    fun hello(){\n        println(\"My name is $name\")\n    }\n}\nclass Person(name: String): Human(name)"
          },
          {
            "type": "text",
            "content": "Стоит отметить, что в данном случае перед абстрактным классом не надо указывать аннотацию open, как при наследовании неабстрактных классов."
          },
          {
            "type": "code",
            "content": "fun main(args: Array<String>) {\n \n    val kate: Person = Person(\"Kate\")\n    val slim: Human = Person(\"Slim Shady\")\n    kate.hello()    // My name is Kate\n    slim.hello()    // My name is Slim Shady\n}"
          },
          {
            "type": "text",
            "content": "Абстрактные классы могут иметь абстрактные методы и свойства. Это такие функции и свойства, которые определяются с ключевым словом abstract. Абстрактные методы не содержат реализацию, то есть у них нет тела. А для абстрактных свойств не указывается значение. При этом абстрактные методы и свойства можно определить только в абстрактных классах:"
          },
          {
            "type": "code",
            "content": "abstract class Human(val name: String){\n \n    abstract var age: Int\n    abstract fun hello()\n}\nclass Person(name: String): Human(name){\n     \n    override var age : Int = 1\n    override fun hello(){\n        println(\"My name is $name\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Если класс наследуется от абстрактного класса, то он должен либо реализовать все его абстрактные методы и свойства, либо также быть абстрактным."
          },
          {
            "type": "text",
            "content": "Так, в данном случае класс Person должен обязательно определить реализацию для функции hello() и свойства age. При этом, как и при переопределении обычных методов и свойств, применяется аннотация override."
          },
          {
            "type": "text",
            "content": "Абстрактные свойства также можно реализовать в первичном конструкторе:"
          },
          {
            "type": "code",
            "content": "abstract class Human(val name: String){\n \n    abstract var age: Int\n    abstract fun hello()\n}\nclass Person(name: String, override var age : Int): Human(name){\n    override fun hello(){\n        println(\"My name is $name\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Зачем нужны абстрактные классы? Классы обычно отражают какие-то сущности реального мира. Но некоторые из этих сущностей представляют абстракцию, которая непосредственного воплощения не имеет. Например, возьмем систему геометрических фигур. В реальности не существует геометрической фигуры как таковой. Есть круг, прямоугольник, квадрат, но просто фигуры нет. Однако же и круг, и прямоугольник имеют что-то общее и являются фигурами. В этом случае мы можем определить абстрактный класс фигуры и затем от него унаследовать все остальные классы фигур:"
          },
          {
            "type": "code",
            "content": "// абстрактный класс фигуры\nabstract class Figure {\n    // абстрактный метод для получения периметра\n    abstract fun perimeter(): Float\n \n    // абстрактный метод для получения площади\n    abstract fun area(): Float\n}\n// производный класс прямоугольника\nclass Rectangle(val width: Float, val height: Float) : Figure()\n{\n    // переопределение получения периметра\n    override fun perimeter(): Float{\n        return width * 2 + height * 2;\n    }\n    // переопрелеление получения площади\n    override fun area(): Float{\n        return width * height;\n    }\n}"
          }
        ]
      },
      {
        "id": 9,
        "title": "Интерфейсы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Интерфейсы"
          },
          {
            "type": "text",
            "content": "Интерфейсы представляют контракт - набор функциональности, который должен реализовать класс. Интерфейсы могут содержать объявления свойств и функций, а также могут содержать их реализацию по умолчанию. Интерфейсы позволяют реализовать в программе концепциюполиморфизмаи решить проблемумножественного наследования, поскольку класс может унаследовать только один класс, зато интерфейсов он может реализовать множество."
          },
          {
            "type": "text",
            "content": "Для определения интерфейса применяется ключевое слово interface:"
          },
          {
            "type": "code",
            "content": "interface название_интерфейса{\n    // определения функций и свойств\n}"
          },
          {
            "type": "text",
            "content": "Для применения интерфейса после имени класса через двоеточие (как при наследовании) указывается имя применяемого интерфейса:"
          },
          {
            "type": "code",
            "content": "interface Movable{}\nclass Car : Movable {}"
          },
          {
            "type": "text",
            "content": "В данном случае класс Car реализует интерфейс Movable."
          },
          {
            "type": "text",
            "content": "Интерфейс может определять функции без реализации. Например:"
          },
          {
            "type": "code",
            "content": "interface Movable{\n    fun move()      // определение функции без реализации\n}"
          },
          {
            "type": "text",
            "content": "Например, в данном случае интерфейс Movable представляет функционал транспортного средства и определяет одну функцию без реализации - функцию move(), которая условно предназначена для передвижения транспортного средства."
          },
          {
            "type": "text",
            "content": "Таким образом, у нас еть интерфейс Movable, которое представляет непонятно какое транспортное средство, и есть функция move, которая предназначена для перемещения транспортного средства, но как именно это перемещение осуществляется - неизвестно."
          },
          {
            "type": "text",
            "content": "Стоит отметить, что мы не можем напрямую создать объект интерфейса, так как интерфейс не поддерживает конструкторы и просто представляет шаблон, которому класс должен соответствовать."
          },
          {
            "type": "text",
            "content": "Определим два класса, которые применяют этот интерфейс:"
          },
          {
            "type": "code",
            "content": "// класс машины\nclass Car : Movable{\n    override fun move(){\n        println(\"Едем на машине\")\n    }\n}\n// класс самолета\nclass Aircraft : Movable{\n    override fun move(){\n        println(\"Летим на самолете\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь определены классы Car и Aircraft, которые условно представляют машину и самолет. При применении интерфейса класс должен реализовать все его абстрактные методы и свойства. При реализации функций и свойств перед ними ставится ключевое слово override."
          },
          {
            "type": "text",
            "content": "Так, класс Car применяет интерфейс Movable. Так как интерфейс содержит абстрактный метод move(), то класс Car обязательно должен его реализовать. То же самое касается класса Aircraft."
          },
          {
            "type": "text",
            "content": "Далее мы можем вызвать реализованный метод move как любую другую функцию класса:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val car = Car()\n    val aircraft = Aircraft()\n    car.move()\n    aircraft.move()\n}"
          },
          {
            "type": "text",
            "content": "Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Едем на машине\nЛетим на самолете"
          },
          {
            "type": "text",
            "content": "И реализация интерфейса также означает, что мы можем рассматривать объекты классом Car и Aircraft как объекты Movable. И тут в дело вступает полиморфизм:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val car = Car()\n    val aircraft = Aircraft()\n    travel(car)         // Едем на машине\n    travel(aircraft)    // Летим на самолете\n}\n \nfun travel(obj: Movable) = obj.move()\n \ninterface Movable{\n    fun move()\n}\nclass Car : Movable{\n    override fun move(){\n        println(\"Едем на машине\")\n    }\n}\nclass Aircraft : Movable{\n    override fun move(){\n        println(\"Летим на самолете\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае функция travel (условная функция путешествия на транспорте) в качестве параметра получает объект Movable. Это может быть машина, и самолет, и любой другой объект, класс которого реализует интерфейс Movable"
          },
          {
            "type": "text",
            "content": "Также стоит отметить, что мы можем напрямую определить объекты типа интерфейса, но для их создания будут применяться конструкторы классов, которые реализуют интерфейс:"
          },
          {
            "type": "code",
            "content": "val car : Movable = Car()\nval aircraft : Movable = Aircraft()"
          },
          {
            "type": "subtitle",
            "content": "\nМножественная реализация интерфейсов"
          },
          {
            "type": "text",
            "content": "Мы не можем наследовать один класс от нескольких классов, зато класс может реализовать множество интерфейсов. Например, у нас есть два интерфейса:"
          },
          {
            "type": "code",
            "content": "interface Worker{\n    fun work()\n}\ninterface Student{\n    fun study()\n}"
          },
          {
            "type": "text",
            "content": "Интерфейс Worker представляет работающего, а интерфейс Student - учащегося. А что если нам надо определить сущность работающего студента? В этом случае мы можем реализовать в классе оба этих интерфейса:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val tom = WorkingStudent(\"Tom\")\n    work(tom)   // Tom работает\n    study(tom)  // Tom учится\n}\nfun work(worker:Worker) = worker.work()\nfun study(student:Student) = student.study()\n \ninterface Worker{\n    fun work()\n}\ninterface Student{\n    fun study()\n}\nclass WorkingStudent(val name:String) : Worker, Student{\n    override fun work() = println(\"$name работает\")\n    override fun study() = println(\"$name учится\")\n}"
          },
          {
            "type": "text",
            "content": "Класс WorkingStudent реализует оба интерфейса - Worker и Student. Все реализуемые интерфейсы передаются после двоеточия через запятую."
          },
          {
            "type": "subtitle",
            "content": "\nРеализация методов по умолчанию."
          },
          {
            "type": "text",
            "content": "Интерфейс может также определять реализацию по умолчанию для своих методов. В свою очередь, класс, который реализует этот интерфейс, может принять эти методы как есть, а может и переопределить их. Например:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val car = Car()\n    val aircraft = Aircraft()\n \n    car.move()  // Едем на машине\n    car.stop()  // Останавливаемся...\n \n    aircraft.move() // Летим на самолете\n    aircraft.stop() // Приземляемся...\n}\ninterface Movable{\n    fun move()      // определение функции без реализации\n    fun stop() {     // определение функции с реализацией по умолчанию\n        println(\"Останавливаемся...\")\n    }\n}\nclass Car : Movable{\n    override fun move(){\n        println(\"Едем на машине\")\n    }\n}\nclass Aircraft : Movable{\n    override fun move(){\n        println(\"Летим на самолете\")\n    }\n    override fun stop() = println(\"Приземляемся...\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь в интерфейсе Movable для функции stop определена реализация по умолчанию. Класс Car не изменяет ее. А класс Aircraft переопределяет эту функцию."
          },
          {
            "type": "subtitle",
            "content": "\nРеализация свойств"
          },
          {
            "type": "text",
            "content": "Интерфейс может определять свойства - таким свойствам в интерфейсе им не присваиваются значения. Класс же, который реализует интерфейс, также обязан реализовать эти свойства. Например:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val car = Car()\n    val aircraft = Aircraft()\n \n    car.move()          // Едем на машине со скоростью 60 км/ч\n    aircraft.move()     // Летим на самолете со скоростью 600 км/ч\n}\ninterface Movable{\n    var speed: Int  // объявление свойства\n    fun move()      // определение функции без реализации\n}\nclass Car : Movable{\n    override var speed = 60\n    override fun move() {\n        println(\"Едем на машине со скоростью $speed км/ч\")\n    }\n}\nclass Aircraft : Movable{\n    override var speed = 600\n    override fun move(){\n        println(\"Летим на самолете со скоростью $speed км/ч\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае в интерфейсе Movable определено свойство speed. Здесь реализация свойства в классах заключается в установке для него начального значения."
          },
          {
            "type": "subtitle",
            "content": "\nУстановка свойств через конструктор"
          },
          {
            "type": "text",
            "content": "Стоит отметить, что реализуемые свойства интерфейса могут устанавливаться через конструктор. Иногда это единственное место, где можно получить значения для свойств. Например:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val tesla: Car = Car(\"Tesla\", \"2345SDG\")\n    println(tesla.model)    // Tesla\n    println(tesla.number)   // 2345SDG\n \n    tesla.move()    // Едем на машине со скоростью 60 км/ч\n}\ninterface Movable{\n    var speed: Int  // объявление свойства\n    val model: String\n    val number: String\n    fun move()      // определение функции без реализации\n}\n// в первичном конструкторе реализуем свойства интерфейса\nclass Car(override val model: String, override var number: String) : Movable{\n    override var speed = 60\n    override fun move() {\n        println(\"Едем на машине со скоростью $speed км/ч\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь интерфейс Movable также определяет свойства model (модель) и number (номер транспортного средства). Но эти характеристики различаются для каждой конкретной машины, соответственно их предпочтительнее устанавливать в конструкторе. В примере выше они устанавливаются в первичном конструкторе класса Car."
          },
          {
            "type": "subtitle",
            "content": "\nПравила переопределения"
          },
          {
            "type": "text",
            "content": "В Kotlin мы можем одновременно реализовать интерфейсы, которые определяют функцию с одним и тем же именем. То же самое касается ситуации, когда класс одновременно реализует интерфейс и наследует класс, которые имеют одноименную функцию. В программировании подобная проблема известна как diamond problem или проблема \"ромба\"/\"ромбовидного наследования\". В этом случае класс, реализующий интерфейсы, может определить одну функцию для всех реализаций:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val player = MediaPlayer()\n    player.play()   // Play audio and video\n}\ninterface  VideoPlayable {\n    fun play()\n}\ninterface AudioPlayable {\n    fun play()\n}\n \nclass MediaPlayer : VideoPlayable, AudioPlayable {\n    // Функция play для обоих интерфейсов\n    override fun play() = println(\"Play audio and video\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь интерфейсы VideoPlayable и  AudioPlayable определяют функцию play. В этом случае класс MediaPlayer, который применяет оба интерфейса, обязательно должен определить функцию с тем же именем, то есть play."
          },
          {
            "type": "subtitle",
            "content": "\nВызов реализации из интерфейса"
          },
          {
            "type": "text",
            "content": "Иногда может быть необходимо использовать функцию из интерфейса с реализацией по умолчанию, но при этом добавить к ней еще какой-то функционал. В этом случае нет смысла дублировать в классе реализацию по умолчанию. И мы можем обратиться к реализации из интерфейса с помощью конструкции super<интерфейс>.имя_функции:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val player = MediaPlayer()\n    player.play() \n}\ninterface  VideoPlayable {\n    fun play() = println(\"Play video\")\n}\ninterface AudioPlayable {\n    fun play() = println(\"Play audio\")\n}\n \nclass MediaPlayer : VideoPlayable, AudioPlayable {\n    // Функцию play обязательно надо переопределить\n    override fun play() {\n        println(\"Start playing\")\n        super<VideoPlayable>.play() // вызываем VideoPlayable.play()\n        super<AudioPlayable>.play() // вызываем AudioPlayable.play()\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае интерфейсы VideoPlayable и AudioPlayable определяют для функции play реализацию по умолчанию, а в классе MediaPlayer вызывается эта реализация."
          }
        ]
      },
      {
        "id": 10,
        "title": "Вложенные и внутренние классы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Вложенные и внутренние классы и интерфейсы"
          },
          {
            "type": "subtitle",
            "content": "\nВложенные классы"
          },
          {
            "type": "text",
            "content": "В Kotlin одни классы могут быть определены в других классах. Такие классы называют вложенными классами или nested classes. Они обычно выполняют какую-то вспомогательную роль, а определение их внутри класса или интерфейсапозволяет разместить их как можно ближе к тому месту, где они непосредственно используются."
          },
          {
            "type": "text",
            "content": "Например, в следующем случае определяется вложенный класс:"
          },
          {
            "type": "code",
            "content": "class Person{\n    class Account(val username: String, val password: String){\n \n        fun showDetails(){\n            println(\"UserName: $username  Password: $password\")\n        }\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае класс Account является вложенным, а класс Person - внешним."
          },
          {
            "type": "text",
            "content": "По умолчанию вложенные классы имеют модификатор видимости public, то есть они видимы в любой части программы. Но для обращения к вложенному классу надо использовать имя внешнего класса. Например, создание объекта вложенного класса:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val userAcc = Person.Account(\"qwerty\", \"123456\");\n    userAcc.showDetails()\n}"
          },
          {
            "type": "text",
            "content": "Если необходимо ограничить область применения вложенного класса только внешним классом, то следует определить вложенный класс с модификатором private:"
          },
          {
            "type": "code",
            "content": "class Person(username: String, password: String){\n \n    private val account: Account = Account(username, password)\n \n    private class Account(val username: String, val password: String)\n \n    fun showAccountDetails(){\n        println(\"UserName: ${account.username}  Password: $account.password\")\n    }\n}\nfun main() {\n \n    val tom = Person(\"qwerty\", \"123456\");\n    tom.showAccountDetails()\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВложенные интерфейсы"
          },
          {
            "type": "text",
            "content": "Классы также могут содержать вложенные интерфейсы. Кроме того, интерфейсы тоже могут содержать вложенные классы и интерфейсы:"
          },
          {
            "type": "code",
            "content": "interface SomeInterface {\n    class NestedClass\n    interface NestedInterface\n}\n \nclass SomeClass {\n    class NestedClass\n    interface NestedInterface\n}"
          },
          {
            "type": "subtitle",
            "content": "\nВнутренние (inner) классы"
          },
          {
            "type": "text",
            "content": "Стоит учитывать, что вложенный (nested) класс по умолчанию не имеет доступа к свойствам и функциям внешнего класса. Например, в следующем случае при попытке обратиться к свойству внешнего класса мы получим ошибку:"
          },
          {
            "type": "code",
            "content": "class BankAccount(private var sum: Int){\n     \n    fun display(){\n        println(\"sum = $sum\")\n    }\n \n    class Transaction{\n        fun pay(s: Int){\n            sum -= s\n            display()\n        }\n    }\n}"
          },
          {
            "type": "text",
            "content": "В данном случае у нас определен класс банковского счета BankAccount, который определяет свойство sum - сумма на счете и функцию display() для вывода информации о счете."
          },
          {
            "type": "text",
            "content": "Кроме того, в классе BankAccount определен вложенный класс Transaction, который представляет операцию по счету. В данном случае класс Transaction определяет функцию pay() для оплаты со счета. Однако в нем мы не можем обратиться в свойствам и функциям внешнего класса BankAccount."
          },
          {
            "type": "text",
            "content": "Чтобы вложенный класс мог иметь доступ к свойствам и функциям внешнего класса, необходимо определить вложенный класс с ключевым словом inner. Такой класс еще называют внутренним классом (inner class), чтобы отличать от обычных вложенных классов. Например:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val acc = BankAccount(3400);\n    acc.Transaction().pay(2500)\n}\nclass BankAccount(private var sum: Int){\n \n    fun display(){\n        println(\"sum = $sum\")\n    }\n \n    inner class Transaction{\n        fun pay(s: Int){\n            sum -= s\n            display()\n        }\n    }\n}"
          },
          {
            "type": "text",
            "content": "Теперь класс Transaction определен с ключевым словом inner, поэтому имеет полный доступ к свойствам и функциям внешнего класса BankAccount. Но теперь если мы хотим использовать объект подобного вложенного класса, то необходимо создать объект внешнего класса:"
          },
          {
            "type": "code",
            "content": "val acc = BankAccount(3400);\n    acc.Transaction().pay(2500)"
          },
          {
            "type": "subtitle",
            "content": "\nСовпадение имен"
          },
          {
            "type": "text",
            "content": "Но что если свойства и функции внутреннего класса называются также, как и свойства и функции внешнего класса? В этом случае внутренний класс может обратиться к свойствам и функциям внешнего через конструкцию this@название_класса.имя_свойства_или_функции:"
          },
          {
            "type": "code",
            "content": "class A{\n    private val n: Int = 1\n    inner class B{\n        private val n: Int = 1\n        fun action(){\n            println(n)          // n из класса B\n            println(this.n)     // n из класса B\n            println(this@B.n)   // n из класса B\n            println(this@A.n)   // n из класса A\n        }\n    }\n}"
          },
          {
            "type": "text",
            "content": "Например, перепишем случай выше с классами Account и Transaction следующим образом:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val acc = BankAccount(3400);\n    acc.Transaction(2400).pay()\n}\nclass BankAccount(private var sum: Int){\n \n    fun display(){\n        println(\"sum = $sum\")\n    }\n \n    inner class Transaction(private var sum: Int){\n        fun pay(){\n            this@BankAccount.sum -= this@Transaction.sum\n            display()\n        }\n    }\n}"
          }
        ]
      },
      {
        "id": 11,
        "title": "Data-классы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Data-классы"
          },
          {
            "type": "text",
            "content": "Иногда классы бывают необходимы только для хранения некоторых данных. В Kotlin такие классы называются data-классы. Они определяются с модификатором data:"
          },
          {
            "type": "code",
            "content": "data class Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "При компиляции такого класса компилятор автоматически добавляет в класс функции с определенной реализацией, которая учитывает свойства класса, которые определены в первичном конструкторе:"
          },
          {
            "type": "text",
            "content": "\t• equals(): сравнивает два объекта на равенство"
          },
          {
            "type": "text",
            "content": "\t• hashCode(): возвращает хеш-код объекта"
          },
          {
            "type": "text",
            "content": "\t• toString(): возвращает строковое представление объекта"
          },
          {
            "type": "text",
            "content": "\t• copy(): копирует данные объекта в другой объект"
          },
          {
            "type": "text",
            "content": "Например, возьмем функцию toString(), которая возвращает строковое представление объекта:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val alice: Person = Person(\"Alice\", 24)\n    println(alice.toString())\n}\n \nclass Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "Результатом программы будет следующий вывод:"
          },
          {
            "type": "code",
            "content": "Person@2a18f23c"
          },
          {
            "type": "text",
            "content": "По умолчанию строковое представление объекта нам практически ни о чем не говорит. Как правило, данная функция предназначена для вывода состояния объекта, но для этого ее надо переопределять. Однако теперь добавим модификатор data к определению класса:"
          },
          {
            "type": "code",
            "content": "data class Person(val name: String, val age: Int)"
          },
          {
            "type": "text",
            "content": "И результат будет отличаться:"
          },
          {
            "type": "code",
            "content": "Person(name=Alice, age=24)"
          },
          {
            "type": "text",
            "content": "То есть мы можем увидить, какие данные хранятся в объекте, какие они имеют значения. То же самое касается всех остальных функций. Таким образом, в случае с data-классами мы имеем готовую реализацию для этих функций. Их не надо вручную переопределять. Но вполне возможно нас может не устраивать эта реализация, тогда мы можем определить свою:"
          },
          {
            "type": "code",
            "content": "data class Person(val name: String, val age: Int){\n    override fun toString(): String {\n        return \"Name: $name  Age: $age\"\n    }\n}"
          },
          {
            "type": "text",
            "content": "В этом случае для функции toString() компилятор не будет определять реализацию."
          },
          {
            "type": "text",
            "content": "Другим показательным примером является копирование данных:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val alice: Person = Person(\"Alice\", 24)\n    val kate = alice.copy(name = \"Kate\")\n    println(alice.toString())   // Person(name=Alice, age=24)\n    println(kate.toString())    // Person(name=Kate, age=24)\n}\n \ndata class Person(var name: String, var age: Int)"
          },
          {
            "type": "text",
            "content": "Опять же компилятор генерирует функцию копирования по умолчанию, которую мы можем использовать. Если мы хотим, чтобы некоторые данные у объкта отличались, то мы их можем указать в функции copy в виде именованных арументов, как в случае со свойством name в примере выше."
          },
          {
            "type": "text",
            "content": "При этом чтобы класс определить как data-класс, он должен соответствовать ряду условий:"
          },
          {
            "type": "text",
            "content": "\t• Первичный конструктор должен иметь как минимум один параметр"
          },
          {
            "type": "text",
            "content": "\t• Все параметры первичного конструктора должны предваряться ключевыми словами val или var, то есть определять свойства.\n\t  Свойства, которые определяются вне первичного конструктора, не используются в функциях toString, equals и hashCode"
          },
          {
            "type": "text",
            "content": "\t• Класс не должен определяться с модификаторами open, abstract, sealed или inner."
          },
          {
            "type": "text",
            "content": "Также стоит отметить, что несмотря на то, что мы можем определять свойства в первичном конструкторе и через val, и через var, например:"
          },
          {
            "type": "code",
            "content": "data class Person(var name: String, var age: Int)"
          },
          {
            "type": "text",
            "content": "Но вообще в ряде ситуаций рекомендуется определять свойства через val, то есть делать их неизменяемыми, поскольку на их основании вычисляет хеш-код, который используется в качестве ключа объекта в такой коллекции как HashMap."
          },
          {
            "type": "subtitle",
            "content": "\nДекомпозиция data-классов"
          },
          {
            "type": "text",
            "content": "Kotlin предоставляет для data-классов возможность декомпозиции на переменные:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val alice: Person = Person(\"Alice\", 24)\n \n    val (username, userage) = alice\n    println(\"Name: $username  Age: $userage\") // Name: Alice  Age: 24\n}\n \ndata class Person(var name: String, var age: Int)"
          }
        ]
      },
      {
        "id": 12,
        "title": "Enum классы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Enum классы (перечисления)"
          },
          {
            "type": "text",
            "content": "Enums или перечисления представляют тип данных, который позволяет определить набор логически связанных констант. Для определения перечисления применяются ключевые слова enum class. Например, определим перечисление:"
          },
          {
            "type": "code",
            "content": "enum class Day{\n    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n}"
          },
          {
            "type": "text",
            "content": "Данное перечисление Day представляет день недели. Внутри перечисления определяются константы. В данном случае это названия семи дней недели. Константы определяются через запятую. Каждая константа фактически представляет объект данного перечисления."
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val day: Day = Day.FRIDAY\n    println(day)            // FRIDAY\n    println(Day.MONDAY)     // MONDAY\n}"
          },
          {
            "type": "text",
            "content": "Классы перечислений как и обычные классы также могут иметь конструктор. Кроме того, для констант перечисления также может вызываться конструктор для их инициализации."
          },
          {
            "type": "code",
            "content": "enum class Day(val value: Int){\n    MONDAY(1), TUESDAY(2), WEDNESDAY(3),\n    THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(100500)\n}\n \nfun main() {\n \n    val day: Day = Day.FRIDAY\n    println(day.value)        // 5\n    println(Day.MONDAY.value) // 1\n}"
          },
          {
            "type": "text",
            "content": "В примере выше у класса перечисления через конструктор определяется свойство value. Соответственно при определении констант перечисления необходимо каждую из этих констант инициализировать, передав значение для свойства value."
          },
          {
            "type": "text",
            "content": "При этом перечисления - это не просто список значений. Они могут определять также свойства и функции. Но если класс перечисления содержит свойства или функции, то константы должны быть отделены точкой с запятой."
          },
          {
            "type": "code",
            "content": "enum class Day(val value: Int){\n    MONDAY(1), TUESDAY(2), WEDNESDAY(3),\n    THURSDAY(4), FRIDAY(5), SATURDAY(6),\n    SUNDAY(7);\n    fun getDuration(day: Day): Int{\n        return value - day.value;\n    }\n}\n \nfun main() {\n \n    val day1: Day = Day.FRIDAY\n    val day2: Day = Day.MONDAY\n    println(day1.getDuration(day2))        // 4\n}"
          },
          {
            "type": "text",
            "content": "В данном случае в перечислении определена функция getDuration(), которая вычисляет разницу в днях между двумя днями недели."
          },
          {
            "type": "subtitle",
            "content": "\nВстроенные свойства и вспомогательные методы"
          },
          {
            "type": "text",
            "content": "Все перечисления обладают двумя встроенными свойствами:"
          },
          {
            "type": "text",
            "content": "\t• name: возвращает название константы в виде строки"
          },
          {
            "type": "text",
            "content": "\t• ordinal: возвращает порядковый номер константы"
          },
          {
            "type": "code",
            "content": "enum class Day(val value: Int){\n    MONDAY(1), TUESDAY(2), WEDNESDAY(3),\n    THURSDAY(4), FRIDAY(5), SATURDAY(6),\n    SUNDAY(7)\n}\n \nfun main() {\n \n    val day1: Day = Day.FRIDAY\n    println(day1.name)        // FRIDAY\n    println(day1.ordinal)     // 4\n}"
          },
          {
            "type": "text",
            "content": "Кроме того, в Kotlin нам доступны вспомогательные функции:"
          },
          {
            "type": "text",
            "content": "\t• valueOf(value: String): возвращает объект перечисления по названию константы"
          },
          {
            "type": "text",
            "content": "\t• values(): возвращает массив констант текущего перечисления"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    for(day in Day.values())\n        println(day)\n \n    println(Day.valueOf(\"FRIDAY\"))\n}"
          },
          {
            "type": "subtitle",
            "content": "\nАнонимные классы и реализация интерфейсов"
          },
          {
            "type": "text",
            "content": "Константы перечисления могут определять анонимные классы, которые могут иметь собственные методы и свойства или реализовать абстрактные методы класса перечисления:"
          },
          {
            "type": "code",
            "content": "enum class DayTime{\n    DAY{\n        override val startHour = 6\n        override val endHour = 21\n        override fun printName(){\n            println(\"День\")\n        }\n    },\n    NIGHT{\n        override val startHour = 22\n        override val endHour = 5\n        override fun printName(){\n            println(\"Ночь\")\n        }\n    };\n    abstract fun printName()\n    abstract val startHour: Int\n    abstract val endHour: Int\n}\n \nfun main() {\n \n    DayTime.DAY.printName()     // День\n    DayTime.NIGHT.printName()   // Ночь\n \n    println(\"Day from ${DayTime.DAY.startHour} to ${DayTime.DAY.endHour}\")\n \n}"
          },
          {
            "type": "text",
            "content": "В данном случае класс перечисления DayTime определяет абстрактный метод printName() и две переменных - startHour (начальный час) и endHour (конечный час). А константы определяют анонимные классы, которые реализуют эти свойства и функцию."
          },
          {
            "type": "text",
            "content": "Также, классы перечислений могут применять интерфейсы. Для этого для каждой константы определяется анонимный класс, который содержат все реализуемые свойства и функции:"
          },
          {
            "type": "code",
            "content": "interface Printable{\n    fun printName()\n}\nenum class DayTime: Printable{\n    DAY{\n        override fun printName(){\n            println(\"День\")\n        }\n    },\n    NIGHT{\n        override fun printName(){\n            println(\"Ночь\")\n        }\n    }\n}\n \nfun main() {\n \n    DayTime.DAY.printName()     // День\n    DayTime.NIGHT.printName()   // Ночь\n}"
          },
          {
            "type": "subtitle",
            "content": "\nХранение состояния"
          },
          {
            "type": "text",
            "content": "Нередко перечисления применяются для хранения состояния в программе. И в зависимоси от этого состояния мы можем направить действие программы по определенному пути. Например, определим перечисление, которое представляет арифметические операции, и функцию, которая в зависимости от переданной операции выполняет то или иное действие:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    println(operate(5, 6, Operation.ADD))         // 11\n    println(operate(5, 6, Operation.SUBTRACT))   // -1\n    println(operate(5, 6, Operation.MULTIPLY))   // 30\n}\nenum class Operation{\n \n    ADD, SUBTRACT, MULTIPLY\n}\nfun operate(n1: Int, n2: Int, op: Operation): Int{\n \n    when(op){\n        Operation.ADD -> return n1 + n2\n        Operation.SUBTRACT -> return n1 - n2\n        Operation.MULTIPLY -> return n1 *n2\n    }\n}"
          },
          {
            "type": "text",
            "content": "Функция operate() принимает два числа - операнды операции и тип операции в виде перечисления Operation. И в зависимоси от значения перечисления возвращает либо сумму, либо разность, либо произведение двух чисел."
          }
        ]
      },
      {
        "id": 13,
        "title": "Делегирование",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Делегирование"
          },
          {
            "type": "text",
            "content": "Делегирование представляет паттерн объектно-ориентированного программирования, который позволяет одному объекту делегировать/перенаправить все запросы другому объекту. В определенной степени делегирование может выступать альтернативой наследованию. И преимуществом Kotlin в данном случае состоит в том, что Kotlin нативно поддерживает данный паттерн, предоставляя необходимый инструментарий."
          },
          {
            "type": "text",
            "content": "Формальный синтаксис:"
          },
          {
            "type": "code",
            "content": "interface Base {\n    fun someFun()\n}\n \nclass BaseImpl() : Base {\n    override fun someFun() { }\n}\n \nclass Derived(someBase: Base) : Base by someBase"
          },
          {
            "type": "text",
            "content": "Есть некоторый интерфейс - Base, который определяет некоторый функционал. Есть его реализация в виде класса BaseImpl."
          },
          {
            "type": "text",
            "content": "И есть еще один класс - Derived, который также применяет интерфейс Base. Причем после указания применяемого интерфейса идет ключевое слово by, а после него - объект, которому будут делегироваться вызовы."
          },
          {
            "type": "code",
            "content": "class Derived(someBase: Base) : Base by someBase"
          },
          {
            "type": "text",
            "content": "То есть в данной схеме класс Derived будет делегировать вызовы объекту someBase, который представляет интерфейс Base и передается через первичный конструктор. При этом Derived может не реализовать интерфейс Base или реализовать неполностью - какие-то отдельные свойства и функции."
          },
          {
            "type": "text",
            "content": "Например, рассмотрим следующие классы:"
          },
          {
            "type": "code",
            "content": "interface Messenger{\n    fun send(message: String)\n}\nclass InstantMessenger(val programName: String) : Messenger{\n \n    override fun send(message: String){\n        println(\"Message `$message` has been sent\")\n    }\n}\nclass SmartPhone(val name: String, m: Messenger): Messenger by  m"
          },
          {
            "type": "text",
            "content": "Здесь определен интерфейс Messenger, который представляет условно программу для отправки сообщений. Для условной отправки сообщений определена функция send()."
          },
          {
            "type": "text",
            "content": "Также есть класс InstantMessenger - программа мгновенных сообщений или проще говоря мессенджер, который применяет интерфейс Messenger, реализуя его функцию send()"
          },
          {
            "type": "text",
            "content": "Далее определен класс   SmartPhone, который представляет смартфон и также применяет интерфейс Messenger, но не реализует его. Вместо этого он принимает через первичный конструктор объект Messenger и делегирует ему обращение к функции send()."
          },
          {
            "type": "text",
            "content": "Применим классы:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val telegram = InstantMessenger(\"Telegram\")\n    val pixel = SmartPhone(\"Pixel 5\", telegram)\n    pixel.send(\"Hello Kotlin\")\n    pixel.send(\"Learn Kotlin on Metanit.com\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь создан объект pixel, который представляет класс SmartPhone. Поскольку SmartPhone применяет интерфейс Messenger, то мы можем вызвать у объекта pixel функцию send() для отправки условного сообщения. Однако сам класс SmartPhone НЕ реализует функцию send - само выполнение этой функции делегируется объекту telegram, который в реальности выполняет отправку сообщения. Соответственно при выполнении программы мы увидим следующий консольный вывод:"
          },
          {
            "type": "code",
            "content": "Message `Hello Kotlin` has been sent\nMessage `Learn Kotlin on Metanit.com` has been sent"
          },
          {
            "type": "subtitle",
            "content": "\nМножественное делегирование"
          },
          {
            "type": "text",
            "content": "Подобным образом один  объект может делегировать выполнение различных функций разным объектам. Например:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val telegram = InstantMessenger(\"Telegram\")\n    val photoCamera = PhotoCamera()\n    val pixel = SmartPhone(\"Pixel 5\", telegram, photoCamera)\n    pixel.send(\"Hello Kotlin\")\n    pixel.takePhoto()\n}\n \ninterface Messenger{\n    fun send(message: String)\n}\nclass InstantMessenger(val programName: String) : Messenger{\n    override fun send(message: String) = println(\"Send message: `$message`\")\n}\ninterface PhotoDevice{\n    fun takePhoto()\n}\nclass PhotoCamera: PhotoDevice{\n    override fun takePhoto() = println(\"Take a photo\")\n}\nclass SmartPhone(val name: String, m: Messenger, p: PhotoDevice)\n    : Messenger by  m, PhotoDevice by p"
          },
          {
            "type": "text",
            "content": "Здесь класс SmartPhone также реализует интерфейс PhotoDevice, который предоставляет функцию takePhoto() для съемки фото. Но выполнение этой функции он делегирует параметру p, который представляет интерфейс PhotoDevice и в роли которого выступает объект PhotoCamera."
          },
          {
            "type": "subtitle",
            "content": "\nПереопределение функций"
          },
          {
            "type": "text",
            "content": "Класс может переопределять часть функций интерфейса, в этом случае выполнение этих функций не делегируется. Например:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val telegram = InstantMessenger(\"Telegram\")\n    val pixel = SmartPhone(\"Pixel 5\", telegram)\n    pixel.sendTextMessage()\n    pixel.sendVideoMessage()\n}\n \ninterface Messenger{\n    fun sendTextMessage()\n    fun sendVideoMessage()\n}\nclass InstantMessenger(val programName: String) : Messenger{\n    override fun sendTextMessage() = println(\"Send text message\")\n    override fun sendVideoMessage() = println(\"Send video message\")\n}\nclass SmartPhone(val name: String, m: Messenger) : Messenger by  m{\n    override fun sendTextMessage() = println(\"Send sms\")\n}"
          },
          {
            "type": "text",
            "content": "В данном случае класс SmartPhone реализует функцию sendTextMessage(), поэтому ее выполнение не делегируется. Консольный вывод программы:"
          },
          {
            "type": "code",
            "content": "Send sms\nSend video message"
          },
          {
            "type": "subtitle",
            "content": "\nДелегирование свойств"
          },
          {
            "type": "text",
            "content": "По аналогии с функциями объект может делегировать обращение к свойствам:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val telegram = InstantMessenger(\"Telegram\")\n    val pixel = SmartPhone(\"Pixel 5\", telegram)\n    println(pixel.programName)  // Telegram\n}\ninterface Messenger{\n    val programName: String\n}\nclass InstantMessenger(override val programName: String) : Messenger\nclass SmartPhone(val name: String, m: Messenger) : Messenger by  m"
          },
          {
            "type": "text",
            "content": "Здесь при интерфейс Messenger определяет свойство programName - название программы отправки. Класс SmartPhone не реализует это свойство, поэтому обращение к этому свойству делегируется объекту m."
          },
          {
            "type": "text",
            "content": "Если бы класс SmartPhone сам реализовал это свойство, то делегирования бы не было:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val telegram = InstantMessenger(\"Telegram\")\n    val pixel = SmartPhone(\"Pixel 5\", telegram)\n    println(pixel.programName)  // Default Messenger\n}\ninterface Messenger{\n    val programName: String\n}\nclass InstantMessenger(override val programName: String) : Messenger\nclass SmartPhone(val name: String, m: Messenger) : Messenger by  m{\n    override val programName = \"Default Messenger\"\n}"
          }
        ]
      },
      {
        "id": 14,
        "title": "Анонимные классы и объекты",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Анонимные классы и объекты"
          },
          {
            "type": "text",
            "content": "Иногда возникает необходимость создать объект некоторого класса, который больше нигде в программе не используется. То есть класс необходим только для создания только одного объекта. В этом случае мы, конечно, можем, как и обычно, определить класс и затем создать объект этого класса. Но Kotlin для таких ситуаций предоставлять возможность определить объект анонимного класса."
          },
          {
            "type": "text",
            "content": "Анонимные классы не используют ключевое слово class для определения. Они не имеют имени, но как и обычные классы могут наследовать другие классы или  применять интерфейсы. Объекты анонимных классов называют анонимыми объктами."
          },
          {
            "type": "text",
            "content": "Для определения анонимного объекта применяется ключевое слово object:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val person = object {\n        val name = \"Tom\"\n        var age = 37\n        fun sayHello(){\n            println(\"Hi, my name is $name\")\n        }\n    }\n    println(\"Name: ${person.name}  Age: ${person.age}\")\n    person.sayHello()\n}"
          },
          {
            "type": "text",
            "content": "После ключевого слова object идет блок кода в фигурных скобках, в которые помещается определение объекта. Ссылка на этот объект присваивается переменной person. Как и в обычном классе, анонимный объект может содержать свойства, функции. И далее по имени переменной person мы можем обращаться к свойствам и функциям этого объекта."
          },
          {
            "type": "text",
            "content": "Если объект определяется вне функции как глобальный объект, то имя объекта указывается после слова object:"
          },
          {
            "type": "code",
            "content": "object person{\n    val name = \"Tom\"\n    var age = 37\n    fun sayHello(){\n        println(\"Hi, my name is $name\")\n    }\n}\n \nfun main() {\n    println(\"Name: ${person.name}  Age: ${person.age}\")\n    person.sayHello()\n}"
          },
          {
            "type": "subtitle",
            "content": "\nНаследование анонимных объектом"
          },
          {
            "type": "text",
            "content": "При наследовании после слова object через двоеточия указывается имя наследуемого класса или его первичный конструктор:"
          },
          {
            "type": "code",
            "content": "fun main() {\n \n    val tom = object : Person(\"Tom\"){\n \n        val company = \"JetBrains\"\n        override fun sayHello(){\n            println(\"Hi, my name is $name. I work in $company\")\n        }\n    }\n \n    tom.sayHello()  // Hi, my name is Tom. I work in JetBrains\n}\nopen class Person(val name: String){\n    open fun sayHello(){\n        println(\"Hi, my name is $name\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "Здесь класс анонимного объекта наследует класс Person и переопределяет его функцию sayHello()."
          },
          {
            "type": "subtitle",
            "content": "\nАнонимный объект как аргумент функции"
          },
          {
            "type": "text",
            "content": "Анонимный объект может передаваться в качестве аргумента в вызов функции:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    hello(\n        object : Person(\"Sam\"){\n            val company = \"JetBrains\"\n            override fun sayHello(){\n                println(\"Hi, my name is $name. I work in $company\")\n            }\n    })\n}\nfun hello(person: Person){\n    person.sayHello()\n}\nopen class Person(val name: String){\n    open fun sayHello() = println(\"Hi, my name is $name\")\n}"
          },
          {
            "type": "text",
            "content": "Здесь поскольку класс анонимного объекта наследуется от класса Person, мы можем передавать этот анонимный объект параметру функции, который имеет тип Person."
          },
          {
            "type": "subtitle",
            "content": "\nАнонимный объект как результат функции"
          },
          {
            "type": "text",
            "content": "Функция может возвращать анонимный объект:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val tom = createPerson(\"Tom\", \"JetBrains\")\n    tom.sayHello()\n}\nprivate fun createPerson(_name: String, _company: String) = object{\n    val name = _name\n    val company = _company\n    fun sayHello() = println(\"Hi, my name is $name. I work in $company\")\n}"
          },
          {
            "type": "text",
            "content": "Однако тут есть нюансы. Чтобы мы могли обращаться к свойствам и функциям анонимного объекта, функция, которая возвращает этот объект, должна быть приватной, как в примере выше."
          },
          {
            "type": "text",
            "content": "Если функция имеет модификатор public или private inline, то в этом случае свойства и функции анонимного класса (за исключением унаследованных) недоступны:"
          },
          {
            "type": "code",
            "content": "fun main() {\n    val tom = createPerson(\"Tom\", \"JetBrains\")\n    println(tom.name)   // норм - свойство name унаследовано от Person\n    println(tom.company)    // ! Ошибка - свойство недоступно\n}\nprivate inline fun createPerson(_name: String, _comp: String) = object: Person(_name){\n    val company = _comp\n}\n \nopen class Person(val name: String)"
          },
          {
            "type": "text",
            "content": "В данном случае функция createPerson() имеет модификатор private inline, поэтому у анонимного объекта будут доступны только унаследованные свойства и функции от класса Person, но собственные свойства и функции будут не доступны."
          }
        ]
      },
      {
        "id": 15,
        "title": "Companion-объекты",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Companion-объекты"
          },
          {
            "type": "text",
            "content": "Класс в языке Kotlin может содержать так называемые companion-объекты. Сompanion-объект определяется внутри некоторого класса и позволяет определить свойства и методы, которые будут общими для всех объектов этого класса. В ряде языков программирования есть похожая концепция - статические поля/свойства и методы. То есть companion-объектыопределяют свойства и методы классав целом, а не объекта."
          },
          {
            "type": "text",
            "content": "Общий синтаксис опредедения companion-объекта:"
          },
          {
            "type": "code",
            "content": "class ClassName{\n \n    // свойства и методы класса\n    companion object {\n \n        // свойства и методы companion-объекта\n    }\n \n}"
          },
          {
            "type": "text",
            "content": "Например, нам надо подсчитать, сколько было создано объектов определенного класса. Для этого определим следующую программу:"
          },
          {
            "type": "code",
            "content": "class Person(val name: String){\n   \n    init{\n        counter++\n    }\n    companion object {\n        var counter = 0\n    }\n}\nfun main (){\n    println(Person.counter) // 0\n    Person(\"Tom\")\n    println(Person.counter) // 1\n    Person(\"Bob\")\n    Person(\"Sam\")\n    println(Person.counter) // 3\n \n}"
          },
          {
            "type": "text",
            "content": "Здесь в классе Person определен следующий companion-объект:"
          },
          {
            "type": "code",
            "content": "companion object {\n    var counter = 0\n}"
          },
          {
            "type": "text",
            "content": "Для его определения применяется ключевое слово companion. Внутри этого объекта определено свойство counter - счетчик, который по умолчанию равен 0."
          },
          {
            "type": "text",
            "content": "В теле класса Person мы можем напрямую обращаться к свойствам и методам companion-объекта. В данном случае при создании объекта в инициализаторе мы увеличиваем этот счетчик на 1:"
          },
          {
            "type": "code",
            "content": "init{\n    counter++\n}"
          },
          {
            "type": "text",
            "content": "То есть при создании каждого объекта счетчик увеличивается на единицу. И поскольку companion-объекты определяют свойства и методы, общие для всех объектов класса, то этот счетчик будет один общий для всех объектов класса Person. И для обращения к нему вне класса применяется имя класса, а не объекта:"
          },
          {
            "type": "code",
            "content": "println(Person.counter) // 0\nPerson(\"Tom\")\nprintln(Person.counter) // 1\nPerson(\"Bob\")\nPerson(\"Sam\")\nprintln(Person.counter) // 3"
          },
          {
            "type": "text",
            "content": "И здесь мы видим, что изначально счетчик равен 0. После создания одного объекта он равен 1, а после создания еще двух объектов - 3."
          },
          {
            "type": "text",
            "content": "Если же мы попробуем обратиться к переменной counter через имя объекта, то мы получим ошибку:"
          },
          {
            "type": "code",
            "content": "val tom = Person(\"Tom\")\nprintln(tom.counter) // Ошибка"
          },
          {
            "type": "text",
            "content": "Теоретически мы, конечно, можем определить и для объектов одноименное свойство. Например:"
          },
          {
            "type": "code",
            "content": "class Person(val name: String){\n   \n    var counter = 22\n    init{\n        Person.counter++\n    }\n    companion object {\n        var counter = 0\n    }\n}\nfun main (){\n    println(Person.counter) // 0\n    val tom = Person(\"Tom\")\n    println(tom.counter) // 22\n    Person(\"Bob\")\n    Person(\"Sam\")\n    println(Person.counter) // 3\n}"
          },
          {
            "type": "text",
            "content": "Здесь в классе Person определено свойство counter, которое по умолчанию равно 22:"
          },
          {
            "type": "code",
            "content": "var counter = 22"
          },
          {
            "type": "text",
            "content": "И для обращения к этому свойству мы можем использовать имя объекта:"
          },
          {
            "type": "code",
            "content": "val tom = Person(\"Tom\")\nprintln(tom.counter) // 22"
          },
          {
            "type": "text",
            "content": "В этом случае, если внутри класса мы хотим обратиться не к этому свойству, а к свойству companion-объекта, то мы также должны указывать имя класса:"
          },
          {
            "type": "code",
            "content": "init{\n    Person.counter++\n}"
          },
          {
            "type": "subtitle",
            "content": "\nСтатические методы"
          },
          {
            "type": "text",
            "content": "Companion-объекты также могут определять методы, общие для всего класса и для обращения к которым также используется имя класса, а не объекта. Например, в примерах выше у нас определенно есть проблема с целостностью данных, так как мы можем из внешнего кода присвоить счетчику любое значение:"
          },
          {
            "type": "code",
            "content": "Person.counter = -100500"
          },
          {
            "type": "text",
            "content": "Естественно это нежелательная ситуация. Поэтому опосредуем доступ к свойству counter:"
          },
          {
            "type": "code",
            "content": "class Person(val name: String){\n   \n    init{\n        counter++\n    }\n    companion object {\n        private var counter = 0\n        fun printCounter() = println(counter)\n    }\n}\nfun main (){\n    Person.printCounter() // 0\n    Person(\"Tom\")\n    Person.printCounter() // 22\n    Person(\"Bob\")\n    Person(\"Sam\")\n    Person.printCounter() // 3\n}"
          },
          {
            "type": "text",
            "content": "Итак, переменная counter теперь приватная, она недоступна вне своего класса. Однако внутри класса мы по прежнему можем к ней обращаться."
          },
          {
            "type": "text",
            "content": "А для того, чтобы внешний код также мог получить ее значение, в companion-объекте определен метод printCounter:"
          },
          {
            "type": "code",
            "content": "fun printCounter() = println(counter)"
          },
          {
            "type": "text",
            "content": "Для доступа к этому методу применяется имя класса:"
          },
          {
            "type": "code",
            "content": "Person.printCounter()"
          },
          {
            "type": "subtitle",
            "content": "\nНаследование"
          },
          {
            "type": "text",
            "content": "Методы и свойства companion-объекта не наследуются, поэтому для обращения к ним применяется имя базового класса, в котором определен companion-объект:"
          },
          {
            "type": "code",
            "content": "open class Person(val name: String){\n   \n    init{\n        counter++\n    }\n    companion object {\n        private var counter = 0\n        fun printCounter() = println(counter)\n    }\n}\nclass Employee(name:String):Person(name)\n \nfun main (){\n    Person.printCounter() // 0\n    Employee(\"Tom\")\n    Person.printCounter() // 1\n    // Employee.printCounter() ! Так нельзя - error: unresolved reference: printCounter\n}"
          }
        ]
      }
    ]
  },
  {
    "chapterId": 5,
    "chapterTitle": "Прочее",
    "articles": [
      {
        "id": 1,
        "title": "Основной синтаксис (повторение)",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Основной синтаксис"
          },
          {
            "type": "text",
            "content": "Это подборка базового синтаксиса с примерами."
          },
          {
            "type": "subtitle",
            "content": "Точка входа в программу"
          },
          {
            "type": "text",
            "content": "В Kotlin точкой входа в программу является функция main."
          },
          {
            "type": "code",
            "content": "fun main(){\n    println(\"Hello world!\")\n}"
          },
          {
            "type": "text",
            "content": "Другая форма main может принимать масссив строк String."
          },
          {
            "type": "subtitle",
            "content": "Вывод в стандартный поток"
          },
          {
            "type": "text",
            "content": "Функция print() выводит свой аргумент в стандартный поток вывода."
          },
          {
            "type": "code",
            "content": "print(\"Hello \")\nprint(\"world!\")"
          },
          {
            "type": "text",
            "content": "Функция println() выводит свой аргумент и добавляет перевод строки, так что следующее, что вы выведите, появится на следующей строке."
          },
          {
            "type": "code",
            "content": "println(\"Hello world!\")\nprintln(1234)"
          },
          {
            "type": "subtitle",
            "content": "Функции"
          },
          {
            "type": "text",
            "content": "В Kotlin функция объявляется с помощью ключевого слова fun. В скобках,после названия указывается список параметров. После скобок, через двоеточие можно указать тип возвращаемого значения. И далее в фигурных скобках идет тело функции."
          },
          {
            "type": "code",
            "content": "fun имя_функции (параметры) : возвращаемый_тип{\n    выполняемые инструкции\n}"
          },
          {
            "type": "text",
            "content": "В качестве тела функции может выступать выражение. Тогда тип возвращаемого значения определяется автоматически."
          },
          {
            "type": "code",
            "content": "fun sum(a: Int, b: Int) = a + b"
          },
          {
            "type": "text",
            "content": "Параметры необязательны, так же как и тип возвращаемого значения, по умолчанию он будет Unit (void в Java)."
          },
          {
            "type": "code",
            "content": "// определение функции hello\nfun hello(){\n    println(\"Hello\")\n\nfun main() {\n \n    hello() // вызов функции hello\n    hello() // вызов функции hello\n    hello() // вызов функции hello\n}}"
          },
          {
            "type": "subtitle",
            "content": "Переменные"
          },
          {
            "type": "text",
            "content": "Неизменяемые (только для чтения) локальные переменные определяются с помощью ключевого слова val. Присвоить им значение можно только один раз."
          },
          {
            "type": "code",
            "content": "val a: Int = 1   // Инициализация при объявлении\nval b = 1        // Тип `Int` определен автоматически\nval c: Int       // Указывать тип обязательно, если переменная не инициализирована сразу\nc = 1            // Последующее присвоение"
          },
          {
            "type": "text",
            "content": "Изменяемые переменные объявляются с помощью ключевого слова var."
          },
          {
            "type": "code",
            "content": "var x = 5 // Тип `Int` определен автоматически\nx += 1"
          },
          {
            "type": "text",
            "content": "Вы можете объявлять глобальные переменные."
          },
          {
            "type": "code",
            "content": "val PI = 3.14\nvar x = 0\n\nfun incrementX() { \n    x += 1 \n}"
          },
          {
            "type": "subtitle",
            "content": "Комментарии"
          },
          {
            "type": "text",
            "content": "Также, как любой другой популярный современный язык, Kotlin поддерживает однострочные и многострочные (блочные) комментарии."
          },
          {
            "type": "code",
            "content": "// Это однострочный комментарий\n\n/* Это блочный комментарий\n   из нескольких строк. */"
          },
          {
            "type": "text",
            "content": "Блочные комментарии в Kotlin могут быть вложенными."
          },
          {
            "type": "code",
            "content": "/* Этот комментарий начинается здесь\n/* содержит вложенный комментарий */\nи заканчивается здесь. */"
          },
          {
            "type": "subtitle",
            "content": "Строковые шаблоны"
          },
          {
            "type": "code",
            "content": "fun main(args: Array<String>) {\n  if (args.size == 0) return\n\n  print(\"Первый аргумент: ${args[0]}\")\n}"
          },
          {
            "type": "code",
            "content": "var a = 1\n// просто имя переменной в шаблоне:\nval s1 = \"a равно $a\" \n\na = 2\n// произвольное выражение в шаблоне:\nval s2 = \"${s1.replace(\"равно\", \"было равно\")}, но теперь равно $a\"\n\n/*\n  Результат работы программы:\n  a было равно 1, но теперь равно 2\n*/"
          },
          {
            "type": "subtitle",
            "content": "Условные выражения"
          },
          {
            "type": "code",
            "content": "fun maxOf(a: Int, b: Int): Int {\n    if (a > b) {\n        return a\n    } else {\n        return b\n    }\n}"
          },
          {
            "type": "text",
            "content": "В Kotlin if может быть использован как выражение (т. е. if … else возвращает значение):"
          },
          {
            "type": "code",
            "content": "fun maxOf(a: Int, b: Int) = if (a > b) a else b"
          },
          {
            "type": "subtitle",
            "content": "Цикл for"
          },
          {
            "type": "text",
            "content": "Цикл for обеспечивает перебор всех значений, поставляемых итератором. Например, выведем все квадраты чисел от 1 до 9, используя цикл for: "
          },
          {
            "type": "code",
            "content": "for(n in 1..9){\n    print(\"${n * n} \")\n}"
          },
          {
            "type": "code",
            "content": "1  4  9  16  25  36  49  64  81 "
          },
          {
            "type": "text",
            "content": "Циклы могут быть вложенными. Например, выведем таблицу умножения:"
          },
          {
            "type": "code",
            "content": "for(i in 1..9){\n    for(j in 1..9){\n        print(\"${i * j}  \")\n    }\n    println()\n}"
          },
          {
            "type": "text",
            "content": "С помощью цикла for можно перебирать элементы коллекции: "
          },
          {
            "type": "code",
            "content": "val items = listOf(\"яблоко\", \"банан\", \"киви\")\nfor (item in items) {\n    println(item)\n}"
          },
          {
            "type": "text",
            "content": "или"
          },
          {
            "type": "code",
            "content": "val items = listOf(\"яблоко\", \"банан\", \"киви\")\nfor (index in items.indices) {\n    println(\"${index} фрукт - это ${items[index]}\")\n}"
          },
          {
            "type": "subtitle",
            "content": "Цикл while"
          },
          {
            "type": "code",
            "content": "val items = listOf(\"яблоко\", \"банан\", \"киви\")\nvar index = 0\nwhile (index < items.size) {\n    println(\"${index} фрукт - это ${items[index]}\")\n    index++\n}"
          },
          {
            "type": "subtitle",
            "content": "Выражение when"
          },
          {
            "type": "code",
            "content": "fun describe(obj: Any): String =\n    when (obj) {\n        1          -> \"Один\"\n        \"Hello\"    -> \"Приветствие\"\n        is Long    -> \"Long\"\n        !is String -> \"Не строка\"\n        else       -> \"Unknown\"\n    }"
          },
          {
            "type": "subtitle",
            "content": "Интервалы"
          },
          {
            "type": "text",
            "content": "Проверка на вхождение числа в интервал с помощью оператора in."
          },
          {
            "type": "code",
            "content": "val x = 10\nval y = 9\nif (x in 1..y+1) {\n    println(\"принадлежит диапазону\")\n}"
          },
          {
            "type": "text",
            "content": "Проверка значения на выход за пределы интервала."
          },
          {
            "type": "code",
            "content": "val list = listOf(\"a\", \"b\", \"c\")\n\nif (-1 !in 0..list.lastIndex) {\n    println(\"-1 не принадлежит диапазону\")\n}\nif (list.size !in list.indices) {\n    println(\"размер списка также выходит за допустимый диапазон индексов списка\")\n}"
          },
          {
            "type": "text",
            "content": "Перебор значений в заданном интервале."
          },
          {
            "type": "code",
            "content": "for (x in 1..5) {\n    print(x)\n}"
          },
          {
            "type": "text",
            "content": "Или по арифметической прогрессии."
          },
          {
            "type": "code",
            "content": "for (x in 1..10 step 2) {\n    print(x)\n}\nprintln()\nfor (x in 9 downTo 0 step 3) {\n    print(x)\n}"
          },
          {
            "type": "subtitle",
            "content": "Коллекции"
          },
          {
            "type": "text",
            "content": "Итерация по коллекции."
          },
          {
            "type": "code",
            "content": "for (item in items) {\n    println(item)\n}"
          },
          {
            "type": "text",
            "content": "Проверка, содержит ли коллекция данный объект, с помощью оператора in."
          },
          {
            "type": "code",
            "content": "val items = setOf(\"яблоко\", \"банан\", \"киви\")\nwhen {\n    \"апельсин\" in items -> println(\"сочно\")\n    \"яблоко\" in items -> println(\"яблоко тоже подойдет\")\n}"
          },
          {
            "type": "text",
            "content": "Использование лямбда-выражения для фильтрации и модификации коллекции."
          },
          {
            "type": "code",
            "content": "fun main() {\n    val fruits = listOf(\"банан\", \"авокадо\", \"апельсин\", \"яблоко\", \"киви\")\n    fruits\n        .filter { it.startsWith(\"а\") }\n        .sortedBy { it }\n        .map { it.uppercase() }\n        .forEach { println(it) }\n}"
          },
          {
            "type": "code",
            "content": "АВОКАДО\nАПЕЛЬСИН"
          },
          {
            "type": "subtitle",
            "content": "Создание классов и экземпляров"
          },
          {
            "type": "text",
            "content": "Для создания класса используйте ключевое слово class."
          },
          {
            "type": "code",
            "content": "class Matrix"
          },
          {
            "type": "text",
            "content": "Свойства класса могут быть перечислены при его объявлении или в его теле."
          },
          {
            "type": "code",
            "content": "class Rectangle(var height: Double, var length: Double) {\n    var perimeter = (height + length) * 2 \n}"
          },
          {
            "type": "text",
            "content": "Конструктор по умолчанию с параметрами, перечисленными при объявлении класса, доступен автоматически."
          },
          {
            "type": "code",
            "content": "val rectangle = Rectangle(5.0, 2.0)\nprintln(\"Периметр равен ${rectangle.perimeter}\")"
          },
          {
            "type": "text",
            "content": "Чтобы объявить наследование между классами используйте двоеточие (:). По умолчанию классы являются финальными, поэтому, чтобы сделать класс наследуемым, используйте open."
          },
          {
            "type": "code",
            "content": "open class Shape\n\nclass Rectangle(var height: Double, var length: Double): Shape() {\n    var perimeter = (height + length) * 2 \n}"
          },
          {
            "type": "subtitle",
            "content": "Nullable-значения и проверка на null"
          },
          {
            "type": "text",
            "content": "Ссылка должна быть явно объявлена как nullable (символ ? в конце имени), когда она может принимать значение null."
          },
          {
            "type": "text",
            "content": "Возвращает null, если str не содержит числа."
          },
          {
            "type": "code",
            "content": "fun readInt(str: String): Int? {\n  // ...\n}"
          },
          {
            "type": "text",
            "content": "Использование функции, возвращающей null:"
          },
          {
            "type": "code",
            "content": "fun printProduct(arg1: String, arg2: String) {\n    val x = parseInt(arg1)\n    val y = parseInt(arg2)\n    \n    // Использование `x * y` приведет к ошибке, потому что они могут содержать null\n    if (x != null && y != null) {\n        // x и y автоматически приведены к не-nullable после проверки на null\n    print(x * y)\n    }\n    else {\n        println(\"'$arg1' или '$arg2' не число\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "или"
          },
          {
            "type": "code",
            "content": "// ...\nif (x == null) {\n    print(\"Неверный формат числа arg1: '$arg1'\")\n    return\n}\nif (y == null) {\n    print(\"Неверный формат числа arg2: '$arg2'\")\n    return\n}\n\n// x и y автоматически приведены к не-nullable после проверки на null\n  print(x * y)"
          },
          {
            "type": "subtitle",
            "content": "Проверка типа и автоматическое приведение типов"
          },
          {
            "type": "text",
            "content": "Оператор is проверяет, является ли выражение экземпляром заданного типа. Если неизменяемая локальная переменная или свойство уже проверены на определенный тип, то в дальнейшем нет необходимости явно приводить к этому типу:"
          },
          {
            "type": "code",
            "content": "fun getStringLength(obj: Any): Int? {\n    if (obj is String) {\n        // в этом блоке `obj` автоматически преобразован в `String`\n        return obj.length\n    }\n\n    // `obj` имеет тип `Any` вне блока проверки типа\n    return null\n}"
          },
          {
            "type": "text",
            "content": "или"
          },
          {
            "type": "code",
            "content": "fun getStringLength(obj: Any): Int? {\n    if (obj !is String) return null\n\n    // в этом блоке `obj` автоматически преобразован в `String`\n    return obj.length\n}"
          },
          {
            "type": "text",
            "content": "или даже"
          },
          {
            "type": "code",
            "content": "fun getStringLength(obj: Any): Int? {\n    // `obj` автоматически преобразован в `String` справа от оператора `&&`\n    if (obj is String && obj.length > 0) {\n        return obj.length\n    }\n\n    return null\n}"
          }
        ]
      },
      {
        "id": 2,
        "title": "Идиомы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Идиомы"
          },
          {
            "type": "text",
            "content": "Набор различных часто используемых идиом в языке Kotlin."
          },
          {
            "type": "subtitle",
            "content": "Значения по умолчанию для параметров функций"
          },
          {
            "type": "code",
            "content": "fun foo(a: Int = 0, b: String = \"\") { ... }"
          },
          {
            "type": "subtitle",
            "content": "Фильтрация списка"
          },
          {
            "type": "code",
            "content": "val positives = list.filter { x -> x > 0 }"
          },
          {
            "type": "text",
            "content": "Или короче: "
          },
          {
            "type": "code",
            "content": "val positives = list.filter { it > 0 }"
          },
          {
            "type": "subtitle",
            "content": "Проверка наличия элемента в коллекции"
          },
          {
            "type": "code",
            "content": "if (\"john@example.com\" in emailsList) { ... }\n\nif (\"jane@example.com\" !in emailsList) { ... }"
          },
          {
            "type": "subtitle",
            "content": "Форматирование строк"
          },
          {
            "type": "code",
            "content": "println(\"Name $name\")"
          },
          {
            "type": "subtitle",
            "content": "Проверка объекта на принадлежность к определённому классу "
          },
          {
            "type": "code",
            "content": "when (x) {\n    is Foo -> ...\n    is Bar -> ...\n    else   -> ...\n}"
          },
          {
            "type": "subtitle",
            "content": "Read-only список"
          },
          {
            "type": "code",
            "content": "val list = listOf(\"a\", \"b\", \"c\")"
          },
          {
            "type": "subtitle",
            "content": "Read-only ассоциативный список (map)"
          },
          {
            "type": "code",
            "content": "val map = mapOf(\"a\" to 1, \"b\" to 2, \"c\" to 3)"
          },
          {
            "type": "subtitle",
            "content": "Обращение к ассоциативному списку"
          },
          {
            "type": "code",
            "content": "println(map[\"key\"])\nmap[\"key\"] = value"
          },
          {
            "type": "subtitle",
            "content": "Итерация по ассоциативному списку или списку пар"
          },
          {
            "type": "code",
            "content": "for ((key, value) in map) {\n    println(\"$key -> $value\")\n}"
          },
          {
            "type": "subtitle",
            "content": "Итерация по диапазону"
          },
          {
            "type": "code",
            "content": "for (i in 1..100) { ... }  // закрытый диапазон: включает 100\nfor (i in 1 until 100) { ... } // полуоткрытый диапазон: не включает 100\nfor (x in 2..10 step 2) { ... }\nfor (x in 10 downTo 1) { ... }\n(1..10).forEach { ... }"
          },
          {
          "type": "subtitle",
          "content": "Ленивые свойства"
          },
          {
            "type": "code",
            "content": "val p: String by lazy { ... }"
          },
          {
            "type": "text",
            "content": "Это означает, что значение p будет вычислено только при первом обращении к нему."
          },
          {
            "type": "subtitle",
            "content": "Функции-расширения"
          },
          {
            "type": "code",
            "content": "fun String.spaceToCamelCase() { ... }\n\n\"Convert this to camelcase\".spaceToCamelCase()"
          },
          {
            "type": "subtitle",
            "content": "Создание синглтона (единичный объект)"
          },
          {
            "type": "code",
            "content": "object Resource {\n    val name = \"Name\"\n}"
          },
          {
            "type": "subtitle",
            "content": "Создание экземпляра абстрактного класса"
          },
          {
            "type": "code",
            "content": "abstract class MyAbstractClass {\n    abstract fun doSomething()\n    abstract fun sleep()\n}\n\nfun main() {\n    val myObject = object : MyAbstractClass() {\n        override fun doSomething() {\n            // ...\n        }\n\n        override fun sleep() { // ...\n        }\n    }\n    myObject.doSomething()\n}"
          },
          {
            "type": "subtitle",
            "content": "Сокращение для \"Если не null\""
          },
          {
            "type": "code",
            "content": "val files = File(\"Test\").listFiles()\n\nprintln(files?.size) // размер выводится, если размер файлов не равен null"
          },
          {
            "type": "subtitle",
            "content": "Сокращение для \"Если не null, иначе\"  (Оператор Элвиса)"
          },
          {
            "type": "code",
            "content": "val files = File(\"Test\").listFiles()\n\nprintln(files?.size ?: \"empty\") // если файл равен null, выводится \"empty\"\n"
          },
          {
            "type": "subtitle",
            "content": "Выброс исключения при равенстве null"
          },
          {
            "type": "code",
            "content": "val values = ...\nval email = values[\"email\"] ?: throw IllegalStateException(\"Email is missing!\")"
          },
          {
            "type": "subtitle",
            "content": "Получение первого элемента, возможно, пустой коллекции"
          },
          {
            "type": "code",
            "content": "val emails = ... // может быть пустой\nval mainEmail = emails.firstOrNull() ?: \"\""
          },
          {
            "type": "subtitle",
            "content": "Выполнение при неравенстве nul"
          },
          {
            "type": "code",
            "content": "val value = ...\n\nvalue?.let {\n    ... // этот блок выполняется, если value не равен null\n}"
          },
          {
            "type": "subtitle",
            "content": "Return с оператором when"
          },
          {
            "type": "code",
            "content": "fun transform(color: String): Int {\n    return when (color) {\n        \"Red\" -> 0\n        \"Green\" -> 1\n        \"Blue\" -> 2\n        else -> throw IllegalArgumentException(\"Invalid color param value\")\n    }\n}"
          },
          {
            "type": "subtitle",
            "content": "Выражение try-catch"
          },
          {
            "type": "code",
            "content": "fun test() {\n    val result = try {\n        count()\n    } catch (e: ArithmeticException) {\n        throw IllegalStateException(e)\n    }\n\n    // Working with result\n}"
          },
          {
            "type": "subtitle",
            "content": "Выражение if"
          },
          {
            "type": "code",
            "content": "val y = if (x == 1) {\n    \"one\"\n} else if (x == 2) {\n    \"two\"\n} else {\n    \"other\"\n}"
          },
          {
            "type": "subtitle",
            "content": "Функции, состоящие из одного выражения"
          },
          {
            "type": "code",
            "content": "fun theAnswer() = 42"
          },
          {
            "type": "text",
            "content": "Что равносильно этому:"
          },
          {
            "type": "code",
            "content": "fun theAnswer(): Int {\n    return 42\n}"
          },
          {
            "type": "text",
            "content": "Для сокращения кода их можно эффективно совмещать с другими идиомами. Например, с when:"
          },
          {
            "type": "code",
            "content": "fun transform(color: String): Int = when (color) {\n    \"Red\" -> 0\n    \"Green\" -> 1\n    \"Blue\" -> 2\n    else -> throw IllegalArgumentException(\"Invalid color param value\")\n}"
          },
          {
            "type": "subtitle",
            "content": "Вызов нескольких методов объекта (with)"
          },
          {
            "type": "code",
            "content": "class Turtle {\n    fun penDown()\n    fun penUp()\n    fun turn(degrees: Double)\n    fun forward(pixels: Double)\n}\n\nval myTurtle = Turtle()\nwith(myTurtle) { // нарисует квадрат размером 100 pix\n    penDown()\n    for (i in 1..4) {\n        forward(100.0)\n        turn(90.0)\n    }\n    penUp()\n}"
          },
          {
            "type": "subtitle",
            "content": "Nullable Boolean"
          },
          {
            "type": "code",
            "content": "val b: Boolean? = ...\nif (b == true) {\n    ...\n} else {\n    // `b` is false or null\n}"
          },
          {
            "type": "subtitle",
            "content": "Обмен значений переменных"
          },
          {
            "type": "code",
            "content": "var a = 1\nvar b = 2\na = b.also { b = a }"
          },
          {
            "type": "subtitle",
            "content": "Обозначение кода как незаконченного (TODO)"
          },
          {
            "type": "text",
            "content": "В стандартной библиотеке Kotlin есть функция TODO(), которая всегда выдает ошибку NotImplementedError. Её возвращаемый тип - Nothing, поэтому её можно использовать независимо от ожидаемого типа."
          },
          {
            "type": "code",
            "content": "fun calcTaxes(): BigDecimal = TODO(\"Waiting for feedback from accounting\")"
          }
        ]
      },
      {
        "id": 3,
        "title": "Стилистика кода",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Соглашение о стилистике кода"
          },
          {
            "type": "text",
            "content": "Общеизвестные и простые в использовании соглашения о стилистике кода жизненно важны для любого языка программирования. Здесь предоставлены рекомендации по стилю кода и его организации для проектов, использующих Kotlin."
          },
          {
            "type": "subtitle",
            "content": "Настройка стиля в IDE"
          },
          {
            "type": "text",
            "content": "Две самые популярные IDE для Kotlin - IntelliJ IDEA и Android Studio обеспечивают широкую поддержку стиля кода."
          },
          {
            "type": "url",
            "content": "https://www.jetbrains.com/idea/"
          },
          {
            "type": "url",
            "content": "http://developer.android.com/studio"
          },
          {
            "type": "text",
            "content": "Вы можете настроить их для автоматического форматирования вашего кода в соответствии с заданным стилем."
          },
          {
            "type": "subtitle",
            "content": "\nСтруктура каталогов"
          },
          {
            "type": "text",
            "content": "В проектах, в которых используется только Kotlin, рекомендуемая структура каталогов соответствует структуре пакетов, при этом общий корневой пакет опущен. Например, если весь код в проекте находится в пакете org.example.kotlin и его подпакетах, файлы с пакетом org.example.kotlin должны размещаться непосредственно в корневом каталоге, а файлы в org.example.kotlin.network.socket должны находиться в подкаталоге корневого каталога network/socket."
          },
          {
            "type": "subtitle",
            "content": "Имена файлов"
          },
          {
            "type": "text",
            "content": "Если Kotlin файл содержит один класс (возможно со связанными объявлениями верхнего уровня), то его имя должно совпадать с именем этого класса с добавлением расширения .kt. Если файл содержит несколько классов или только объявления верхнего уровня, выберите имя, описывающее содержимое файла, и назовите файл соответствующим образом. Используйте UpperCamelCase (так же известный как Pascal case), начиная с заглавной буквы, например, ProcessDeclarations.kt.\n\nИмена файлов должны описывать, что в них делает код. Поэтому при наименовании файла вам следует избегать слов, не несущих смысла."
          },
          {
            "type": "subtitle",
            "content": "Организация файла"
          },
          {
            "type": "text",
            "content": "Размещение нескольких объявлений (классов, функций верхнего уровня или свойств) в одном исходном файле Kotlin рекомендуется до тех пор, пока эти объявления тесно связаны друг с другом семантически, а размер файла остается разумным (не более нескольких сотен строк).\n\nВ частности, при определении функций-расширения для класса, которые актуальны для всех клиентов этого класса, поместите их в один файл с самим классом. При определении функций-расширения, которые имеют смысл только для конкретного клиента, поместите их рядом с кодом этого клиента. Избегайте создания файлов только для хранения всех расширений какого-либо класса."
          },
          {
            "type": "subtitle",
            "content": "Схема классов"
          },
          {
            "type": "text",
            "content": "Содержимое класса должно располагаться в следующем порядке:\n\n\t1. Объявления свойств и блоки инициализации\n\t2. Дополнительные конструкторы\n\t3. Объявления методов\n\t4. Вспомогательный объект\n\nНе сортируйте объявления методов по алфавиту или по видимости и не отделяйте обычные методы от методов-расширения. Вместо этого соберите связанный код вместе, чтобы тот, кто читает класс сверху вниз, мог следовать логике происходящего. Выберите порядок (либо сначала материал более высокого уровня, либо наоборот) и придерживайтесь его.\n\nПоместите вложенные классы рядом с кодом, который их использует. Если эти классы предназначены для внешнего использования и на них нет ссылок внутри класса, поместите их в конце, после сопутствующего объекта."
          },
          {
            "type": "subtitle",
            "content": "Правила наименований"
          },
          {
            "type": "text",
            "content": "Правила наименования пакетов и классов в Kotlin довольно просты:\n\n\t• Имена пакетов всегда написаны в нижнем регистре и не содержат нижних подчеркиваний. Использование имен, состоящих из нескольких слов, обычно не рекомендуется, но, если вы не можете их не использовать, либо просто объедините их вместе, либо используйте при этом lowerCamelCase (org.example.myProject).\n\t• Имена классов и объектов начинаются с заглавной буквы и используют UpperCamelCase."
          },
          {
            "type": "code",
            "content": "open class DeclarationProcessor { /*...*/ }\n\nobject EmptyDeclarationProcessor : DeclarationProcessor() { /*...*/ }"
          },
          {
            "type": "subtitle",
            "content": "Имена функций"
          },
          {
            "type": "text",
            "content": "Имена функций, свойств и локальных переменных начинаются со строчной буквы и используют lowerCamelCase без нижнего подчеркивания."
          },
          {
            "type": "code",
            "content": "fun processDeclarations() { /*...*/ }\nvar declarationCount = 1"
          },
          {
            "type": "subtitle",
            "content": "Имена тестовых методов"
          },
          {
            "type": "text",
            "content": "В тестах (и только в тестах) вы можете использовать имена методов с пробелами, заключенными в обратный апостроф. Обратите внимание, что такие имена методов в настоящее время не поддерживаются средой Android. Подчеркивания в именах методов также разрешены в тестовом коде."
          },
          {
            "type": "code",
            "content": "class MyTestCase {\n     @Test fun `ensure everything works`() { /*...*/ }\n     \n     @Test fun ensureEverythingWorks_onAndroid() { /*...*/ }\n}"
          },
          {
            "type": "subtitle",
            "content": "Имена свойств"
          },
          {
            "type": "text",
            "content": "Имена констант (свойства, помеченные const, свойства верхнего уровня или объект val без функции get) должны использовать имена, разделенные подчеркиванием и написанные в верхнем регистре (SCREAMING_SNAKE_CASE)."
          },
          {
            "type": "code",
            "content": "const val MAX_COUNT = 8\nval USER_NAME_FIELD = \"UserName\""
          },
          {
            "type": "text",
            "content": "Имена свойств верхнего уровня или объектов, которые содержат объекты с поведением или изменяемыми данными, должны использовать имена lowerCamelCase."
          },
          {
            "type": "code",
            "content": "val mutableCollection: MutableSet<String> = HashSet()"
          },
          {
            "type": "subtitle",
            "content": "Имена для вспомогательных свойств"
          },
          {
            "type": "text",
            "content": "Если класс имеет два свойства, которые концептуально одинаковы, но одно из них является частью общедоступного API, а другое - деталью реализации, используйте символ нижнего подчеркивания в начале имени частного свойства:"
          },
          {
            "type": "code",
            "content": "class C {\n    private val _elementList = mutableListOf<Element>()\n    \n    val elementList: List<Element>\n         get() = _elementList\n}"
          },
          {
            "type": "subtitle",
            "content": "Выбирайте хорошие имена"
          },
          {
            "type": "text",
            "content": "Имя класса обычно представляет собой существительное или словосочетание, объясняющее, что это за класс: List, PersonReader.\n\nИмя метода обычно представляет собой глагол или фразу с глаголом, объясняющую, что делает этот метод: close, readPersons. Имя также должно указывать, изменяет ли метод объект или возвращает новый. Так, sort сортирует коллекцию, а sorted возвращает отсортированную копию коллекции.\n\nИмена должны прояснять, какова цель того или иного элемента, поэтому лучше избегать использования бессмысленных слов (Manager, Wrapper) в именах.\n\nПри использовании аббревиатуры в качестве части имени объявления, пишите её в верхнем регистре, если она состоит из двух букв (IOStream); если аббревиатура длиннее, заглавной следует оставить только первую букву (XmlFormatter, HttpInputStream)."
          },
          {
            "type": "subtitle",
            "content": "Форматирование\n"
          },
          {
            "type": "subtitle",
            "content": "Отступы"
          },
          {
            "type": "text",
            "content": "Используйте четыре пробела для отступа. Не используйте табуляцию.\n\nОткрывающую фигурную скобку поместите в конец строки, где начинается конструкция, а закрывающую скобку на отдельной строке, выровненной по горизонтали с открывающей конструкцией."
          },
          {
            "type": "code",
            "content": "if (elements != null) {\n    for (element in elements) {\n        // ...\n    }\n}"
          },
          {
            "type": "subtitle",
            "content": "Пробелы"
          },
          {
            "type": "text",
            "content": "\t• Используйте пробелы вокруг двоичных операторов (a + b). Исключение: не ставьте пробелы вокруг оператора “диапазон до” (0..i).\n\n\t• Не ставьте пробелы вокруг унарных операторов (a++).\n\n\t• Ставьте пробелы между ключевыми словами (if, when, for, and while) и соответствующей открывающей скобкой.\n\n\t• Не ставьте пробел перед открывающей скобкой в объявлении основного конструктора, объявлении метода или вызове метода."
          },
          {
            "type": "code",
            "content": "class A(val x: Int)\n\nfun foo(x: Int) { ... }\n\nfun bar() {\n    foo(1)\n}"
          },
          {
            "type": "text",
            "content": "\t•Никогда не ставьте пробел после (, [ или перед ], ).\n\n\t• Никогда не ставьте пробелы вокруг . или ?.\n\n\t• Ставьте пробел после //\n\n\t• Не ставьте пробелы вокруг угловых скобок, используемых для указания параметров типа\n\n\t• Не ставьте пробел вокруг ::\n\n\t• Не ставьте пробел перед вопросительным знаком ?, который используется для обозначения типа, допускающего обнуление: String?."
          },
          {
            "type": "text",
            "content": "Основное правило: избегайте любого горизонтального выравнивания. Переименование идентификатора в имя с другой длиной не должно влиять на форматирование."
          },
          {
            "type": "subtitle",
            "content": "Заголовки классов"
          },
          {
            "type": "text",
            "content": "Классы с небольшим количеством параметрами конструктора можно писать на одной строчке."
          },
          {
            "type": "code",
            "content": "class Person(id: Int, name: String)"
          },
          {
            "type": "text",
            "content": "Классы с более длинными сигнатурами должны быть отформатированы так, чтобы каждый параметр находится в отдельной строке с отступом. Кроме того, закрывающая скобка должна быть в новой строке. Наследование, вызов конструктора суперкласса или список реализованных интерфейсов должны располагаться в той же строке, что и скобка."
          },
          {
            "type": "code",
            "content": "class Person(\n    id: Int, \n    name: String,\n    surname: String\n) : Human(id, name) {\n    // ...\n}"
          },
          {
            "type": "subtitle",
            "content": "Порядок модификаторов"
          },
          {
            "type": "text",
            "content": "Если объявление содержит несколько модификаторов, всегда располагайте их в следующем порядке."
          },
          {
            "type": "code",
            "content": "public / protected / private / internal\nexpect / actual\nfinal / open / abstract / sealed / const\nexternal\noverride\nlateinit\ntailrec\nvararg\nsuspend\ninner\nenum / annotation / fun // модификатор в `fun interface` \ncompanion\ninline / value\ninfix\noperator\ndata"
          },
          {
            "type": "subtitle",
            "content": "Аннотации"
          },
          {
            "type": "text",
            "content": "Если сигнатура функции не помещается в одной строке, используйте следующий синтаксис."
          },
          {
            "type": "code",
            "content": "fun longMethodName(\n    argument: ArgumentType = defaultValue,\n    argument2: AnotherArgumentType,\n): ReturnType {\n    // body\n}"
          },
          {
            "type": "text",
            "content": "Используйте обычный отступ (четыре пробела) для параметров функции. Это помогает обеспечить согласованность с параметрами конструктора.\n\nДля функции, состоящей из одного выражения, предпочтительно использовать выражение в качестве тела функции."
          },
          {
            "type": "code",
            "content": "fun foo(): Int {     // плохо\n    return 1 \n}\n\nfun foo() = 1        // хорошо"
          },
          {
            "type": "subtitle",
            "content": "Свойства"
          },
          {
            "type": "text",
            "content": "Для очень простых свойств, доступных только для чтения, используйте форматирование в одну строку."
          },
          {
            "type": "code",
            "content": "val isEmpty: Boolean get() = size == 0"
          },
          {
            "type": "text",
            "content": "Для более сложных свойств всегда помещайте ключевые слова get и set в отдельные строки."
          },
          {
            "type": "subtitle",
            "content": "Операторы управления потоком"
          },
          {
            "type": "text",
            "content": "Если условие операторов if или when многострочное, всегда используйте фигурные скобки вокруг тела оператора. Делайте отступ в каждой последующей строке условия в четыре пробела. Поместите закрывающую скобку условия вместе с открывающей фигурной скобкой в отдельной строке."
          },
          {
            "type": "code",
            "content": "if (!component.isSyncing &&\n    !hasAnyKotlinRuntimeInScope(module)\n) {\n    return createKotlinNotConfiguredPanel(module)\n}"
          },
          {
            "type": "text",
            "content": "Это поможет выровнять тела условия и инструкции.\n\nПоместите ключевые слова else, catch, finally, а также ключевое слово while цикла do-while, на ту же строку, что и предыдущая фигурная скобка."
          },
          {
            "type": "code",
            "content": "if (condition) {\n    // body\n} else {\n    // else part\n}\n\ntry {\n    // body\n} finally {\n    // cleanup\n}"
          },
          {
            "type": "text",
            "content": "Если ветвь оператора when состоит более чем из одной строки, рассмотрите возможность отделения её от остальных ветвей пустой строкой."
          },
          {
            "type": "code",
            "content": "private fun parsePropertyValue(propName: String, token: Token) {\n    when (token) {\n        is Token.ValueToken ->\n            callback.visitValue(propName, token.value)\n\n        Token.LBRACE -> { // ...\n        }\n    }\n}"
          },
          {
            "type": "text",
            "content": "Поместите короткие ветви на ту же линию, что и условие, без скобок."
          },
          {
            "type": "code",
            "content": "when (foo) {\n    true -> bar() // хорошо\n    false -> { baz() } // плохо\n}"
          },
          {
            "type": "subtitle",
            "content": "Вызовы методов"
          },
          {
            "type": "text",
            "content": "В длинных списках аргументов после открывающей скобки переходите на следующую строку. Отступы аргументов в четыре пробела. Сгруппируйте несколько тесно связанных аргументов в одной строке."
          },
          {
            "type": "code",
            "content": "drawSquare(\n    x = 10, y = 10,\n    width = 100, height = 100,\n    fill = true\n)"
          },
          {
            "type": "subtitle",
            "content": "Группировка цепочки вызовов"
          },
          {
            "type": "text",
            "content": "При группировке цепочки вызовов, расположите символ . или оператор ?. на следующей строке с обычным отступом."
          },
          {
            "type": "code",
            "content": "val anchor = owner\n    ?.firstChild!!\n    .siblings(forward = true)\n    .dropWhile { it is PsiComment || it is PsiWhiteSpace }"
          },
          {
            "type": "subtitle",
            "content": "Лямбда-выражения"
          },
          {
            "type": "text",
            "content": "В лямбда-выражениях фигурные скобки и стрелка, которая отделяет параметры от тела, отделяются пробелами. Если вызов включает только одну лямбду, желательно передавать её за пределами скобок."
          },
          {
            "type": "code",
            "content": "list.filter { it > 10 }"
          },
          {
            "type": "text",
            "content": "При объявлении имен параметров в многострочной лямбде поместите имена в первую строку, за которой следует стрелка и новая строка."
          },
          {
            "type": "code",
            "content": "appendCommaSeparated(properties) { prop ->\n    val propertyValue = prop.get(obj)  // ...\n}"
          },
          {
            "type": "text",
            "content": "Если список параметров слишком длинный, чтобы поместиться в строку, поместите стрелку в отдельную строку:"
          },
          {
            "type": "code",
            "content": "foo {\n   context: Context,\n   environment: Env\n   ->\n   context.configureEnv(environment)\n}"
          },
          {
            "type": "subtitle",
            "content": "Документация комментариями"
          },
          {
            "type": "code",
            "content": "/**\n * Это документационный комментарий\n * на нескольких строках.\n */"
          },
          {
            "type": "code",
            "content": "/** Это короткий документационный комментарий. */"
          },
          {
            "type": "text",
            "content": "Следует избегать использования тегов @param и @return. Вместо этого включите описание параметров и возвращаемых значений непосредственно в документационный комментарий и добавьте ссылки на параметры везде, где они упоминаются. Используйте @param и @return только тогда, когда требуется длинное описание, которое не вписывается в основной текст."
          },
          {
            "type": "code",
            "content": "// Не делайте так:\n\n/**\n * Возвращает абсолютное значение заданного числа.\n * @param number Число, для которого будет найдено абсолютное значение.\n * @return Абсолютное значение.\n */\nfun abs(number: Int): Int { /*...*/ }\n\n// Делайте так:\n\n/**\n * Возвращает абсолютное значение заданного [number].\n */\nfun abs(number: Int): Int { /*...*/ }"
          },
          {
            "type": "subtitle",
            "content": "Идиоматическое использование функций языка\n\nНеизменность"
          },
          {
            "type": "text",
            "content": "Предпочтительнее использовать неизменяемые данные. Всегда объявляйте локальные переменные и свойства как val, а не var, если они не будут изменены после инициализации.\n\nВсегда используйте неизменяемые коллекции интерфейсов (Collection, List, Set, Map) для объявления коллекций, которые не изменяются. При использовании фабричных функций для создания экземпляров коллекции всегда используйте функции, возвращающие неизменяемые типы коллекций, когда это возможно."
          },
          {
            "type": "code",
            "content": "// Плохо: использование изменяемого типа коллекции для значения, которое не будет изменено\nfun validateValue(actualValue: String, allowedValues: HashSet<String>) { ... }\n\n// Хорошо: использование неизменяемого типа коллекции\nfun validateValue(actualValue: String, allowedValues: Set<String>) { ... }\n\n// Плохо: arrayListOf() возвращает ArrayList<T>, который является изменяемым типом\nval allowedValues = arrayListOf(\"a\", \"b\", \"c\")\n\n// Хорошо: listOf() возвращает List<T>\nval allowedValues = listOf(\"a\", \"b\", \"c\")"
          },
          {
            "type": "subtitle",
            "content": "Условные операторы"
          },
          {
            "type": "text",
            "content": "Предпочтительно использовать эту форму выражения try, if и when."
          },
          {
            "type": "code",
            "content": "return if (x) foo() else bar()"
          },
          {
            "type": "code",
            "content": "return when(x) {\n    0 -> \"zero\"\n    else -> \"nonzero\"\n}"
          },
          {
            "type": "text",
            "content": "Выше изложенное предпочтительнее, чем:"
          },
          {
            "type": "code",
            "content": "if (x)\n    return foo()\nelse\n    return bar()"
          },
          {
            "type": "code",
            "content": "when(x) {\n    0 -> return \"zero\"\n    else -> return \"nonzero\"\n} "
          },
          {
            "type": "subtitle",
            "content": "if vs when"
          },
          {
            "type": "text",
            "content": "Для двоичных условий лучше использовать if. Например, используйте этот синтаксис с if:"
          },
          {
            "type": "code",
            "content": "if (x == null) ... else ..."
          },
          {
            "type": "text",
            "content": "вместо этого с when:"
          },
          {
            "type": "code",
            "content": "when (x) {\n    null -> // ...\n    else -> // ...\n}"
          },
          {
            "type": "text",
            "content": "Предпочтительнее использовать when, если есть три и более варианта."
          },
          {
            "type": "subtitle",
            "content": "Циклы"
          },
          {
            "type": "text",
            "content": "Предпочтительнее использовать функции более высокого порядка (filter, map и т.д.), чем циклы. Исключение: forEach (лучше использовать обычный цикл for) используется только, если получатель forEach не может быть обнулен или forEach используется как часть более длинной цепочки вызовов.\n\nДелая выбор между циклом и сложным выражением, использующим несколько функций более высокого порядка, учитывайте стоимость операций, выполняемых в каждом конкретном случае, исходите из соображений производительности."
          },
          {
            "type": "subtitle",
            "content": "Циклы для диапазонов"
          },
          {
            "type": "text",
            "content": "Используйте функцию until, чтобы использовать открытый диапазон в цикле."
          },
          {
            "type": "code",
            "content": "for (i in 0..n - 1) { /*...*/ }  // плохо\nfor (i in 0 until n) { /*...*/ }  // хорошо"
          },
          {
            "type": "subtitle",
            "content": "Строки"
          },
          {
            "type": "text",
            "content": "Используйте строковые шаблоны вместо конкатенации строк.\n\nЧтобы сохранить отступ в многострочных строках, используйте trimIndent, когда результирующая строка не требует внутреннего отступа, и trimMargin, когда требуется внутренний отступ."
          },
          {
            "type": "code",
            "content": "println(\"\"\"\n    Not\n    trimmed\n    text\n    \"\"\"\n       )\n\nprintln(\"\"\"\n    Trimmed\n    text\n    \"\"\".trimIndent()\n       )\n\nprintln()\n\nval a = \"\"\"Trimmed to margin text:\n          |if(a > 1) {\n          |    return a\n          |}\"\"\".trimMargin()\n\nprintln(a)"
          }
        ]
      }
    ]
  }
]