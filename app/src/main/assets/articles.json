[
  {
    "chapterId": 1,
    "chapterTitle": "Введение в язык Kotlin",
    "articles": [
      {
        "id": 1,
        "title": "Основной синтаксис",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Основной синтаксис"
          },
          {
            "type": "text",
            "content": "Это подборка базового синтаксиса с примерами. Далее в приложении "
          },
          {
            "type": "subtitle",
            "content": "Точка входа в программу"
          },
          {
            "type": "text",
            "content": "В Kotlin точкой входа в программу является функция main."
          },
          {
            "type": "code",
            "content": "fun main(){\n    println(\"Hello world!\")\n}"
          },
          {
            "type": "text",
            "content": "Другая форма main может принимать масссив строк String."
          },
          {
            "type": "subtitle",
            "content": "Вывод в стандартный поток"
          },
          {
            "type": "text",
            "content": "Функция print() выводит свой аргумент в стандартный поток вывода."
          },
          {
            "type": "code",
            "content": "print(\"Hello \")\nprint(\"world!\")"
          },
          {
            "type": "text",
            "content": "Функция println() выводит свой аргумент и добавляет перевод строки, так что следующее, что вы выведите, появится на следующей строке."
          },
          {
            "type": "code",
            "content": "println(\"Hello world!\")\nprintln(1234)"
          },
          {
            "type": "subtitle",
            "content": "Функции"
          },
          {
            "type": "text",
            "content": "В Kotlin функция объявляется с помощью ключевого слова fun. В скобках,после названия указывается список параметров. После скобок, через двоеточие можно указать тип возвращаемого значения. И далее в фигурных скобках идет тело функции."
          },
          {
            "type": "code",
            "content": "fun имя_функции (параметры) : возвращаемый_тип{\n    выполняемые инструкции\n}"
          },
          {
            "type": "text",
            "content": "В качестве тела функции может выступать выражение. Тогда тип возвращаемого значения определяется автоматически."
          },
          {
            "type": "code",
            "content": "fun sum(a: Int, b: Int) = a + b"
          },
          {
            "type": "text",
            "content": "Параметры необязательны, так же как и тип возвращаемого значения, по умолчанию он будет Unit (void в Java)."
          },
          {
            "type": "code",
            "content": "// определение функции hello\nfun hello(){\n    println(\"Hello\")\n\nfun main() {\n \n    hello() // вызов функции hello\n    hello() // вызов функции hello\n    hello() // вызов функции hello\n}}"
          },
          {
            "type": "subtitle",
            "content": "Переменные"
          },
          {
            "type": "text",
            "content": "Неизменяемые (только для чтения) локальные переменные определяются с помощью ключевого слова val. Присвоить им значение можно только один раз."
          },
          {
            "type": "code",
            "content": "val a: Int = 1   // Инициализация при объявлении\nval b = 1        // Тип `Int` определен автоматически\nval c: Int       // Указывать тип обязательно, если переменная не инициализирована сразу\nc = 1            // Последующее присвоение"
          },
          {
            "type": "text",
            "content": "Изменяемые переменные объявляются с помощью ключевого слова var."
          },
          {
            "type": "code",
            "content": "var x = 5 // Тип `Int` определен автоматически\nx += 1"
          },
          {
            "type": "text",
            "content": "Вы можете объявлять глобальные переменные."
          },
          {
            "type": "code",
            "content": "val PI = 3.14\nvar x = 0\n\nfun incrementX() { \n    x += 1 \n}"
          },
          {
            "type": "subtitle",
            "content": "Комментарии"
          },
          {
            "type": "text",
            "content": "Также, как любой другой популярный современный язык, Kotlin поддерживает однострочные и многострочные (блочные) комментарии."
          },
          {
            "type": "code",
            "content": "// Это однострочный комментарий\n\n/* Это блочный комментарий\n   из нескольких строк. */"
          },
          {
            "type": "text",
            "content": "Блочные комментарии в Kotlin могут быть вложенными."
          },
          {
            "type": "code",
            "content": "/* Этот комментарий начинается здесь\n/* содержит вложенный комментарий */\nи заканчивается здесь. */"
          },
          {
            "type": "subtitle",
            "content": "Строковые шаблоны"
          },
          {
            "type": "code",
            "content": "fun main(args: Array<String>) {\n  if (args.size == 0) return\n\n  print(\"Первый аргумент: ${args[0]}\")\n}"
          },
          {
            "type": "code",
            "content": "var a = 1\n// просто имя переменной в шаблоне:\nval s1 = \"a равно $a\" \n\na = 2\n// произвольное выражение в шаблоне:\nval s2 = \"${s1.replace(\"равно\", \"было равно\")}, но теперь равно $a\"\n\n/*\n  Результат работы программы:\n  a было равно 1, но теперь равно 2\n*/"
          },
          {
            "type": "subtitle",
            "content": "Условные выражения"
          },
          {
            "type": "code",
            "content": "fun maxOf(a: Int, b: Int): Int {\n    if (a > b) {\n        return a\n    } else {\n        return b\n    }\n}"
          },
          {
            "type": "text",
            "content": "В Kotlin if может быть использован как выражение (т. е. if … else возвращает значение):"
          },
          {
            "type": "code",
            "content": "fun maxOf(a: Int, b: Int) = if (a > b) a else b"
          },
          {
            "type": "subtitle",
            "content": "Цикл for"
          },
          {
            "type": "text",
            "content": "Цикл for обеспечивает перебор всех значений, поставляемых итератором. Например, выведем все квадраты чисел от 1 до 9, используя цикл for: "
          },
          {
            "type": "code",
            "content": "for(n in 1..9){\n    print(\"${n * n} \")\n}"
          },
          {
            "type": "code",
            "content": "1  4  9  16  25  36  49  64  81 "
          },
          {
            "type": "text",
            "content": "Циклы могут быть вложенными. Например, выведем таблицу умножения:"
          },
          {
            "type": "code",
            "content": "for(i in 1..9){\n    for(j in 1..9){\n        print(\"${i * j}  \")\n    }\n    println()\n}"
          },
          {
            "type": "text",
            "content": "С помощью цикла for можно перебирать элементы коллекции: "
          },
          {
            "type": "code",
            "content": "val items = listOf(\"яблоко\", \"банан\", \"киви\")\nfor (item in items) {\n    println(item)\n}"
          },
          {
            "type": "text",
            "content": "или"
          },
          {
            "type": "code",
            "content": "val items = listOf(\"яблоко\", \"банан\", \"киви\")\nfor (index in items.indices) {\n    println(\"${index} фрукт - это ${items[index]}\")\n}"
          },
          {
            "type": "subtitle",
            "content": "Цикл while"
          },
          {
            "type": "code",
            "content": "val items = listOf(\"яблоко\", \"банан\", \"киви\")\nvar index = 0\nwhile (index < items.size) {\n    println(\"${index} фрукт - это ${items[index]}\")\n    index++\n}"
          },
          {
            "type": "subtitle",
            "content": "Выражение when"
          },
          {
            "type": "code",
            "content": "fun describe(obj: Any): String =\n    when (obj) {\n        1          -> \"Один\"\n        \"Hello\"    -> \"Приветствие\"\n        is Long    -> \"Long\"\n        !is String -> \"Не строка\"\n        else       -> \"Unknown\"\n    }"
          },
          {
            "type": "subtitle",
            "content": "Интервалы"
          },
          {
            "type": "text",
            "content": "Проверка на вхождение числа в интервал с помощью оператора in."
          },
          {
            "type": "code",
            "content": "val x = 10\nval y = 9\nif (x in 1..y+1) {\n    println(\"принадлежит диапазону\")\n}"
          },
          {
            "type": "text",
            "content": "Проверка значения на выход за пределы интервала."
          },
          {
            "type": "code",
            "content": "val list = listOf(\"a\", \"b\", \"c\")\n\nif (-1 !in 0..list.lastIndex) {\n    println(\"-1 не принадлежит диапазону\")\n}\nif (list.size !in list.indices) {\n    println(\"размер списка также выходит за допустимый диапазон индексов списка\")\n}"
          },
          {
            "type": "text",
            "content": "Перебор значений в заданном интервале."
          },
          {
            "type": "code",
            "content": "for (x in 1..5) {\n    print(x)\n}"
          },
          {
            "type": "text",
            "content": "Или по арифметической прогрессии."
          },
          {
            "type": "code",
            "content": "for (x in 1..10 step 2) {\n    print(x)\n}\nprintln()\nfor (x in 9 downTo 0 step 3) {\n    print(x)\n}"
          },
          {
            "type": "subtitle",
            "content": "Коллекции"
          },
          {
            "type": "text",
            "content": "Итерация по коллекции."
          },
          {
            "type": "code",
            "content": "for (item in items) {\n    println(item)\n}"
          },
          {
            "type": "text",
            "content": "Проверка, содержит ли коллекция данный объект, с помощью оператора in."
          },
          {
            "type": "code",
            "content": "val items = setOf(\"яблоко\", \"банан\", \"киви\")\nwhen {\n    \"апельсин\" in items -> println(\"сочно\")\n    \"яблоко\" in items -> println(\"яблоко тоже подойдет\")\n}"
          },
          {
            "type": "text",
            "content": "Использование лямбда-выражения для фильтрации и модификации коллекции."
          },
          {
            "type": "code",
            "content": "fun main() {\n    val fruits = listOf(\"банан\", \"авокадо\", \"апельсин\", \"яблоко\", \"киви\")\n    fruits\n        .filter { it.startsWith(\"а\") }\n        .sortedBy { it }\n        .map { it.uppercase() }\n        .forEach { println(it) }\n}"
          },
          {
            "type": "code",
            "content": "АВОКАДО\nАПЕЛЬСИН"
          },
          {
            "type": "subtitle",
            "content": "Создание классов и экземпляров"
          },
          {
            "type": "text",
            "content": "Для создания класса используйте ключевое слово class."
          },
          {
            "type": "code",
            "content": "class Matrix"
          },
          {
            "type": "text",
            "content": "Свойства класса могут быть перечислены при его объявлении или в его теле."
          },
          {
            "type": "code",
            "content": "class Rectangle(var height: Double, var length: Double) {\n    var perimeter = (height + length) * 2 \n}"
          },
          {
            "type": "text",
            "content": "Конструктор по умолчанию с параметрами, перечисленными при объявлении класса, доступен автоматически."
          },
          {
            "type": "code",
            "content": "val rectangle = Rectangle(5.0, 2.0)\nprintln(\"Периметр равен ${rectangle.perimeter}\")"
          },
          {
            "type": "text",
            "content": "Чтобы объявить наследование между классами используйте двоеточие (:). По умолчанию классы являются финальными, поэтому, чтобы сделать класс наследуемым, используйте open."
          },
          {
            "type": "code",
            "content": "open class Shape\n\nclass Rectangle(var height: Double, var length: Double): Shape() {\n    var perimeter = (height + length) * 2 \n}"
          },
          {
            "type": "subtitle",
            "content": "Nullable-значения и проверка на null"
          },
          {
            "type": "text",
            "content": "Ссылка должна быть явно объявлена как nullable (символ ? в конце имени), когда она может принимать значение null."
          },
          {
            "type": "text",
            "content": "Возвращает null, если str не содержит числа."
          },
          {
            "type": "code",
            "content": "fun readInt(str: String): Int? {\n  // ...\n}"
          },
          {
            "type": "text",
            "content": "Использование функции, возвращающей null:"
          },
          {
            "type": "code",
            "content": "fun printProduct(arg1: String, arg2: String) {\n    val x = parseInt(arg1)\n    val y = parseInt(arg2)\n    \n    // Использование `x * y` приведет к ошибке, потому что они могут содержать null\n    if (x != null && y != null) {\n        // x и y автоматически приведены к не-nullable после проверки на null\n    print(x * y)\n    }\n    else {\n        println(\"'$arg1' или '$arg2' не число\")\n    }\n}"
          },
          {
            "type": "text",
            "content": "или"
          },
          {
            "type": "code",
            "content": "// ...\nif (x == null) {\n    print(\"Неверный формат числа arg1: '$arg1'\")\n    return\n}\nif (y == null) {\n    print(\"Неверный формат числа arg2: '$arg2'\")\n    return\n}\n\n// x и y автоматически приведены к не-nullable после проверки на null\n  print(x * y)"
          },
          {
            "type": "subtitle",
            "content": "Проверка типа и автоматическое приведение типов"
          },
          {
            "type": "text",
            "content": "Оператор is проверяет, является ли выражение экземпляром заданного типа. Если неизменяемая локальная переменная или свойство уже проверены на определенный тип, то в дальнейшем нет необходимости явно приводить к этому типу:"
          },
          {
            "type": "code",
            "content": "fun getStringLength(obj: Any): Int? {\n    if (obj is String) {\n        // в этом блоке `obj` автоматически преобразован в `String`\n        return obj.length\n    }\n\n    // `obj` имеет тип `Any` вне блока проверки типа\n    return null\n}"
          },
          {
            "type": "text",
            "content": "или"
          },
          {
            "type": "code",
            "content": "fun getStringLength(obj: Any): Int? {\n    if (obj !is String) return null\n\n    // в этом блоке `obj` автоматически преобразован в `String`\n    return obj.length\n}"
          },
          {
            "type": "text",
            "content": "или даже"
          },
          {
            "type": "code",
            "content": "fun getStringLength(obj: Any): Int? {\n    // `obj` автоматически преобразован в `String` справа от оператора `&&`\n    if (obj is String && obj.length > 0) {\n        return obj.length\n    }\n\n    return null\n}"
          }
        ]
      },
      {
        "id": 2,
        "title": "Идиомы",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Идиомы"
          },
          {
            "type": "text",
            "content": "Набор различных часто используемых идиом в языке Kotlin."
          },
          {
            "type": "subtitle",
            "content": "Значения по умолчанию для параметров функций"
          },
          {
            "type": "code",
            "content": "fun foo(a: Int = 0, b: String = \"\") { ... }"
          },
          {
            "type": "subtitle",
            "content": "Фильтрация списка"
          },
          {
            "type": "code",
            "content": "val positives = list.filter { x -> x > 0 }"
          },
          {
            "type": "text",
            "content": "Или короче: "
          },
          {
            "type": "code",
            "content": "val positives = list.filter { it > 0 }"
          },
          {
            "type": "subtitle",
            "content": "Проверка наличия элемента в коллекции"
          },
          {
            "type": "code",
            "content": "if (\"john@example.com\" in emailsList) { ... }\n\nif (\"jane@example.com\" !in emailsList) { ... }"
          },
          {
            "type": "subtitle",
            "content": "Форматирование строк"
          },
          {
            "type": "code",
            "content": "println(\"Name $name\")"
          },
          {
            "type": "subtitle",
            "content": "Проверка объекта на принадлежность к определённому классу "
          },
          {
            "type": "code",
            "content": "when (x) {\n    is Foo -> ...\n    is Bar -> ...\n    else   -> ...\n}"
          },
          {
            "type": "subtitle",
            "content": "Read-only список"
          },
          {
            "type": "code",
            "content": "val list = listOf(\"a\", \"b\", \"c\")"
          },
          {
            "type": "subtitle",
            "content": "Read-only ассоциативный список (map)"
          },
          {
            "type": "code",
            "content": "val map = mapOf(\"a\" to 1, \"b\" to 2, \"c\" to 3)"
          },
          {
            "type": "subtitle",
            "content": "Обращение к ассоциативному списку"
          },
          {
            "type": "code",
            "content": "println(map[\"key\"])\nmap[\"key\"] = value"
          },
          {
            "type": "subtitle",
            "content": "Итерация по ассоциативному списку или списку пар"
          },
          {
            "type": "code",
            "content": "for ((key, value) in map) {\n    println(\"$key -> $value\")\n}"
          },
          {
            "type": "subtitle",
            "content": "Итерация по диапазону"
          },
          {
            "type": "code",
            "content": "for (i in 1..100) { ... }  // закрытый диапазон: включает 100\nfor (i in 1 until 100) { ... } // полуоткрытый диапазон: не включает 100\nfor (x in 2..10 step 2) { ... }\nfor (x in 10 downTo 1) { ... }\n(1..10).forEach { ... }"
          },
          {
          "type": "subtitle",
          "content": "Ленивые свойства"
          },
          {
            "type": "code",
            "content": "val p: String by lazy { ... }"
          },
          {
            "type": "text",
            "content": "Это означает, что значение p будет вычислено только при первом обращении к нему."
          },
          {
            "type": "subtitle",
            "content": "Функции-расширения"
          },
          {
            "type": "code",
            "content": "fun String.spaceToCamelCase() { ... }\n\n\"Convert this to camelcase\".spaceToCamelCase()"
          },
          {
            "type": "subtitle",
            "content": "Создание синглтона (единичный объект)"
          },
          {
            "type": "code",
            "content": "object Resource {\n    val name = \"Name\"\n}"
          },
          {
            "type": "subtitle",
            "content": "Создание экземпляра абстрактного класса"
          },
          {
            "type": "code",
            "content": "abstract class MyAbstractClass {\n    abstract fun doSomething()\n    abstract fun sleep()\n}\n\nfun main() {\n    val myObject = object : MyAbstractClass() {\n        override fun doSomething() {\n            // ...\n        }\n\n        override fun sleep() { // ...\n        }\n    }\n    myObject.doSomething()\n}"
          },
          {
            "type": "subtitle",
            "content": "Сокращение для \"Если не null\""
          },
          {
            "type": "code",
            "content": "val files = File(\"Test\").listFiles()\n\nprintln(files?.size) // размер выводится, если размер файлов не равен null"
          },
          {
            "type": "subtitle",
            "content": "Сокращение для \"Если не null, иначе\"  (Оператор Элвиса)"
          },
          {
            "type": "code",
            "content": "val files = File(\"Test\").listFiles()\n\nprintln(files?.size ?: \"empty\") // если файл равен null, выводится \"empty\"\n"
          },
          {
            "type": "subtitle",
            "content": "Выброс исключения при равенстве null"
          },
          {
            "type": "code",
            "content": "val values = ...\nval email = values[\"email\"] ?: throw IllegalStateException(\"Email is missing!\")"
          },
          {
            "type": "subtitle",
            "content": "Получение первого элемента, возможно, пустой коллекции"
          },
          {
            "type": "code",
            "content": "val emails = ... // может быть пустой\nval mainEmail = emails.firstOrNull() ?: \"\""
          },
          {
            "type": "subtitle",
            "content": "Выполнение при неравенстве nul"
          },
          {
            "type": "code",
            "content": "val value = ...\n\nvalue?.let {\n    ... // этот блок выполняется, если value не равен null\n}"
          },
          {
            "type": "subtitle",
            "content": "Return с оператором when"
          },
          {
            "type": "code",
            "content": "fun transform(color: String): Int {\n    return when (color) {\n        \"Red\" -> 0\n        \"Green\" -> 1\n        \"Blue\" -> 2\n        else -> throw IllegalArgumentException(\"Invalid color param value\")\n    }\n}"
          },
          {
            "type": "subtitle",
            "content": "Выражение try-catch"
          },
          {
            "type": "code",
            "content": "fun test() {\n    val result = try {\n        count()\n    } catch (e: ArithmeticException) {\n        throw IllegalStateException(e)\n    }\n\n    // Working with result\n}"
          },
          {
            "type": "subtitle",
            "content": "Выражение if"
          },
          {
            "type": "code",
            "content": "val y = if (x == 1) {\n    \"one\"\n} else if (x == 2) {\n    \"two\"\n} else {\n    \"other\"\n}"
          },
          {
            "type": "subtitle",
            "content": "Функции, состоящие из одного выражения"
          },
          {
            "type": "code",
            "content": "fun theAnswer() = 42"
          },
          {
            "type": "text",
            "content": "Что равносильно этому:"
          },
          {
            "type": "code",
            "content": "fun theAnswer(): Int {\n    return 42\n}"
          },
          {
            "type": "text",
            "content": "Для сокращения кода их можно эффективно совмещать с другими идиомами. Например, с when:"
          },
          {
            "type": "code",
            "content": "fun transform(color: String): Int = when (color) {\n    \"Red\" -> 0\n    \"Green\" -> 1\n    \"Blue\" -> 2\n    else -> throw IllegalArgumentException(\"Invalid color param value\")\n}"
          },
          {
            "type": "subtitle",
            "content": "Вызов нескольких методов объекта (with)"
          },
          {
            "type": "code",
            "content": "class Turtle {\n    fun penDown()\n    fun penUp()\n    fun turn(degrees: Double)\n    fun forward(pixels: Double)\n}\n\nval myTurtle = Turtle()\nwith(myTurtle) { // нарисует квадрат размером 100 pix\n    penDown()\n    for (i in 1..4) {\n        forward(100.0)\n        turn(90.0)\n    }\n    penUp()\n}"
          },
          {
            "type": "subtitle",
            "content": "Nullable Boolean"
          },
          {
            "type": "code",
            "content": "val b: Boolean? = ...\nif (b == true) {\n    ...\n} else {\n    // `b` is false or null\n}"
          },
          {
            "type": "subtitle",
            "content": "Обмен значений переменных"
          },
          {
            "type": "code",
            "content": "var a = 1\nvar b = 2\na = b.also { b = a }"
          },
          {
            "type": "subtitle",
            "content": "Обозначение кода как незаконченного (TODO)"
          },
          {
            "type": "text",
            "content": "В стандартной библиотеке Kotlin есть функция TODO(), которая всегда выдает ошибку NotImplementedError. Её возвращаемый тип - Nothing, поэтому её можно использовать независимо от ожидаемого типа."
          },
          {
            "type": "code",
            "content": "fun calcTaxes(): BigDecimal = TODO(\"Waiting for feedback from accounting\")"
          }
        ]
      },
      {
        "id": 3,
        "title": "Стилистика кода",
        "blocks": [
          {
            "type": "subtitle",
            "content": "Соглашение о стилистике кода"
          },
          {
            "type": "text",
            "content": "Общеизвестные и простые в использовании соглашения о стилистике кода жизненно важны для любого языка программирования. Здесь предоставлены рекомендации по стилю кода и его организации для проектов, использующих Kotlin."
          },
          {
            "type": "subtitle",
            "content": "Настройка стиля в IDE"
          },
          {
            "type": "text",
            "content": "Две самые популярные IDE для Kotlin - IntelliJ IDEA и Android Studio обеспечивают широкую поддержку стиля кода."
          },
          {
            "type": "url",
            "content": "https://www.jetbrains.com/idea/"
          },
          {
            "type": "url",
            "content": "http://developer.android.com/studio"
          },
          {
            "type": "text",
            "content": "Вы можете настроить их для автоматического форматирования вашего кода в соответствии с заданным стилем."
          },
          {
            "type": "subtitle",
            "content": "\nСтруктура каталогов"
          },
          {
            "type": "text",
            "content": "В проектах, в которых используется только Kotlin, рекомендуемая структура каталогов соответствует структуре пакетов, при этом общий корневой пакет опущен. Например, если весь код в проекте находится в пакете org.example.kotlin и его подпакетах, файлы с пакетом org.example.kotlin должны размещаться непосредственно в корневом каталоге, а файлы в org.example.kotlin.network.socket должны находиться в подкаталоге корневого каталога network/socket."
          },
          {
            "type": "subtitle",
            "content": "Имена файлов"
          },
          {
            "type": "text",
            "content": "Если Kotlin файл содержит один класс (возможно со связанными объявлениями верхнего уровня), то его имя должно совпадать с именем этого класса с добавлением расширения .kt. Если файл содержит несколько классов или только объявления верхнего уровня, выберите имя, описывающее содержимое файла, и назовите файл соответствующим образом. Используйте UpperCamelCase (так же известный как Pascal case), начиная с заглавной буквы, например, ProcessDeclarations.kt.\n\nИмена файлов должны описывать, что в них делает код. Поэтому при наименовании файла вам следует избегать слов, не несущих смысла."
          },
          {
            "type": "subtitle",
            "content": "Организация файла"
          },
          {
            "type": "text",
            "content": "Размещение нескольких объявлений (классов, функций верхнего уровня или свойств) в одном исходном файле Kotlin рекомендуется до тех пор, пока эти объявления тесно связаны друг с другом семантически, а размер файла остается разумным (не более нескольких сотен строк).\n\nВ частности, при определении функций-расширения для класса, которые актуальны для всех клиентов этого класса, поместите их в один файл с самим классом. При определении функций-расширения, которые имеют смысл только для конкретного клиента, поместите их рядом с кодом этого клиента. Избегайте создания файлов только для хранения всех расширений какого-либо класса."
          },
          {
            "type": "subtitle",
            "content": "Схема классов"
          },
          {
            "type": "text",
            "content": "Содержимое класса должно располагаться в следующем порядке:\n\n\t1. Объявления свойств и блоки инициализации\n\t2. Дополнительные конструкторы\n\t3. Объявления методов\n\t4. Вспомогательный объект\n\nНе сортируйте объявления методов по алфавиту или по видимости и не отделяйте обычные методы от методов-расширения. Вместо этого соберите связанный код вместе, чтобы тот, кто читает класс сверху вниз, мог следовать логике происходящего. Выберите порядок (либо сначала материал более высокого уровня, либо наоборот) и придерживайтесь его.\n\nПоместите вложенные классы рядом с кодом, который их использует. Если эти классы предназначены для внешнего использования и на них нет ссылок внутри класса, поместите их в конце, после сопутствующего объекта."
          },
          {
            "type": "subtitle",
            "content": "Правила наименований"
          },
          {
            "type": "text",
            "content": "Правила наименования пакетов и классов в Kotlin довольно просты:\n\n\t• Имена пакетов всегда написаны в нижнем регистре и не содержат нижних подчеркиваний. Использование имен, состоящих из нескольких слов, обычно не рекомендуется, но, если вы не можете их не использовать, либо просто объедините их вместе, либо используйте при этом lowerCamelCase (org.example.myProject).\n\t• Имена классов и объектов начинаются с заглавной буквы и используют UpperCamelCase."
          },
          {
            "type": "code",
            "content": "open class DeclarationProcessor { /*...*/ }\n\nobject EmptyDeclarationProcessor : DeclarationProcessor() { /*...*/ }"
          },
          {
            "type": "subtitle",
            "content": "Имена функций"
          },
          {
            "type": "text",
            "content": "Имена функций, свойств и локальных переменных начинаются со строчной буквы и используют lowerCamelCase без нижнего подчеркивания."
          },
          {
            "type": "code",
            "content": "fun processDeclarations() { /*...*/ }\nvar declarationCount = 1"
          },
          {
            "type": "subtitle",
            "content": "Имена тестовых методов"
          },
          {
            "type": "text",
            "content": "В тестах (и только в тестах) вы можете использовать имена методов с пробелами, заключенными в обратный апостроф. Обратите внимание, что такие имена методов в настоящее время не поддерживаются средой Android. Подчеркивания в именах методов также разрешены в тестовом коде."
          },
          {
            "type": "code",
            "content": "class MyTestCase {\n     @Test fun `ensure everything works`() { /*...*/ }\n     \n     @Test fun ensureEverythingWorks_onAndroid() { /*...*/ }\n}"
          },
          {
            "type": "subtitle",
            "content": "Имена свойств"
          },
          {
            "type": "text",
            "content": "Имена констант (свойства, помеченные const, свойства верхнего уровня или объект val без функции get) должны использовать имена, разделенные подчеркиванием и написанные в верхнем регистре (SCREAMING_SNAKE_CASE)."
          },
          {
            "type": "code",
            "content": "const val MAX_COUNT = 8\nval USER_NAME_FIELD = \"UserName\""
          },
          {
            "type": "text",
            "content": "Имена свойств верхнего уровня или объектов, которые содержат объекты с поведением или изменяемыми данными, должны использовать имена lowerCamelCase."
          },
          {
            "type": "code",
            "content": "val mutableCollection: MutableSet<String> = HashSet()"
          },
          {
            "type": "subtitle",
            "content": "Имена для вспомогательных свойств"
          },
          {
            "type": "text",
            "content": "Если класс имеет два свойства, которые концептуально одинаковы, но одно из них является частью общедоступного API, а другое - деталью реализации, используйте символ нижнего подчеркивания в начале имени частного свойства:"
          },
          {
            "type": "code",
            "content": "class C {\n    private val _elementList = mutableListOf<Element>()\n    \n    val elementList: List<Element>\n         get() = _elementList\n}"
          },
          {
            "type": "subtitle",
            "content": "Выбирайте хорошие имена"
          },
          {
            "type": "text",
            "content": "Имя класса обычно представляет собой существительное или словосочетание, объясняющее, что это за класс: List, PersonReader.\n\nИмя метода обычно представляет собой глагол или фразу с глаголом, объясняющую, что делает этот метод: close, readPersons. Имя также должно указывать, изменяет ли метод объект или возвращает новый. Так, sort сортирует коллекцию, а sorted возвращает отсортированную копию коллекции.\n\nИмена должны прояснять, какова цель того или иного элемента, поэтому лучше избегать использования бессмысленных слов (Manager, Wrapper) в именах.\n\nПри использовании аббревиатуры в качестве части имени объявления, пишите её в верхнем регистре, если она состоит из двух букв (IOStream); если аббревиатура длиннее, заглавной следует оставить только первую букву (XmlFormatter, HttpInputStream)."
          },
          {
            "type": "subtitle",
            "content": "Форматирование\n"
          },
          {
            "type": "subtitle",
            "content": "Отступы"
          },
          {
            "type": "text",
            "content": "Используйте четыре пробела для отступа. Не используйте табуляцию.\n\nОткрывающую фигурную скобку поместите в конец строки, где начинается конструкция, а закрывающую скобку на отдельной строке, выровненной по горизонтали с открывающей конструкцией."
          },
          {
            "type": "code",
            "content": "if (elements != null) {\n    for (element in elements) {\n        // ...\n    }\n}"
          },
          {
            "type": "subtitle",
            "content": "Пробелы"
          },
          {
            "type": "text",
            "content": "\t• Используйте пробелы вокруг двоичных операторов (a + b). Исключение: не ставьте пробелы вокруг оператора “диапазон до” (0..i).\n\n\t• Не ставьте пробелы вокруг унарных операторов (a++).\n\n\t• Ставьте пробелы между ключевыми словами (if, when, for, and while) и соответствующей открывающей скобкой.\n\n\t• Не ставьте пробел перед открывающей скобкой в объявлении основного конструктора, объявлении метода или вызове метода."
          },
          {
            "type": "code",
            "content": "class A(val x: Int)\n\nfun foo(x: Int) { ... }\n\nfun bar() {\n    foo(1)\n}"
          },
          {
            "type": "text",
            "content": "\t•Никогда не ставьте пробел после (, [ или перед ], ).\n\n\t• Никогда не ставьте пробелы вокруг . или ?.\n\n\t• Ставьте пробел после //\n\n\t• Не ставьте пробелы вокруг угловых скобок, используемых для указания параметров типа\n\n\t• Не ставьте пробел вокруг ::\n\n\t• Не ставьте пробел перед вопросительным знаком ?, который используется для обозначения типа, допускающего обнуление: String?."
          },
          {
            "type": "text",
            "content": "Основное правило: избегайте любого горизонтального выравнивания. Переименование идентификатора в имя с другой длиной не должно влиять на форматирование."
          },
          {
            "type": "subtitle",
            "content": "Заголовки классов"
          },
          {
            "type": "text",
            "content": "Классы с небольшим количеством параметрами конструктора можно писать на одной строчке."
          },
          {
            "type": "code",
            "content": "class Person(id: Int, name: String)"
          },
          {
            "type": "text",
            "content": "Классы с более длинными сигнатурами должны быть отформатированы так, чтобы каждый параметр находится в отдельной строке с отступом. Кроме того, закрывающая скобка должна быть в новой строке. Наследование, вызов конструктора суперкласса или список реализованных интерфейсов должны располагаться в той же строке, что и скобка."
          },
          {
            "type": "code",
            "content": "class Person(\n    id: Int, \n    name: String,\n    surname: String\n) : Human(id, name) {\n    // ...\n}"
          },
          {
            "type": "subtitle",
            "content": "Порядок модификаторов"
          },
          {
            "type": "text",
            "content": "Если объявление содержит несколько модификаторов, всегда располагайте их в следующем порядке."
          },
          {
            "type": "code",
            "content": "public / protected / private / internal\nexpect / actual\nfinal / open / abstract / sealed / const\nexternal\noverride\nlateinit\ntailrec\nvararg\nsuspend\ninner\nenum / annotation / fun // модификатор в `fun interface` \ncompanion\ninline / value\ninfix\noperator\ndata"
          },
          {
            "type": "subtitle",
            "content": "Аннотации"
          },
          {
            "type": "text",
            "content": "Если сигнатура функции не помещается в одной строке, используйте следующий синтаксис."
          },
          {
            "type": "code",
            "content": "fun longMethodName(\n    argument: ArgumentType = defaultValue,\n    argument2: AnotherArgumentType,\n): ReturnType {\n    // body\n}"
          },
          {
            "type": "text",
            "content": "Используйте обычный отступ (четыре пробела) для параметров функции. Это помогает обеспечить согласованность с параметрами конструктора.\n\nДля функции, состоящей из одного выражения, предпочтительно использовать выражение в качестве тела функции."
          },
          {
            "type": "code",
            "content": "fun foo(): Int {     // плохо\n    return 1 \n}\n\nfun foo() = 1        // хорошо"
          },
          {
            "type": "subtitle",
            "content": "Свойства"
          },
          {
            "type": "text",
            "content": "Для очень простых свойств, доступных только для чтения, используйте форматирование в одну строку."
          },
          {
            "type": "code",
            "content": "val isEmpty: Boolean get() = size == 0"
          },
          {
            "type": "text",
            "content": "Для более сложных свойств всегда помещайте ключевые слова get и set в отдельные строки."
          },
          {
            "type": "subtitle",
            "content": "Операторы управления потоком"
          },
          {
            "type": "text",
            "content": "Если условие операторов if или when многострочное, всегда используйте фигурные скобки вокруг тела оператора. Делайте отступ в каждой последующей строке условия в четыре пробела. Поместите закрывающую скобку условия вместе с открывающей фигурной скобкой в отдельной строке."
          },
          {
            "type": "code",
            "content": "if (!component.isSyncing &&\n    !hasAnyKotlinRuntimeInScope(module)\n) {\n    return createKotlinNotConfiguredPanel(module)\n}"
          },
          {
            "type": "text",
            "content": "Это поможет выровнять тела условия и инструкции.\n\nПоместите ключевые слова else, catch, finally, а также ключевое слово while цикла do-while, на ту же строку, что и предыдущая фигурная скобка."
          },
          {
            "type": "code",
            "content": "if (condition) {\n    // body\n} else {\n    // else part\n}\n\ntry {\n    // body\n} finally {\n    // cleanup\n}"
          },
          {
            "type": "text",
            "content": "Если ветвь оператора when состоит более чем из одной строки, рассмотрите возможность отделения её от остальных ветвей пустой строкой."
          },
          {
            "type": "code",
            "content": "private fun parsePropertyValue(propName: String, token: Token) {\n    when (token) {\n        is Token.ValueToken ->\n            callback.visitValue(propName, token.value)\n\n        Token.LBRACE -> { // ...\n        }\n    }\n}"
          },
          {
            "type": "text",
            "content": "Поместите короткие ветви на ту же линию, что и условие, без скобок."
          },
          {
            "type": "code",
            "content": "when (foo) {\n    true -> bar() // хорошо\n    false -> { baz() } // плохо\n}"
          },
          {
            "type": "subtitle",
            "content": "Вызовы методов"
          },
          {
            "type": "text",
            "content": "В длинных списках аргументов после открывающей скобки переходите на следующую строку. Отступы аргументов в четыре пробела. Сгруппируйте несколько тесно связанных аргументов в одной строке."
          },
          {
            "type": "code",
            "content": "drawSquare(\n    x = 10, y = 10,\n    width = 100, height = 100,\n    fill = true\n)"
          },
          {
            "type": "subtitle",
            "content": "Группировка цепочки вызовов"
          },
          {
            "type": "text",
            "content": "При группировке цепочки вызовов, расположите символ . или оператор ?. на следующей строке с обычным отступом."
          },
          {
            "type": "code",
            "content": "val anchor = owner\n    ?.firstChild!!\n    .siblings(forward = true)\n    .dropWhile { it is PsiComment || it is PsiWhiteSpace }"
          },
          {
            "type": "subtitle",
            "content": "Лямбда-выражения"
          },
          {
            "type": "text",
            "content": "В лямбда-выражениях фигурные скобки и стрелка, которая отделяет параметры от тела, отделяются пробелами. Если вызов включает только одну лямбду, желательно передавать её за пределами скобок."
          },
          {
            "type": "code",
            "content": "list.filter { it > 10 }"
          },
          {
            "type": "text",
            "content": "При объявлении имен параметров в многострочной лямбде поместите имена в первую строку, за которой следует стрелка и новая строка."
          },
          {
            "type": "code",
            "content": "appendCommaSeparated(properties) { prop ->\n    val propertyValue = prop.get(obj)  // ...\n}"
          },
          {
            "type": "text",
            "content": "Если список параметров слишком длинный, чтобы поместиться в строку, поместите стрелку в отдельную строку:"
          },
          {
            "type": "code",
            "content": "foo {\n   context: Context,\n   environment: Env\n   ->\n   context.configureEnv(environment)\n}"
          },
          {
            "type": "subtitle",
            "content": "Документация комментариями"
          },
          {
            "type": "code",
            "content": "/**\n * Это документационный комментарий\n * на нескольких строках.\n */"
          },
          {
            "type": "code",
            "content": "/** Это короткий документационный комментарий. */"
          },
          {
            "type": "text",
            "content": "Следует избегать использования тегов @param и @return. Вместо этого включите описание параметров и возвращаемых значений непосредственно в документационный комментарий и добавьте ссылки на параметры везде, где они упоминаются. Используйте @param и @return только тогда, когда требуется длинное описание, которое не вписывается в основной текст."
          },
          {
            "type": "code",
            "content": "// Не делайте так:\n\n/**\n * Возвращает абсолютное значение заданного числа.\n * @param number Число, для которого будет найдено абсолютное значение.\n * @return Абсолютное значение.\n */\nfun abs(number: Int): Int { /*...*/ }\n\n// Делайте так:\n\n/**\n * Возвращает абсолютное значение заданного [number].\n */\nfun abs(number: Int): Int { /*...*/ }"
          },
          {
            "type": "subtitle",
            "content": "Идиоматическое использование функций языка\n\nНеизменность"
          },
          {
            "type": "text",
            "content": "Предпочтительнее использовать неизменяемые данные. Всегда объявляйте локальные переменные и свойства как val, а не var, если они не будут изменены после инициализации.\n\nВсегда используйте неизменяемые коллекции интерфейсов (Collection, List, Set, Map) для объявления коллекций, которые не изменяются. При использовании фабричных функций для создания экземпляров коллекции всегда используйте функции, возвращающие неизменяемые типы коллекций, когда это возможно."
          },
          {
            "type": "code",
            "content": "// Плохо: использование изменяемого типа коллекции для значения, которое не будет изменено\nfun validateValue(actualValue: String, allowedValues: HashSet<String>) { ... }\n\n// Хорошо: использование неизменяемого типа коллекции\nfun validateValue(actualValue: String, allowedValues: Set<String>) { ... }\n\n// Плохо: arrayListOf() возвращает ArrayList<T>, который является изменяемым типом\nval allowedValues = arrayListOf(\"a\", \"b\", \"c\")\n\n// Хорошо: listOf() возвращает List<T>\nval allowedValues = listOf(\"a\", \"b\", \"c\")"
          },
          {
            "type": "subtitle",
            "content": "Условные операторы"
          },
          {
            "type": "text",
            "content": "Предпочтительно использовать эту форму выражения try, if и when."
          },
          {
            "type": "code",
            "content": "return if (x) foo() else bar()"
          },
          {
            "type": "code",
            "content": "return when(x) {\n    0 -> \"zero\"\n    else -> \"nonzero\"\n}"
          },
          {
            "type": "text",
            "content": "Выше изложенное предпочтительнее, чем:"
          },
          {
            "type": "code",
            "content": "if (x)\n    return foo()\nelse\n    return bar()"
          },
          {
            "type": "code",
            "content": "when(x) {\n    0 -> return \"zero\"\n    else -> return \"nonzero\"\n} "
          },
          {
            "type": "subtitle",
            "content": "if vs when"
          },
          {
            "type": "text",
            "content": "Для двоичных условий лучше использовать if. Например, используйте этот синтаксис с if:"
          },
          {
            "type": "code",
            "content": "if (x == null) ... else ..."
          },
          {
            "type": "text",
            "content": "вместо этого с when:"
          },
          {
            "type": "code",
            "content": "when (x) {\n    null -> // ...\n    else -> // ...\n}"
          },
          {
            "type": "text",
            "content": "Предпочтительнее использовать when, если есть три и более варианта."
          },
          {
            "type": "subtitle",
            "content": "Циклы"
          },
          {
            "type": "text",
            "content": "Предпочтительнее использовать функции более высокого порядка (filter, map и т.д.), чем циклы. Исключение: forEach (лучше использовать обычный цикл for) используется только, если получатель forEach не может быть обнулен или forEach используется как часть более длинной цепочки вызовов.\n\nДелая выбор между циклом и сложным выражением, использующим несколько функций более высокого порядка, учитывайте стоимость операций, выполняемых в каждом конкретном случае, исходите из соображений производительности."
          },
          {
            "type": "subtitle",
            "content": "Циклы для диапазонов"
          },
          {
            "type": "text",
            "content": "Используйте функцию until, чтобы использовать открытый диапазон в цикле."
          },
          {
            "type": "code",
            "content": "for (i in 0..n - 1) { /*...*/ }  // плохо\nfor (i in 0 until n) { /*...*/ }  // хорошо"
          },
          {
            "type": "subtitle",
            "content": "Строки"
          },
          {
            "type": "text",
            "content": "Используйте строковые шаблоны вместо конкатенации строк.\n\nЧтобы сохранить отступ в многострочных строках, используйте trimIndent, когда результирующая строка не требует внутреннего отступа, и trimMargin, когда требуется внутренний отступ."
          },
          {
            "type": "code",
            "content": "println(\"\"\"\n    Not\n    trimmed\n    text\n    \"\"\"\n       )\n\nprintln(\"\"\"\n    Trimmed\n    text\n    \"\"\".trimIndent()\n       )\n\nprintln()\n\nval a = \"\"\"Trimmed to margin text:\n          |if(a > 1) {\n          |    return a\n          |}\"\"\".trimMargin()\n\nprintln(a)"
          }
        ]
      }
    ]
  }
]